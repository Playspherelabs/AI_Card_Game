"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_simplewebauthn_browser_dist_bundle_index_js"],{

/***/ "(app-pages-browser)/./node_modules/@simplewebauthn/browser/dist/bundle/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/dist/bundle/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebAuthnAbortService: function() { return /* binding */ WebAuthnAbortService; },\n/* harmony export */   WebAuthnError: function() { return /* binding */ WebAuthnError; },\n/* harmony export */   base64URLStringToBuffer: function() { return /* binding */ base64URLStringToBuffer; },\n/* harmony export */   browserSupportsWebAuthn: function() { return /* binding */ browserSupportsWebAuthn; },\n/* harmony export */   browserSupportsWebAuthnAutofill: function() { return /* binding */ browserSupportsWebAuthnAutofill; },\n/* harmony export */   bufferToBase64URLString: function() { return /* binding */ bufferToBase64URLString; },\n/* harmony export */   platformAuthenticatorIsAvailable: function() { return /* binding */ platformAuthenticatorIsAvailable; },\n/* harmony export */   startAuthentication: function() { return /* binding */ startAuthentication; },\n/* harmony export */   startRegistration: function() { return /* binding */ startRegistration; }\n/* harmony export */ });\n/* [@simplewebauthn/browser@9.0.1] */ function utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = \"\";\n    for (const charCode of bytes){\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const padLength = (4 - base64.length % 4) % 4;\n    const padded = base64.padEnd(base64.length + padLength, \"=\");\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for(let i = 0; i < binary.length; i++){\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\nfunction browserSupportsWebAuthn() {\n    var _window;\n    return ((_window = window) === null || _window === void 0 ? void 0 : _window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === \"function\";\n}\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports\n    };\n}\nfunction isValidDomain(hostname) {\n    return hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname);\n}\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name }){\n        super(message, {\n            cause\n        });\n        this.name = name !== null && name !== void 0 ? name : cause.name;\n        this.code = code;\n    }\n}\nfunction identifyRegistrationError(param) {\n    let { error, options } = param;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: \"Registration ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"ConstraintError\") {\n        var _publicKey_authenticatorSelection, _publicKey_authenticatorSelection1;\n        if (((_publicKey_authenticatorSelection = publicKey.authenticatorSelection) === null || _publicKey_authenticatorSelection === void 0 ? void 0 : _publicKey_authenticatorSelection.requireResidentKey) === true) {\n            return new WebAuthnError({\n                message: \"Discoverable credentials were required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT\",\n                cause: error\n            });\n        } else if (((_publicKey_authenticatorSelection1 = publicKey.authenticatorSelection) === null || _publicKey_authenticatorSelection1 === void 0 ? void 0 : _publicKey_authenticatorSelection1.userVerification) === \"required\") {\n            return new WebAuthnError({\n                message: \"User verification was required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"InvalidStateError\") {\n        return new WebAuthnError({\n            message: \"The authenticator was previously registered\",\n            code: \"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED\",\n            cause: error\n        });\n    } else if (error.name === \"NotAllowedError\") {\n        return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"NotSupportedError\") {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param)=>param.type === \"public-key\");\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: \"ERROR_MALFORMED_PUBKEYCREDPARAMS\",\n                cause: error\n            });\n        }\n        return new WebAuthnError({\n            message: \"No available authenticator supported any of the specified pubKeyCredParams algorithms\",\n            code: \"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: \"\".concat(window.location.hostname, \" is an invalid domain\"),\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: 'The RP ID \"'.concat(publicKey.rp.id, '\" is invalid for this domain'),\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"TypeError\") {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: \"User ID was not between 1 and 64 characters\",\n                code: \"ERROR_INVALID_USER_ID_LENGTH\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new credential\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return error;\n}\nclass BaseWebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error(\"Cancelling existing WebAuthn API call for new one\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error(\"Manually cancelling existing WebAuthn API call\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\nconst attachments = [\n    \"cross-platform\",\n    \"platform\"\n];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\nasync function startRegistration(creationOptionsJSON) {\n    var _creationOptionsJSON_excludeCredentials;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error(\"WebAuthn is not supported in this browser\");\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id)\n        },\n        excludeCredentials: (_creationOptionsJSON_excludeCredentials = creationOptionsJSON.excludeCredentials) === null || _creationOptionsJSON_excludeCredentials === void 0 ? void 0 : _creationOptionsJSON_excludeCredentials.map(toPublicKeyCredentialDescriptor)\n    };\n    const options = {\n        publicKey\n    };\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = await navigator.credentials.create(options);\n    } catch (err) {\n        throw identifyRegistrationError({\n            error: err,\n            options\n        });\n    }\n    if (!credential) {\n        throw new Error(\"Registration was not completed\");\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === \"function\") {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === \"function\") {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        } catch (error) {\n            warnOnBrokenImplementation(\"getPublicKeyAlgorithm()\", error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === \"function\") {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        } catch (error) {\n            warnOnBrokenImplementation(\"getPublicKey()\", error);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === \"function\") {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        } catch (error) {\n            warnOnBrokenImplementation(\"getAuthenticatorData()\", error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)\n    };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(\"The browser extension that intercepted this WebAuthn API call incorrectly implemented \".concat(methodName, \". You should report this error to them.\\n\"), cause);\n}\nfunction bufferToUTF8String(value) {\n    return new TextDecoder(\"utf-8\").decode(value);\n}\nfunction browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n        return new Promise((resolve)=>resolve(false));\n    }\n    return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\nfunction identifyAuthenticationError(param) {\n    let { error, options } = param;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: \"Authentication ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"NotAllowedError\") {\n        return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: \"\".concat(window.location.hostname, \" is an invalid domain\"),\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: 'The RP ID \"'.concat(publicKey.rpId, '\" is invalid for this domain'),\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new assertion signature\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return error;\n}\nasync function startAuthentication(requestOptionsJSON) {\n    let useBrowserAutofill = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    var _requestOptionsJSON_allowCredentials;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error(\"WebAuthn is not supported in this browser\");\n    }\n    let allowCredentials;\n    if (((_requestOptionsJSON_allowCredentials = requestOptionsJSON.allowCredentials) === null || _requestOptionsJSON_allowCredentials === void 0 ? void 0 : _requestOptionsJSON_allowCredentials.length) !== 0) {\n        var _requestOptionsJSON_allowCredentials1;\n        allowCredentials = (_requestOptionsJSON_allowCredentials1 = requestOptionsJSON.allowCredentials) === null || _requestOptionsJSON_allowCredentials1 === void 0 ? void 0 : _requestOptionsJSON_allowCredentials1.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!await browserSupportsWebAuthnAutofill()) {\n            throw Error(\"Browser does not support WebAuthn autofill\");\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        options.mediation = \"conditional\";\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = await navigator.credentials.get(options);\n    } catch (err) {\n        throw identifyAuthenticationError({\n            error: err,\n            options\n        });\n    }\n    if (!credential) {\n        throw new Error(\"Authentication was not completed\");\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment)\n    };\n}\nfunction platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve)=>resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2ltcGxld2ViYXV0aG4vYnJvd3Nlci9kaXN0L2J1bmRsZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxtQ0FBbUMsR0FDbkMsU0FBU0EsbUJBQW1CQyxLQUFLO0lBQzdCLE9BQU8sSUFBSUMsY0FBY0MsTUFBTSxDQUFDRjtBQUNwQztBQUVBLFNBQVNHLHdCQUF3QkMsTUFBTTtJQUNuQyxNQUFNQyxRQUFRLElBQUlDLFdBQVdGO0lBQzdCLElBQUlHLE1BQU07SUFDVixLQUFLLE1BQU1DLFlBQVlILE1BQU87UUFDMUJFLE9BQU9FLE9BQU9DLFlBQVksQ0FBQ0Y7SUFDL0I7SUFDQSxNQUFNRyxlQUFlQyxLQUFLTDtJQUMxQixPQUFPSSxhQUFhRSxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsT0FBTyxLQUFLQSxPQUFPLENBQUMsTUFBTTtBQUM5RTtBQUVBLFNBQVNDLHdCQUF3QkMsZUFBZTtJQUM1QyxNQUFNQyxTQUFTRCxnQkFBZ0JGLE9BQU8sQ0FBQyxNQUFNLEtBQUtBLE9BQU8sQ0FBQyxNQUFNO0lBQ2hFLE1BQU1JLFlBQVksQ0FBQyxJQUFLRCxPQUFPRSxNQUFNLEdBQUcsQ0FBQyxJQUFLO0lBQzlDLE1BQU1DLFNBQVNILE9BQU9JLE1BQU0sQ0FBQ0osT0FBT0UsTUFBTSxHQUFHRCxXQUFXO0lBQ3hELE1BQU1JLFNBQVNDLEtBQUtIO0lBQ3BCLE1BQU1mLFNBQVMsSUFBSW1CLFlBQVlGLE9BQU9ILE1BQU07SUFDNUMsTUFBTWIsUUFBUSxJQUFJQyxXQUFXRjtJQUM3QixJQUFLLElBQUlvQixJQUFJLEdBQUdBLElBQUlILE9BQU9ILE1BQU0sRUFBRU0sSUFBSztRQUNwQ25CLEtBQUssQ0FBQ21CLEVBQUUsR0FBR0gsT0FBT0ksVUFBVSxDQUFDRDtJQUNqQztJQUNBLE9BQU9wQjtBQUNYO0FBRUEsU0FBU3NCO1FBQ0dDO0lBQVIsT0FBUUEsRUFBQUEsVUFBQUEs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RyxFQUFFO0lBQ25DO0lBQ0ExRSxRQUFRQyxTQUFTLEdBQUdBO0lBQ3BCRCxRQUFRRSxNQUFNLEdBQUd1QixxQkFBcUJQLG9CQUFvQjtJQUMxRCxJQUFJaUI7SUFDSixJQUFJO1FBQ0FBLGFBQWMsTUFBTUMsVUFBVUMsV0FBVyxDQUFDMEMsR0FBRyxDQUFDL0U7SUFDbEQsRUFDQSxPQUFPdUMsS0FBSztRQUNSLE1BQU04Qiw0QkFBNEI7WUFBRXRFLE9BQU93QztZQUFLdkM7UUFBUTtJQUM1RDtJQUNBLElBQUksQ0FBQ21DLFlBQVk7UUFDYixNQUFNLElBQUkzQyxNQUFNO0lBQ3BCO0lBQ0EsTUFBTSxFQUFFTixFQUFFLEVBQUVzRCxLQUFLLEVBQUVDLFFBQVEsRUFBRTlCLElBQUksRUFBRSxHQUFHd0I7SUFDdEMsSUFBSTZDLGFBQWFqRztJQUNqQixJQUFJMEQsU0FBU3VDLFVBQVUsRUFBRTtRQUNyQkEsYUFBYW5CLG1CQUFtQnBCLFNBQVN1QyxVQUFVO0lBQ3ZEO0lBQ0EsT0FBTztRQUNIOUY7UUFDQXNELE9BQU9uRix3QkFBd0JtRjtRQUMvQkMsVUFBVTtZQUNOYSxtQkFBbUJqRyx3QkFBd0JvRixTQUFTYSxpQkFBaUI7WUFDckVGLGdCQUFnQi9GLHdCQUF3Qm9GLFNBQVNXLGNBQWM7WUFDL0Q2QixXQUFXNUgsd0JBQXdCb0YsU0FBU3dDLFNBQVM7WUFDckREO1FBQ0o7UUFDQXJFO1FBQ0E0Qyx3QkFBd0JwQixXQUFXcUIseUJBQXlCO1FBQzVEQyx5QkFBeUI5QiwwQkFBMEJRLFdBQVdzQix1QkFBdUI7SUFDekY7QUFDSjtBQUVBLFNBQVN5QjtJQUNMLElBQUksQ0FBQ3RHLDJCQUEyQjtRQUM1QixPQUFPLElBQUl1RixRQUFRLENBQUNDLFVBQVlBLFFBQVE7SUFDNUM7SUFDQSxPQUFPdEYsb0JBQW9CcUcsNkNBQTZDO0FBQzVFO0FBRXFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2ltcGxld2ViYXV0aG4vYnJvd3Nlci9kaXN0L2J1bmRsZS9pbmRleC5qcz81NmZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFtAc2ltcGxld2ViYXV0aG4vYnJvd3NlckA5LjAuMV0gKi9cbmZ1bmN0aW9uIHV0ZjhTdHJpbmdUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhidWZmZXIpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAoY29uc3QgY2hhckNvZGUgb2YgYnl0ZXMpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSBidG9hKHN0cik7XG4gICAgcmV0dXJuIGJhc2U2NFN0cmluZy5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89L2csICcnKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VVJMU3RyaW5nVG9CdWZmZXIoYmFzZTY0VVJMU3RyaW5nKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gYmFzZTY0VVJMU3RyaW5nLnJlcGxhY2UoLy0vZywgJysnKS5yZXBsYWNlKC9fL2csICcvJyk7XG4gICAgY29uc3QgcGFkTGVuZ3RoID0gKDQgLSAoYmFzZTY0Lmxlbmd0aCAlIDQpKSAlIDQ7XG4gICAgY29uc3QgcGFkZGVkID0gYmFzZTY0LnBhZEVuZChiYXNlNjQubGVuZ3RoICsgcGFkTGVuZ3RoLCAnPScpO1xuICAgIGNvbnN0IGJpbmFyeSA9IGF0b2IocGFkZGVkKTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYmluYXJ5Lmxlbmd0aCk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuKCkge1xuICAgIHJldHVybiAod2luZG93Py5QdWJsaWNLZXlDcmVkZW50aWFsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5QdWJsaWNLZXlDcmVkZW50aWFsID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gdG9QdWJsaWNLZXlDcmVkZW50aWFsRGVzY3JpcHRvcihkZXNjcmlwdG9yKSB7XG4gICAgY29uc3QgeyBpZCB9ID0gZGVzY3JpcHRvcjtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZXNjcmlwdG9yLFxuICAgICAgICBpZDogYmFzZTY0VVJMU3RyaW5nVG9CdWZmZXIoaWQpLFxuICAgICAgICB0cmFuc3BvcnRzOiBkZXNjcmlwdG9yLnRyYW5zcG9ydHMsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZERvbWFpbihob3N0bmFtZSkge1xuICAgIHJldHVybiAoaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8XG4gICAgICAgIC9eKFthLXowLTldKygtW2EtejAtOV0rKSpcXC4pK1thLXpdezIsfSQvaS50ZXN0KGhvc3RuYW1lKSk7XG59XG5cbmNsYXNzIFdlYkF1dGhuRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzYWdlLCBjb2RlLCBjYXVzZSwgbmFtZSwgfSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCB7IGNhdXNlIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lID8/IGNhdXNlLm5hbWU7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yKHsgZXJyb3IsIG9wdGlvbnMsIH0pIHtcbiAgICBjb25zdCB7IHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICB0aHJvdyBFcnJvcignb3B0aW9ucyB3YXMgbWlzc2luZyByZXF1aXJlZCBwdWJsaWNLZXkgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVnaXN0cmF0aW9uIGNlcmVtb255IHdhcyBzZW50IGFuIGFib3J0IHNpZ25hbCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0NFUkVNT05ZX0FCT1JURUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdDb25zdHJhaW50RXJyb3InKSB7XG4gICAgICAgIGlmIChwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbj8ucmVxdWlyZVJlc2lkZW50S2V5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdEaXNjb3ZlcmFibGUgY3JlZGVudGlhbHMgd2VyZSByZXF1aXJlZCBidXQgbm8gYXZhaWxhYmxlIGF1dGhlbnRpY2F0b3Igc3VwcG9ydGVkIGl0JyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9NSVNTSU5HX0RJU0NPVkVSQUJMRV9DUkVERU5USUFMX1NVUFBPUlQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1YmxpY0tleS5hdXRoZW50aWNhdG9yU2VsZWN0aW9uPy51c2VyVmVyaWZpY2F0aW9uID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIHZlcmlmaWNhdGlvbiB3YXMgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19VU0VSX1ZFUklGSUNBVElPTl9TVVBQT1JUJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCcsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9QUkVWSU9VU0xZX1JFR0lTVEVSRUQnLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RTdXBwb3J0ZWRFcnJvcicpIHtcbiAgICAgICAgY29uc3QgdmFsaWRQdWJLZXlDcmVkUGFyYW1zID0gcHVibGljS2V5LnB1YktleUNyZWRQYXJhbXMuZmlsdGVyKChwYXJhbSkgPT4gcGFyYW0udHlwZSA9PT0gJ3B1YmxpYy1rZXknKTtcbiAgICAgICAgaWYgKHZhbGlkUHViS2V5Q3JlZFBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ05vIGVudHJ5IGluIHB1YktleUNyZWRQYXJhbXMgd2FzIG9mIHR5cGUgXCJwdWJsaWMta2V5XCInLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9NQUxGT1JNRURfUFVCS0VZQ1JFRFBBUkFNUycsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdObyBhdmFpbGFibGUgYXV0aGVudGljYXRvciBzdXBwb3J0ZWQgYW55IG9mIHRoZSBzcGVjaWZpZWQgcHViS2V5Q3JlZFBhcmFtcyBhbGdvcml0aG1zJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX05PX1NVUFBPUlRFRF9QVUJLRVlDUkVEUEFSQU1TX0FMRycsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnU2VjdXJpdHlFcnJvcicpIHtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlRG9tYWluID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgICAgICBpZiAoIWlzVmFsaWREb21haW4oZWZmZWN0aXZlRG9tYWluKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgJHt3aW5kb3cubG9jYXRpb24uaG9zdG5hbWV9IGlzIGFuIGludmFsaWQgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9ET01BSU4nLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1YmxpY0tleS5ycC5pZCAhPT0gZWZmZWN0aXZlRG9tYWluKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBUaGUgUlAgSUQgXCIke3B1YmxpY0tleS5ycC5pZH1cIiBpcyBpbnZhbGlkIGZvciB0aGlzIGRvbWFpbmAsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfUlBfSUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgIGlmIChwdWJsaWNLZXkudXNlci5pZC5ieXRlTGVuZ3RoIDwgMSB8fCBwdWJsaWNLZXkudXNlci5pZC5ieXRlTGVuZ3RoID4gNjQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VzZXIgSUQgd2FzIG5vdCBiZXR3ZWVuIDEgYW5kIDY0IGNoYXJhY3RlcnMnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1VTRVJfSURfTEVOR1RIJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVW5rbm93bkVycm9yJykge1xuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBhdXRoZW50aWNhdG9yIHdhcyB1bmFibGUgdG8gcHJvY2VzcyB0aGUgc3BlY2lmaWVkIG9wdGlvbnMsIG9yIGNvdWxkIG5vdCBjcmVhdGUgYSBuZXcgY3JlZGVudGlhbCcsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9HRU5FUkFMX0VSUk9SJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cblxuY2xhc3MgQmFzZVdlYkF1dGhuQWJvcnRTZXJ2aWNlIHtcbiAgICBjcmVhdGVOZXdBYm9ydFNpZ25hbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignQ2FuY2VsbGluZyBleGlzdGluZyBXZWJBdXRobiBBUEkgY2FsbCBmb3IgbmV3IG9uZScpO1xuICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KGFib3J0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IG5ld0NvbnRyb2xsZXI7XG4gICAgICAgIHJldHVybiBuZXdDb250cm9sbGVyLnNpZ25hbDtcbiAgICB9XG4gICAgY2FuY2VsQ2VyZW1vbnkoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoJ01hbnVhbGx5IGNhbmNlbGxpbmcgZXhpc3RpbmcgV2ViQXV0aG4gQVBJIGNhbGwnKTtcbiAgICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydChhYm9ydEVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IFdlYkF1dGhuQWJvcnRTZXJ2aWNlID0gbmV3IEJhc2VXZWJBdXRobkFib3J0U2VydmljZSgpO1xuXG5jb25zdCBhdHRhY2htZW50cyA9IFsnY3Jvc3MtcGxhdGZvcm0nLCAncGxhdGZvcm0nXTtcbmZ1bmN0aW9uIHRvQXV0aGVudGljYXRvckF0dGFjaG1lbnQoYXR0YWNobWVudCkge1xuICAgIGlmICghYXR0YWNobWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhdHRhY2htZW50cy5pbmRleE9mKGF0dGFjaG1lbnQpIDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhdHRhY2htZW50O1xufVxuXG5hc3luYyBmdW5jdGlvbiBzdGFydFJlZ2lzdHJhdGlvbihjcmVhdGlvbk9wdGlvbnNKU09OKSB7XG4gICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViQXV0aG4gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0ge1xuICAgICAgICAuLi5jcmVhdGlvbk9wdGlvbnNKU09OLFxuICAgICAgICBjaGFsbGVuZ2U6IGJhc2U2NFVSTFN0cmluZ1RvQnVmZmVyKGNyZWF0aW9uT3B0aW9uc0pTT04uY2hhbGxlbmdlKSxcbiAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgLi4uY3JlYXRpb25PcHRpb25zSlNPTi51c2VyLFxuICAgICAgICAgICAgaWQ6IHV0ZjhTdHJpbmdUb0J1ZmZlcihjcmVhdGlvbk9wdGlvbnNKU09OLnVzZXIuaWQpLFxuICAgICAgICB9LFxuICAgICAgICBleGNsdWRlQ3JlZGVudGlhbHM6IGNyZWF0aW9uT3B0aW9uc0pTT04uZXhjbHVkZUNyZWRlbnRpYWxzPy5tYXAodG9QdWJsaWNLZXlDcmVkZW50aWFsRGVzY3JpcHRvciksXG4gICAgfTtcbiAgICBjb25zdCBvcHRpb25zID0geyBwdWJsaWNLZXkgfTtcbiAgICBvcHRpb25zLnNpZ25hbCA9IFdlYkF1dGhuQWJvcnRTZXJ2aWNlLmNyZWF0ZU5ld0Fib3J0U2lnbmFsKCk7XG4gICAgbGV0IGNyZWRlbnRpYWw7XG4gICAgdHJ5IHtcbiAgICAgICAgY3JlZGVudGlhbCA9IChhd2FpdCBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yKHsgZXJyb3I6IGVyciwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgaWYgKCFjcmVkZW50aWFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVnaXN0cmF0aW9uIHdhcyBub3QgY29tcGxldGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHJhd0lkLCByZXNwb25zZSwgdHlwZSB9ID0gY3JlZGVudGlhbDtcbiAgICBsZXQgdHJhbnNwb3J0cyA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmdldFRyYW5zcG9ydHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdHJhbnNwb3J0cyA9IHJlc3BvbnNlLmdldFRyYW5zcG9ydHMoKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlUHVibGljS2V5QWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZ2V0UHVibGljS2V5QWxnb3JpdGhtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZVB1YmxpY0tleUFsZ29yaXRobSA9IHJlc3BvbnNlLmdldFB1YmxpY0tleUFsZ29yaXRobSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgd2Fybk9uQnJva2VuSW1wbGVtZW50YXRpb24oJ2dldFB1YmxpY0tleUFsZ29yaXRobSgpJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByZXNwb25zZVB1YmxpY0tleSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmdldFB1YmxpY0tleSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgX3B1YmxpY0tleSA9IHJlc3BvbnNlLmdldFB1YmxpY0tleSgpO1xuICAgICAgICAgICAgaWYgKF9wdWJsaWNLZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVB1YmxpY0tleSA9IGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKF9wdWJsaWNLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgd2Fybk9uQnJva2VuSW1wbGVtZW50YXRpb24oJ2dldFB1YmxpY0tleSgpJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByZXNwb25zZUF1dGhlbnRpY2F0b3JEYXRhO1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZ2V0QXV0aGVudGljYXRvckRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlQXV0aGVudGljYXRvckRhdGEgPSBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhyZXNwb25zZS5nZXRBdXRoZW50aWNhdG9yRGF0YSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdhcm5PbkJyb2tlbkltcGxlbWVudGF0aW9uKCdnZXRBdXRoZW50aWNhdG9yRGF0YSgpJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICByYXdJZDogYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcocmF3SWQpLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgYXR0ZXN0YXRpb25PYmplY3Q6IGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKHJlc3BvbnNlLmF0dGVzdGF0aW9uT2JqZWN0KSxcbiAgICAgICAgICAgIGNsaWVudERhdGFKU09OOiBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhyZXNwb25zZS5jbGllbnREYXRhSlNPTiksXG4gICAgICAgICAgICB0cmFuc3BvcnRzLFxuICAgICAgICAgICAgcHVibGljS2V5QWxnb3JpdGhtOiByZXNwb25zZVB1YmxpY0tleUFsZ29yaXRobSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcmVzcG9uc2VQdWJsaWNLZXksXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogcmVzcG9uc2VBdXRoZW50aWNhdG9yRGF0YSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0czogY3JlZGVudGlhbC5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCksXG4gICAgICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiB0b0F1dGhlbnRpY2F0b3JBdHRhY2htZW50KGNyZWRlbnRpYWwuYXV0aGVudGljYXRvckF0dGFjaG1lbnQpLFxuICAgIH07XG59XG5mdW5jdGlvbiB3YXJuT25Ccm9rZW5JbXBsZW1lbnRhdGlvbihtZXRob2ROYW1lLCBjYXVzZSkge1xuICAgIGNvbnNvbGUud2FybihgVGhlIGJyb3dzZXIgZXh0ZW5zaW9uIHRoYXQgaW50ZXJjZXB0ZWQgdGhpcyBXZWJBdXRobiBBUEkgY2FsbCBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCAke21ldGhvZE5hbWV9LiBZb3Ugc2hvdWxkIHJlcG9ydCB0aGlzIGVycm9yIHRvIHRoZW0uXFxuYCwgY2F1c2UpO1xufVxuXG5mdW5jdGlvbiBidWZmZXJUb1VURjhTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpLmRlY29kZSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuQXV0b2ZpbGwoKSB7XG4gICAgY29uc3QgZ2xvYmFsUHVibGljS2V5Q3JlZGVudGlhbCA9IHdpbmRvd1xuICAgICAgICAuUHVibGljS2V5Q3JlZGVudGlhbDtcbiAgICBpZiAoZ2xvYmFsUHVibGljS2V5Q3JlZGVudGlhbC5pc0NvbmRpdGlvbmFsTWVkaWF0aW9uQXZhaWxhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlKGZhbHNlKSk7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxQdWJsaWNLZXlDcmVkZW50aWFsLmlzQ29uZGl0aW9uYWxNZWRpYXRpb25BdmFpbGFibGUoKTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yKHsgZXJyb3IsIG9wdGlvbnMsIH0pIHtcbiAgICBjb25zdCB7IHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICB0aHJvdyBFcnJvcignb3B0aW9ucyB3YXMgbWlzc2luZyByZXF1aXJlZCBwdWJsaWNLZXkgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQXV0aGVudGljYXRpb24gY2VyZW1vbnkgd2FzIHNlbnQgYW4gYWJvcnQgc2lnbmFsJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdTZWN1cml0eUVycm9yJykge1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVEb21haW4gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIGlmICghaXNWYWxpZERvbWFpbihlZmZlY3RpdmVEb21haW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX0RPTUFJTicsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHVibGljS2V5LnJwSWQgIT09IGVmZmVjdGl2ZURvbWFpbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVGhlIFJQIElEIFwiJHtwdWJsaWNLZXkucnBJZH1cIiBpcyBpbnZhbGlkIGZvciB0aGlzIGRvbWFpbmAsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfUlBfSUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdVbmtub3duRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHVuYWJsZSB0byBwcm9jZXNzIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgb3IgY291bGQgbm90IGNyZWF0ZSBhIG5ldyBhc3NlcnRpb24gc2lnbmF0dXJlJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX0dFTkVSQUxfRVJST1InLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzdGFydEF1dGhlbnRpY2F0aW9uKHJlcXVlc3RPcHRpb25zSlNPTiwgdXNlQnJvd3NlckF1dG9maWxsID0gZmFsc2UpIHtcbiAgICBpZiAoIWJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJBdXRobiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgIH1cbiAgICBsZXQgYWxsb3dDcmVkZW50aWFscztcbiAgICBpZiAocmVxdWVzdE9wdGlvbnNKU09OLmFsbG93Q3JlZGVudGlhbHM/Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBhbGxvd0NyZWRlbnRpYWxzID0gcmVxdWVzdE9wdGlvbnNKU09OLmFsbG93Q3JlZGVudGlhbHM/Lm1hcCh0b1B1YmxpY0tleUNyZWRlbnRpYWxEZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0ge1xuICAgICAgICAuLi5yZXF1ZXN0T3B0aW9uc0pTT04sXG4gICAgICAgIGNoYWxsZW5nZTogYmFzZTY0VVJMU3RyaW5nVG9CdWZmZXIocmVxdWVzdE9wdGlvbnNKU09OLmNoYWxsZW5nZSksXG4gICAgICAgIGFsbG93Q3JlZGVudGlhbHMsXG4gICAgfTtcbiAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgaWYgKHVzZUJyb3dzZXJBdXRvZmlsbCkge1xuICAgICAgICBpZiAoIShhd2FpdCBicm93c2VyU3VwcG9ydHNXZWJBdXRobkF1dG9maWxsKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkF1dGhuIGF1dG9maWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxpZ2libGVJbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFthdXRvY29tcGxldGUkPVxcJ3dlYmF1dGhuXFwnXScpO1xuICAgICAgICBpZiAoZWxpZ2libGVJbnB1dHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ05vIDxpbnB1dD4gd2l0aCBcIndlYmF1dGhuXCIgYXMgdGhlIG9ubHkgb3IgbGFzdCB2YWx1ZSBpbiBpdHMgYGF1dG9jb21wbGV0ZWAgYXR0cmlidXRlIHdhcyBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMubWVkaWF0aW9uID0gJ2NvbmRpdGlvbmFsJztcbiAgICAgICAgcHVibGljS2V5LmFsbG93Q3JlZGVudGlhbHMgPSBbXTtcbiAgICB9XG4gICAgb3B0aW9ucy5wdWJsaWNLZXkgPSBwdWJsaWNLZXk7XG4gICAgb3B0aW9ucy5zaWduYWwgPSBXZWJBdXRobkFib3J0U2VydmljZS5jcmVhdGVOZXdBYm9ydFNpZ25hbCgpO1xuICAgIGxldCBjcmVkZW50aWFsO1xuICAgIHRyeSB7XG4gICAgICAgIGNyZWRlbnRpYWwgPSAoYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldChvcHRpb25zKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yKHsgZXJyb3I6IGVyciwgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgaWYgKCFjcmVkZW50aWFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gd2FzIG5vdCBjb21wbGV0ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcmF3SWQsIHJlc3BvbnNlLCB0eXBlIH0gPSBjcmVkZW50aWFsO1xuICAgIGxldCB1c2VySGFuZGxlID0gdW5kZWZpbmVkO1xuICAgIGlmIChyZXNwb25zZS51c2VySGFuZGxlKSB7XG4gICAgICAgIHVzZXJIYW5kbGUgPSBidWZmZXJUb1VURjhTdHJpbmcocmVzcG9uc2UudXNlckhhbmRsZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICByYXdJZDogYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcocmF3SWQpLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgYXV0aGVudGljYXRvckRhdGE6IGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKHJlc3BvbnNlLmF1dGhlbnRpY2F0b3JEYXRhKSxcbiAgICAgICAgICAgIGNsaWVudERhdGFKU09OOiBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhyZXNwb25zZS5jbGllbnREYXRhSlNPTiksXG4gICAgICAgICAgICBzaWduYXR1cmU6IGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKHJlc3BvbnNlLnNpZ25hdHVyZSksXG4gICAgICAgICAgICB1c2VySGFuZGxlLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlLFxuICAgICAgICBjbGllbnRFeHRlbnNpb25SZXN1bHRzOiBjcmVkZW50aWFsLmdldENsaWVudEV4dGVuc2lvblJlc3VsdHMoKSxcbiAgICAgICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6IHRvQXV0aGVudGljYXRvckF0dGFjaG1lbnQoY3JlZGVudGlhbC5hdXRoZW50aWNhdG9yQXR0YWNobWVudCksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGxhdGZvcm1BdXRoZW50aWNhdG9ySXNBdmFpbGFibGUoKSB7XG4gICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShmYWxzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHVibGljS2V5Q3JlZGVudGlhbC5pc1VzZXJWZXJpZnlpbmdQbGF0Zm9ybUF1dGhlbnRpY2F0b3JBdmFpbGFibGUoKTtcbn1cblxuZXhwb3J0IHsgV2ViQXV0aG5BYm9ydFNlcnZpY2UsIFdlYkF1dGhuRXJyb3IsIGJhc2U2NFVSTFN0cmluZ1RvQnVmZmVyLCBicm93c2VyU3VwcG9ydHNXZWJBdXRobiwgYnJvd3NlclN1cHBvcnRzV2ViQXV0aG5BdXRvZmlsbCwgYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcsIHBsYXRmb3JtQXV0aGVudGljYXRvcklzQXZhaWxhYmxlLCBzdGFydEF1dGhlbnRpY2F0aW9uLCBzdGFydFJlZ2lzdHJhdGlvbiB9O1xuIl0sIm5hbWVzIjpbInV0ZjhTdHJpbmdUb0J1ZmZlciIsInZhbHVlIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyIsImJ1ZmZlciIsImJ5dGVzIiwiVWludDhBcnJheSIsInN0ciIsImNoYXJDb2RlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYmFzZTY0U3RyaW5nIiwiYnRvYSIsInJlcGxhY2UiLCJiYXNlNjRVUkxTdHJpbmdUb0J1ZmZlciIsImJhc2U2NFVSTFN0cmluZyIsImJhc2U2NCIsInBhZExlbmd0aCIsImxlbmd0aCIsInBhZGRlZCIsInBhZEVuZCIsImJpbmFyeSIsImF0b2IiLCJBcnJheUJ1ZmZlciIsImkiLCJjaGFyQ29kZUF0IiwiYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4iLCJ3aW5kb3ciLCJQdWJsaWNLZXlDcmVkZW50aWFsIiwidW5kZWZpbmVkIiwidG9QdWJsaWNLZXlDcmVkZW50aWFsRGVzY3JpcHRvciIsImRlc2NyaXB0b3IiLCJpZCIsInRyYW5zcG9ydHMiLCJpc1ZhbGlkRG9tYWluIiwiaG9zdG5hbWUiLCJ0ZXN0IiwiV2ViQXV0aG5FcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiY29kZSIsImNhdXNlIiwibmFtZSIsImlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IiLCJlcnJvciIsIm9wdGlvbnMiLCJwdWJsaWNLZXkiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsImF1dGhlbnRpY2F0b3JTZWxlY3Rpb24iLCJyZXF1aXJlUmVzaWRlbnRLZXkiLCJ1c2VyVmVyaWZpY2F0aW9uIiwidmFsaWRQdWJLZXlDcmVkUGFyYW1zIiwicHViS2V5Q3JlZFBhcmFtcyIsImZpbHRlciIsInBhcmFtIiwidHlwZSIsImVmZmVjdGl2ZURvbWFpbiIsImxvY2F0aW9uIiwicnAiLCJ1c2VyIiwiYnl0ZUxlbmd0aCIsIkJhc2VXZWJBdXRobkFib3J0U2VydmljZSIsImNyZWF0ZU5ld0Fib3J0U2lnbmFsIiwiY29udHJvbGxlciIsImFib3J0RXJyb3IiLCJhYm9ydCIsIm5ld0NvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJjYW5jZWxDZXJlbW9ueSIsIldlYkF1dGhuQWJvcnRTZXJ2aWNlIiwiYXR0YWNobWVudHMiLCJ0b0F1dGhlbnRpY2F0b3JBdHRhY2htZW50IiwiYXR0YWNobWVudCIsImluZGV4T2YiLCJzdGFydFJlZ2lzdHJhdGlvbiIsImNyZWF0aW9uT3B0aW9uc0pTT04iLCJjaGFsbGVuZ2UiLCJleGNsdWRlQ3JlZGVudGlhbHMiLCJtYXAiLCJjcmVkZW50aWFsIiwibmF2aWdhdG9yIiwiY3JlZGVudGlhbHMiLCJjcmVhdGUiLCJlcnIiLCJyYXdJZCIsInJlc3BvbnNlIiwiZ2V0VHJhbnNwb3J0cyIsInJlc3BvbnNlUHVibGljS2V5QWxnb3JpdGhtIiwiZ2V0UHVibGljS2V5QWxnb3JpdGhtIiwid2Fybk9uQnJva2VuSW1wbGVtZW50YXRpb24iLCJyZXNwb25zZVB1YmxpY0tleSIsImdldFB1YmxpY0tleSIsIl9wdWJsaWNLZXkiLCJyZXNwb25zZUF1dGhlbnRpY2F0b3JEYXRhIiwiZ2V0QXV0aGVudGljYXRvckRhdGEiLCJhdHRlc3RhdGlvbk9iamVjdCIsImNsaWVudERhdGFKU09OIiwicHVibGljS2V5QWxnb3JpdGhtIiwiYXV0aGVudGljYXRvckRhdGEiLCJjbGllbnRFeHRlbnNpb25SZXN1bHRzIiwiZ2V0Q2xpZW50RXh0ZW5zaW9uUmVzdWx0cyIsImF1dGhlbnRpY2F0b3JBdHRhY2htZW50IiwibWV0aG9kTmFtZSIsImNvbnNvbGUiLCJ3YXJuIiwiYnVmZmVyVG9VVEY4U3RyaW5nIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJicm93c2VyU3VwcG9ydHNXZWJBdXRobkF1dG9maWxsIiwiZ2xvYmFsUHVibGljS2V5Q3JlZGVudGlhbCIsImlzQ29uZGl0aW9uYWxNZWRpYXRpb25BdmFpbGFibGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciIsInJwSWQiLCJzdGFydEF1dGhlbnRpY2F0aW9uIiwicmVxdWVzdE9wdGlvbnNKU09OIiwidXNlQnJvd3NlckF1dG9maWxsIiwiYWxsb3dDcmVkZW50aWFscyIsImVsaWdpYmxlSW5wdXRzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwibWVkaWF0aW9uIiwiZ2V0IiwidXNlckhhbmRsZSIsInNpZ25hdHVyZSIsInBsYXRmb3JtQXV0aGVudGljYXRvcklzQXZhaWxhYmxlIiwiaXNVc2VyVmVyaWZ5aW5nUGxhdGZvcm1BdXRoZW50aWNhdG9yQXZhaWxhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@simplewebauthn/browser/dist/bundle/index.js\n"));

/***/ })

}]);