"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-fetch-native";
exports.ids = ["vendor-chunks/node-fetch-native"];
exports.modules = {

/***/ "(ssr)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/chunks/multipart-parser.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toFormData: () => (/* binding */ Z)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ \"node:path\");\n/* harmony import */ var _node_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node.mjs */ \"(ssr)/./node_modules/node-fetch-native/dist/node.mjs\");\n/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:http */ \"node:http\");\n/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:https */ \"node:https\");\n/* harmony import */ var node_zlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:zlib */ \"node:zlib\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node:buffer */ \"node:buffer\");\n/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! node:util */ \"node:util\");\n/* harmony import */ var _shared_node_fetch_native_1a4a356d_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../shared/node-fetch-native.1a4a356d.mjs */ \"(ssr)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.1a4a356d.mjs\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_net__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! node:net */ \"node:net\");\nvar B = Object.defineProperty;\nvar E = (u, a)=>B(u, \"name\", {\n        value: a,\n        configurable: !0\n    });\n\n\n\n\n\n\n\n\n\n\n\n\nlet D = 0;\nconst t = {\n    START_BOUNDARY: D++,\n    HEADER_FIELD_START: D++,\n    HEADER_FIELD: D++,\n    HEADER_VALUE_START: D++,\n    HEADER_VALUE: D++,\n    HEADER_VALUE_ALMOST_DONE: D++,\n    HEADERS_ALMOST_DONE: D++,\n    PART_DATA_START: D++,\n    PART_DATA: D++,\n    END: D++\n};\nlet w = 1;\nconst R = {\n    PART_BOUNDARY: w,\n    LAST_BOUNDARY: w *= 2\n}, g = 10, N = 13, x = 32, P = 45, C = 58, I = 97, M = 122, $ = E((u)=>u | 32, \"lower\"), m = E(()=>{}, \"noop\"), F = class F {\n    constructor(a){\n        this.index = 0, this.flags = 0, this.onHeaderEnd = m, this.onHeaderField = m, this.onHeadersEnd = m, this.onHeaderValue = m, this.onPartBegin = m, this.onPartData = m, this.onPartEnd = m, this.boundaryChars = {}, a = `\\r\n--` + a;\n        const n = new Uint8Array(a.length);\n        for(let r = 0; r < a.length; r++)n[r] = a.charCodeAt(r), this.boundaryChars[n[r]] = !0;\n        this.boundary = n, this.lookbehind = new Uint8Array(this.boundary.length + 8), this.state = t.START_BOUNDARY;\n    }\n    write(a) {\n        let n = 0;\n        const r = a.length;\n        let d = this.index, { lookbehind: l, boundary: c, boundaryChars: p, index: e, state: i, flags: A } = this;\n        const H = this.boundary.length, O = H - 1, y = a.length;\n        let o, L;\n        const f = E((h)=>{\n            this[h + \"Mark\"] = n;\n        }, \"mark\"), s = E((h)=>{\n            delete this[h + \"Mark\"];\n        }, \"clear\"), T = E((h, S, _, U)=>{\n            (S === void 0 || S !== _) && this[h](U && U.subarray(S, _));\n        }, \"callback\"), b = E((h, S)=>{\n            const _ = h + \"Mark\";\n            _ in this && (S ? (T(h, this[_], n, a), delete this[_]) : (T(h, this[_], a.length, a), this[_] = 0));\n        }, \"dataCallback\");\n        for(n = 0; n < r; n++)switch(o = a[n], i){\n            case t.START_BOUNDARY:\n                if (e === c.length - 2) {\n                    if (o === P) A |= R.LAST_BOUNDARY;\n                    else if (o !== N) return;\n                    e++;\n                    break;\n                } else if (e - 1 === c.length - 2) {\n                    if (A & R.LAST_BOUNDARY && o === P) i = t.END, A = 0;\n                    else if (!(A & R.LAST_BOUNDARY) && o === g) e = 0, T(\"onPartBegin\"), i = t.HEADER_FIELD_START;\n                    else return;\n                    break;\n                }\n                o !== c[e + 2] && (e = -2), o === c[e + 2] && e++;\n                break;\n            case t.HEADER_FIELD_START:\n                i = t.HEADER_FIELD, f(\"onHeaderField\"), e = 0;\n            case t.HEADER_FIELD:\n                if (o === N) {\n                    s(\"onHeaderField\"), i = t.HEADERS_ALMOST_DONE;\n                    break;\n                }\n                if (e++, o === P) break;\n                if (o === C) {\n                    if (e === 1) return;\n                    b(\"onHeaderField\", !0), i = t.HEADER_VALUE_START;\n                    break;\n                }\n                if (L = $(o), L < I || L > M) return;\n                break;\n            case t.HEADER_VALUE_START:\n                if (o === x) break;\n                f(\"onHeaderValue\"), i = t.HEADER_VALUE;\n            case t.HEADER_VALUE:\n                o === N && (b(\"onHeaderValue\", !0), T(\"onHeaderEnd\"), i = t.HEADER_VALUE_ALMOST_DONE);\n                break;\n            case t.HEADER_VALUE_ALMOST_DONE:\n                if (o !== g) return;\n                i = t.HEADER_FIELD_START;\n                break;\n            case t.HEADERS_ALMOST_DONE:\n                if (o !== g) return;\n                T(\"onHeadersEnd\"), i = t.PART_DATA_START;\n                break;\n            case t.PART_DATA_START:\n                i = t.PART_DATA, f(\"onPartData\");\n            case t.PART_DATA:\n                if (d = e, e === 0) {\n                    for(n += O; n < y && !(a[n] in p);)n += H;\n                    n -= O, o = a[n];\n                }\n                if (e < c.length) c[e] === o ? (e === 0 && b(\"onPartData\", !0), e++) : e = 0;\n                else if (e === c.length) e++, o === N ? A |= R.PART_BOUNDARY : o === P ? A |= R.LAST_BOUNDARY : e = 0;\n                else if (e - 1 === c.length) if (A & R.PART_BOUNDARY) {\n                    if (e = 0, o === g) {\n                        A &= ~R.PART_BOUNDARY, T(\"onPartEnd\"), T(\"onPartBegin\"), i = t.HEADER_FIELD_START;\n                        break;\n                    }\n                } else A & R.LAST_BOUNDARY && o === P ? (T(\"onPartEnd\"), i = t.END, A = 0) : e = 0;\n                if (e > 0) l[e - 1] = o;\n                else if (d > 0) {\n                    const h = new Uint8Array(l.buffer, l.byteOffset, l.byteLength);\n                    T(\"onPartData\", 0, d, h), d = 0, f(\"onPartData\"), n--;\n                }\n                break;\n            case t.END:\n                break;\n            default:\n                throw new Error(`Unexpected state entered: ${i}`);\n        }\n        b(\"onHeaderField\"), b(\"onHeaderValue\"), b(\"onPartData\"), this.index = e, this.state = i, this.flags = A;\n    }\n    end() {\n        if (this.state === t.HEADER_FIELD_START && this.index === 0 || this.state === t.PART_DATA && this.index === this.boundary.length) this.onPartEnd();\n        else if (this.state !== t.END) throw new Error(\"MultipartParser.end(): stream ended unexpectedly\");\n    }\n};\nE(F, \"MultipartParser\");\nlet k = F;\nfunction v(u) {\n    const a = u.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n    if (!a) return;\n    const n = a[2] || a[3] || \"\";\n    let r = n.slice(n.lastIndexOf(\"\\\\\") + 1);\n    return r = r.replace(/%22/g, '\"'), r = r.replace(/&#(\\d{4});/g, (d, l)=>String.fromCharCode(l)), r;\n}\nE(v, \"_fileName\");\nasync function Z(u, a) {\n    if (!/multipart/i.test(a)) throw new TypeError(\"Failed to fetch\");\n    const n = a.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n    if (!n) throw new TypeError(\"no or bad content-type header, no multipart boundary\");\n    const r = new k(n[1] || n[2]);\n    let d, l, c, p, e, i;\n    const A = [], H = new _node_mjs__WEBPACK_IMPORTED_MODULE_2__.FormData, O = E((s)=>{\n        c += f.decode(s, {\n            stream: !0\n        });\n    }, \"onPartData\"), y = E((s)=>{\n        A.push(s);\n    }, \"appendToFile\"), o = E(()=>{\n        const s = new _node_mjs__WEBPACK_IMPORTED_MODULE_2__.File(A, i, {\n            type: e\n        });\n        H.append(p, s);\n    }, \"appendFileToFormData\"), L = E(()=>{\n        H.append(p, c);\n    }, \"appendEntryToFormData\"), f = new TextDecoder(\"utf-8\");\n    f.decode(), r.onPartBegin = function() {\n        r.onPartData = O, r.onPartEnd = L, d = \"\", l = \"\", c = \"\", p = \"\", e = \"\", i = null, A.length = 0;\n    }, r.onHeaderField = function(s) {\n        d += f.decode(s, {\n            stream: !0\n        });\n    }, r.onHeaderValue = function(s) {\n        l += f.decode(s, {\n            stream: !0\n        });\n    }, r.onHeaderEnd = function() {\n        if (l += f.decode(), d = d.toLowerCase(), d === \"content-disposition\") {\n            const s = l.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n            s && (p = s[2] || s[3] || \"\"), i = v(l), i && (r.onPartData = y, r.onPartEnd = o);\n        } else d === \"content-type\" && (e = l);\n        l = \"\", d = \"\";\n    };\n    for await (const s of u)r.write(s);\n    return r.end(), H;\n}\nE(Z, \"toFormData\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9jaHVua3MvbXVsdGlwYXJ0LXBhcnNlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLElBQUVDLE9BQU9DLGNBQWM7QUFBQyxJQUFJQyxJQUFFLENBQUNDLEdBQUVDLElBQUlMLEVBQUVJLEdBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQztBQUFtQjtBQUFrQjtBQUFpRDtBQUFrQjtBQUFtQjtBQUFrQjtBQUFvQjtBQUFvQjtBQUFrQjtBQUFpRDtBQUFpQjtBQUFpQjtBQUFBLElBQUlLLElBQUU7QUFBRSxNQUFNQyxJQUFFO0lBQUNDLGdCQUFlRjtJQUFJRyxvQkFBbUJIO0lBQUlJLGNBQWFKO0lBQUlLLG9CQUFtQkw7SUFBSU0sY0FBYU47SUFBSU8sMEJBQXlCUDtJQUFJUSxxQkFBb0JSO0lBQUlTLGlCQUFnQlQ7SUFBSVUsV0FBVVY7SUFBSVcsS0FBSVg7QUFBRztBQUFFLElBQUlZLElBQUU7QUFBRSxNQUFNQyxJQUFFO0lBQUNDLGVBQWNGO0lBQUVHLGVBQWNILEtBQUc7QUFBQyxHQUFFSSxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLEtBQUlDLElBQUVoQyxFQUFFQyxDQUFBQSxJQUFHQSxJQUFFLElBQUcsVUFBU2dDLElBQUVqQyxFQUFFLEtBQUssR0FBRSxTQUFRa0MsSUFBRSxNQUFNQTtJQUFFQyxZQUFZakMsQ0FBQyxDQUFDO1FBQUMsSUFBSSxDQUFDa0MsS0FBSyxHQUFDLEdBQUUsSUFBSSxDQUFDQyxLQUFLLEdBQUMsR0FBRSxJQUFJLENBQUNDLFdBQVcsR0FBQ0wsR0FBRSxJQUFJLENBQUNNLGFBQWEsR0FBQ04sR0FBRSxJQUFJLENBQUNPLFlBQVksR0FBQ1AsR0FBRSxJQUFJLENBQUNRLGFBQWEsR0FBQ1IsR0FBRSxJQUFJLENBQUNTLFdBQVcsR0FBQ1QsR0FBRSxJQUFJLENBQUNVLFVBQVUsR0FBQ1YsR0FBRSxJQUFJLENBQUNXLFNBQVMsR0FBQ1gsR0FBRSxJQUFJLENBQUNZLGFBQWEsR0FBQyxDQUFDLEdBQUUzQyxJQUFFLENBQUM7RUFDNTRCLENBQUMsR0FBQ0E7UUFBRSxNQUFNNEMsSUFBRSxJQUFJQyxXQUFXN0MsRUFBRThDLE1BQU07UUFBRSxJQUFJLElBQUlDLElBQUUsR0FBRUEsSUFBRS9DLEVBQUU4QyxNQUFNLEVBQUNDLElBQUlILENBQUMsQ0FBQ0csRUFBRSxHQUFDL0MsRUFBRWdELFVBQVUsQ0FBQ0QsSUFBRyxJQUFJLENBQUNKLGFBQWEsQ0FBQ0MsQ0FBQyxDQUFDRyxFQUFFLENBQUMsR0FBQyxDQUFDO1FBQUUsSUFBSSxDQUFDRSxRQUFRLEdBQUNMLEdBQUUsSUFBSSxDQUFDTSxVQUFVLEdBQUMsSUFBSUwsV0FBVyxJQUFJLENBQUNJLFFBQVEsQ0FBQ0gsTUFBTSxHQUFDLElBQUcsSUFBSSxDQUFDSyxLQUFLLEdBQUMzQyxFQUFFQyxjQUFjO0lBQUE7SUFBQzJDLE1BQU1wRCxDQUFDLEVBQUM7UUFBQyxJQUFJNEMsSUFBRTtRQUFFLE1BQU1HLElBQUUvQyxFQUFFOEMsTUFBTTtRQUFDLElBQUlPLElBQUUsSUFBSSxDQUFDbkIsS0FBSyxFQUFDLEVBQUNnQixZQUFXSSxDQUFDLEVBQUNMLFVBQVNNLENBQUMsRUFBQ1osZUFBY2EsQ0FBQyxFQUFDdEIsT0FBTXVCLENBQUMsRUFBQ04sT0FBTU8sQ0FBQyxFQUFDdkIsT0FBTXdCLENBQUMsRUFBQyxHQUFDLElBQUk7UUFBQyxNQUFNQyxJQUFFLElBQUksQ0FBQ1gsUUFBUSxDQUFDSCxNQUFNLEVBQUNlLElBQUVELElBQUUsR0FBRUUsSUFBRTlELEVBQUU4QyxNQUFNO1FBQUMsSUFBSWlCLEdBQUVDO1FBQUUsTUFBTUMsSUFBRW5FLEVBQUVvRSxDQUFBQTtZQUFJLElBQUksQ0FBQ0EsSUFBRSxPQUFPLEdBQUN0QjtRQUFDLEdBQUUsU0FBUXVCLElBQUVyRSxFQUFFb0UsQ0FBQUE7WUFBSSxPQUFPLElBQUksQ0FBQ0EsSUFBRSxPQUFPO1FBQUEsR0FBRSxVQUFTRSxJQUFFdEUsRUFBRSxDQUFDb0UsR0FBRUcsR0FBRUMsR0FBRUM7WUFBTUYsQ0FBQUEsTUFBSSxLQUFLLEtBQUdBLE1BQUlDLENBQUFBLEtBQUksSUFBSSxDQUFDSixFQUFFLENBQUNLLEtBQUdBLEVBQUVDLFFBQVEsQ0FBQ0gsR0FBRUM7UUFBRyxHQUFFLGFBQVlHLElBQUUzRSxFQUFFLENBQUNvRSxHQUFFRztZQUFLLE1BQU1DLElBQUVKLElBQUU7WUFBT0ksS0FBSyxJQUFJLElBQUdELENBQUFBLElBQUdELENBQUFBLEVBQUVGLEdBQUUsSUFBSSxDQUFDSSxFQUFFLEVBQUMxQixHQUFFNUMsSUFBRyxPQUFPLElBQUksQ0FBQ3NFLEVBQUUsSUFBR0YsQ0FBQUEsRUFBRUYsR0FBRSxJQUFJLENBQUNJLEVBQUUsRUFBQ3RFLEVBQUU4QyxNQUFNLEVBQUM5QyxJQUFHLElBQUksQ0FBQ3NFLEVBQUUsR0FBQyxFQUFDO1FBQUUsR0FBRTtRQUFnQixJQUFJMUIsSUFBRSxHQUFFQSxJQUFFRyxHQUFFSCxJQUFJLE9BQU9tQixJQUFFL0QsQ0FBQyxDQUFDNEMsRUFBRSxFQUFDYztZQUFHLEtBQUtsRCxFQUFFQyxjQUFjO2dCQUFDLElBQUdnRCxNQUFJRixFQUFFVCxNQUFNLEdBQUMsR0FBRTtvQkFBQyxJQUFHaUIsTUFBSXJDLEdBQUVpQyxLQUFHdkMsRUFBRUUsYUFBYTt5QkFBTSxJQUFHeUMsTUFBSXZDLEdBQUU7b0JBQU9pQztvQkFBSTtnQkFBSyxPQUFNLElBQUdBLElBQUUsTUFBSUYsRUFBRVQsTUFBTSxHQUFDLEdBQUU7b0JBQUMsSUFBR2EsSUFBRXZDLEVBQUVFLGFBQWEsSUFBRXlDLE1BQUlyQyxHQUFFZ0MsSUFBRWxELEVBQUVVLEdBQUcsRUFBQ3lDLElBQUU7eUJBQU8sSUFBRyxDQUFFQSxDQUFBQSxJQUFFdkMsRUFBRUUsYUFBYSxLQUFHeUMsTUFBSXhDLEdBQUVrQyxJQUFFLEdBQUVXLEVBQUUsZ0JBQWVWLElBQUVsRCxFQUFFRSxrQkFBa0I7eUJBQU07b0JBQU87Z0JBQUs7Z0JBQUNxRCxNQUFJUixDQUFDLENBQUNFLElBQUUsRUFBRSxJQUFHQSxDQUFBQSxJQUFFLENBQUMsSUFBR00sTUFBSVIsQ0FBQyxDQUFDRSxJQUFFLEVBQUUsSUFBRUE7Z0JBQUk7WUFBTSxLQUFLakQsRUFBRUUsa0JBQWtCO2dCQUFDZ0QsSUFBRWxELEVBQUVHLFlBQVksRUFBQ3NELEVBQUUsa0JBQWlCUixJQUFFO1lBQUUsS0FBS2pELEVBQUVHLFlBQVk7Z0JBQUMsSUFBR29ELE1BQUl2QyxHQUFFO29CQUFDMkMsRUFBRSxrQkFBaUJULElBQUVsRCxFQUFFTyxtQkFBbUI7b0JBQUM7Z0JBQUs7Z0JBQUMsSUFBRzBDLEtBQUlNLE1BQUlyQyxHQUFFO2dCQUFNLElBQUdxQyxNQUFJcEMsR0FBRTtvQkFBQyxJQUFHOEIsTUFBSSxHQUFFO29CQUFPZ0IsRUFBRSxpQkFBZ0IsQ0FBQyxJQUFHZixJQUFFbEQsRUFBRUksa0JBQWtCO29CQUFDO2dCQUFLO2dCQUFDLElBQUdvRCxJQUFFbEMsRUFBRWlDLElBQUdDLElBQUVwQyxLQUFHb0MsSUFBRW5DLEdBQUU7Z0JBQU87WUFBTSxLQUFLckIsRUFBRUksa0JBQWtCO2dCQUFDLElBQUdtRCxNQUFJdEMsR0FBRTtnQkFBTXdDLEVBQUUsa0JBQWlCUCxJQUFFbEQsRUFBRUssWUFBWTtZQUFDLEtBQUtMLEVBQUVLLFlBQVk7Z0JBQUNrRCxNQUFJdkMsS0FBSWlELENBQUFBLEVBQUUsaUJBQWdCLENBQUMsSUFBR0wsRUFBRSxnQkFBZVYsSUFBRWxELEVBQUVNLHdCQUF3QjtnQkFBRTtZQUFNLEtBQUtOLEVBQUVNLHdCQUF3QjtnQkFBQyxJQUFHaUQsTUFBSXhDLEdBQUU7Z0JBQU9tQyxJQUFFbEQsRUFBRUUsa0JBQWtCO2dCQUFDO1lBQU0sS0FBS0YsRUFBRU8sbUJBQW1CO2dCQUFDLElBQUdnRCxNQUFJeEMsR0FBRTtnQkFBTzZDLEVBQUUsaUJBQWdCVixJQUFFbEQsRUFBRVEsZUFBZTtnQkFBQztZQUFNLEtBQUtSLEVBQUVRLGVBQWU7Z0JBQUMwQyxJQUFFbEQsRUFBRVMsU0FBUyxFQUFDZ0QsRUFBRTtZQUFjLEtBQUt6RCxFQUFFUyxTQUFTO2dCQUFDLElBQUdvQyxJQUFFSSxHQUFFQSxNQUFJLEdBQUU7b0JBQUMsSUFBSWIsS0FBR2lCLEdBQUVqQixJQUFFa0IsS0FBRyxDQUFFOUQsQ0FBQUEsQ0FBQyxDQUFDNEMsRUFBRSxJQUFHWSxDQUFBQSxHQUFJWixLQUFHZ0I7b0JBQUVoQixLQUFHaUIsR0FBRUUsSUFBRS9ELENBQUMsQ0FBQzRDLEVBQUU7Z0JBQUE7Z0JBQUMsSUFBR2EsSUFBRUYsRUFBRVQsTUFBTSxFQUFDUyxDQUFDLENBQUNFLEVBQUUsS0FBR00sSUFBR04sQ0FBQUEsTUFBSSxLQUFHZ0IsRUFBRSxjQUFhLENBQUMsSUFBR2hCLEdBQUUsSUFBR0EsSUFBRTtxQkFBTyxJQUFHQSxNQUFJRixFQUFFVCxNQUFNLEVBQUNXLEtBQUlNLE1BQUl2QyxJQUFFbUMsS0FBR3ZDLEVBQUVDLGFBQWEsR0FBQzBDLE1BQUlyQyxJQUFFaUMsS0FBR3ZDLEVBQUVFLGFBQWEsR0FBQ21DLElBQUU7cUJBQU8sSUFBR0EsSUFBRSxNQUFJRixFQUFFVCxNQUFNLEVBQUMsSUFBR2EsSUFBRXZDLEVBQUVDLGFBQWEsRUFBQztvQkFBQyxJQUFHb0MsSUFBRSxHQUFFTSxNQUFJeEMsR0FBRTt3QkFBQ29DLEtBQUcsQ0FBQ3ZDLEVBQUVDLGFBQWEsRUFBQytDLEVBQUUsY0FBYUEsRUFBRSxnQkFBZVYsSUFBRWxELEVBQUVFLGtCQUFrQjt3QkFBQztvQkFBSztnQkFBQyxPQUFNaUQsSUFBRXZDLEVBQUVFLGFBQWEsSUFBRXlDLE1BQUlyQyxJQUFHMEMsQ0FBQUEsRUFBRSxjQUFhVixJQUFFbEQsRUFBRVUsR0FBRyxFQUFDeUMsSUFBRSxLQUFHRixJQUFFO2dCQUFFLElBQUdBLElBQUUsR0FBRUgsQ0FBQyxDQUFDRyxJQUFFLEVBQUUsR0FBQ007cUJBQU8sSUFBR1YsSUFBRSxHQUFFO29CQUFDLE1BQU1hLElBQUUsSUFBSXJCLFdBQVdTLEVBQUVvQixNQUFNLEVBQUNwQixFQUFFcUIsVUFBVSxFQUFDckIsRUFBRXNCLFVBQVU7b0JBQUVSLEVBQUUsY0FBYSxHQUFFZixHQUFFYSxJQUFHYixJQUFFLEdBQUVZLEVBQUUsZUFBY3JCO2dCQUFHO2dCQUFDO1lBQU0sS0FBS3BDLEVBQUVVLEdBQUc7Z0JBQUM7WUFBTTtnQkFBUSxNQUFNLElBQUkyRCxNQUFNLENBQUMsMEJBQTBCLEVBQUVuQixFQUFFLENBQUM7UUFBQztRQUFDZSxFQUFFLGtCQUFpQkEsRUFBRSxrQkFBaUJBLEVBQUUsZUFBYyxJQUFJLENBQUN2QyxLQUFLLEdBQUN1QixHQUFFLElBQUksQ0FBQ04sS0FBSyxHQUFDTyxHQUFFLElBQUksQ0FBQ3ZCLEtBQUssR0FBQ3dCO0lBQUM7SUFBQ21CLE1BQUs7UUFBQyxJQUFHLElBQUksQ0FBQzNCLEtBQUssS0FBRzNDLEVBQUVFLGtCQUFrQixJQUFFLElBQUksQ0FBQ3dCLEtBQUssS0FBRyxLQUFHLElBQUksQ0FBQ2lCLEtBQUssS0FBRzNDLEVBQUVTLFNBQVMsSUFBRSxJQUFJLENBQUNpQixLQUFLLEtBQUcsSUFBSSxDQUFDZSxRQUFRLENBQUNILE1BQU0sRUFBQyxJQUFJLENBQUNKLFNBQVM7YUFBUSxJQUFHLElBQUksQ0FBQ1MsS0FBSyxLQUFHM0MsRUFBRVUsR0FBRyxFQUFDLE1BQU0sSUFBSTJELE1BQU07SUFBbUQ7QUFBQztBQUFFL0UsRUFBRWtDLEdBQUU7QUFBbUIsSUFBSStDLElBQUUvQztBQUFFLFNBQVNnRCxFQUFFakYsQ0FBQztJQUFFLE1BQU1DLElBQUVELEVBQUVrRixLQUFLLENBQUM7SUFBOEQsSUFBRyxDQUFDakYsR0FBRTtJQUFPLE1BQU00QyxJQUFFNUMsQ0FBQyxDQUFDLEVBQUUsSUFBRUEsQ0FBQyxDQUFDLEVBQUUsSUFBRTtJQUFHLElBQUkrQyxJQUFFSCxFQUFFc0MsS0FBSyxDQUFDdEMsRUFBRXVDLFdBQVcsQ0FBQyxRQUFNO0lBQUcsT0FBT3BDLElBQUVBLEVBQUVxQyxPQUFPLENBQUMsUUFBTyxNQUFLckMsSUFBRUEsRUFBRXFDLE9BQU8sQ0FBQyxlQUFjLENBQUMvQixHQUFFQyxJQUFJK0IsT0FBT0MsWUFBWSxDQUFDaEMsS0FBSVA7QUFBQztBQUFDakQsRUFBRWtGLEdBQUU7QUFBYSxlQUFlTyxFQUFFeEYsQ0FBQyxFQUFDQyxDQUFDO0lBQUUsSUFBRyxDQUFDLGFBQWF3RixJQUFJLENBQUN4RixJQUFHLE1BQU0sSUFBSXlGLFVBQVU7SUFBbUIsTUFBTTdDLElBQUU1QyxFQUFFaUYsS0FBSyxDQUFDO0lBQW1DLElBQUcsQ0FBQ3JDLEdBQUUsTUFBTSxJQUFJNkMsVUFBVTtJQUF3RCxNQUFNMUMsSUFBRSxJQUFJZ0MsRUFBRW5DLENBQUMsQ0FBQyxFQUFFLElBQUVBLENBQUMsQ0FBQyxFQUFFO0lBQUUsSUFBSVMsR0FBRUMsR0FBRUMsR0FBRUMsR0FBRUMsR0FBRUM7SUFBRSxNQUFNQyxJQUFFLEVBQUUsRUFBQ0MsSUFBRSxJQUFJeEQsK0NBQUNBLEVBQUN5RCxJQUFFL0QsRUFBRXFFLENBQUFBO1FBQUlaLEtBQUdVLEVBQUV5QixNQUFNLENBQUN2QixHQUFFO1lBQUN3QixRQUFPLENBQUM7UUFBQztJQUFFLEdBQUUsZUFBYzdCLElBQUVoRSxFQUFFcUUsQ0FBQUE7UUFBSVIsRUFBRWlDLElBQUksQ0FBQ3pCO0lBQUUsR0FBRSxpQkFBZ0JKLElBQUVqRSxFQUFFO1FBQUssTUFBTXFFLElBQUUsSUFBSTdELDJDQUFDQSxDQUFDcUQsR0FBRUQsR0FBRTtZQUFDbUMsTUFBS3BDO1FBQUM7UUFBR0csRUFBRWtDLE1BQU0sQ0FBQ3RDLEdBQUVXO0lBQUUsR0FBRSx5QkFBd0JILElBQUVsRSxFQUFFO1FBQUs4RCxFQUFFa0MsTUFBTSxDQUFDdEMsR0FBRUQ7SUFBRSxHQUFFLDBCQUF5QlUsSUFBRSxJQUFJOEIsWUFBWTtJQUFTOUIsRUFBRXlCLE1BQU0sSUFBRzNDLEVBQUVQLFdBQVcsR0FBQztRQUFXTyxFQUFFTixVQUFVLEdBQUNvQixHQUFFZCxFQUFFTCxTQUFTLEdBQUNzQixHQUFFWCxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxNQUFLQyxFQUFFYixNQUFNLEdBQUM7SUFBQyxHQUFFQyxFQUFFVixhQUFhLEdBQUMsU0FBUzhCLENBQUM7UUFBRWQsS0FBR1ksRUFBRXlCLE1BQU0sQ0FBQ3ZCLEdBQUU7WUFBQ3dCLFFBQU8sQ0FBQztRQUFDO0lBQUUsR0FBRTVDLEVBQUVSLGFBQWEsR0FBQyxTQUFTNEIsQ0FBQztRQUFFYixLQUFHVyxFQUFFeUIsTUFBTSxDQUFDdkIsR0FBRTtZQUFDd0IsUUFBTyxDQUFDO1FBQUM7SUFBRSxHQUFFNUMsRUFBRVgsV0FBVyxHQUFDO1FBQVcsSUFBR2tCLEtBQUdXLEVBQUV5QixNQUFNLElBQUdyQyxJQUFFQSxFQUFFMkMsV0FBVyxJQUFHM0MsTUFBSSx1QkFBc0I7WUFBQyxNQUFNYyxJQUFFYixFQUFFMkIsS0FBSyxDQUFDO1lBQXFEZCxLQUFJWCxDQUFBQSxJQUFFVyxDQUFDLENBQUMsRUFBRSxJQUFFQSxDQUFDLENBQUMsRUFBRSxJQUFFLEVBQUMsR0FBR1QsSUFBRXNCLEVBQUUxQixJQUFHSSxLQUFJWCxDQUFBQSxFQUFFTixVQUFVLEdBQUNxQixHQUFFZixFQUFFTCxTQUFTLEdBQUNxQixDQUFBQTtRQUFFLE9BQU1WLE1BQUksa0JBQWlCSSxDQUFBQSxJQUFFSCxDQUFBQTtRQUFHQSxJQUFFLElBQUdELElBQUU7SUFBRTtJQUFFLFdBQVUsTUFBTWMsS0FBS3BFLEVBQUVnRCxFQUFFSyxLQUFLLENBQUNlO0lBQUcsT0FBT3BCLEVBQUUrQixHQUFHLElBQUdsQjtBQUFDO0FBQUM5RCxFQUFFeUYsR0FBRTtBQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL0Bwcml2eS1pby93YWdtaS1kZW1vLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlL2Rpc3QvY2h1bmtzL211bHRpcGFydC1wYXJzZXIubWpzPzFkOTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEI9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBFPSh1LGEpPT5CKHUsXCJuYW1lXCIse3ZhbHVlOmEsY29uZmlndXJhYmxlOiEwfSk7aW1wb3J0XCJub2RlOmZzXCI7aW1wb3J0XCJub2RlOnBhdGhcIjtpbXBvcnR7Rm9ybURhdGEgYXMgVixGaWxlIGFzIFl9ZnJvbVwiLi4vbm9kZS5tanNcIjtpbXBvcnRcIm5vZGU6aHR0cFwiO2ltcG9ydFwibm9kZTpodHRwc1wiO2ltcG9ydFwibm9kZTp6bGliXCI7aW1wb3J0XCJub2RlOnN0cmVhbVwiO2ltcG9ydFwibm9kZTpidWZmZXJcIjtpbXBvcnRcIm5vZGU6dXRpbFwiO2ltcG9ydFwiLi4vc2hhcmVkL25vZGUtZmV0Y2gtbmF0aXZlLjFhNGEzNTZkLm1qc1wiO2ltcG9ydFwibm9kZTp1cmxcIjtpbXBvcnRcIm5vZGU6bmV0XCI7bGV0IEQ9MDtjb25zdCB0PXtTVEFSVF9CT1VOREFSWTpEKyssSEVBREVSX0ZJRUxEX1NUQVJUOkQrKyxIRUFERVJfRklFTEQ6RCsrLEhFQURFUl9WQUxVRV9TVEFSVDpEKyssSEVBREVSX1ZBTFVFOkQrKyxIRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6RCsrLEhFQURFUlNfQUxNT1NUX0RPTkU6RCsrLFBBUlRfREFUQV9TVEFSVDpEKyssUEFSVF9EQVRBOkQrKyxFTkQ6RCsrfTtsZXQgdz0xO2NvbnN0IFI9e1BBUlRfQk9VTkRBUlk6dyxMQVNUX0JPVU5EQVJZOncqPTJ9LGc9MTAsTj0xMyx4PTMyLFA9NDUsQz01OCxJPTk3LE09MTIyLCQ9RSh1PT51fDMyLFwibG93ZXJcIiksbT1FKCgpPT57fSxcIm5vb3BcIiksRj1jbGFzcyBGe2NvbnN0cnVjdG9yKGEpe3RoaXMuaW5kZXg9MCx0aGlzLmZsYWdzPTAsdGhpcy5vbkhlYWRlckVuZD1tLHRoaXMub25IZWFkZXJGaWVsZD1tLHRoaXMub25IZWFkZXJzRW5kPW0sdGhpcy5vbkhlYWRlclZhbHVlPW0sdGhpcy5vblBhcnRCZWdpbj1tLHRoaXMub25QYXJ0RGF0YT1tLHRoaXMub25QYXJ0RW5kPW0sdGhpcy5ib3VuZGFyeUNoYXJzPXt9LGE9YFxcclxuLS1gK2E7Y29uc3Qgbj1uZXcgVWludDhBcnJheShhLmxlbmd0aCk7Zm9yKGxldCByPTA7cjxhLmxlbmd0aDtyKyspbltyXT1hLmNoYXJDb2RlQXQociksdGhpcy5ib3VuZGFyeUNoYXJzW25bcl1dPSEwO3RoaXMuYm91bmRhcnk9bix0aGlzLmxvb2tiZWhpbmQ9bmV3IFVpbnQ4QXJyYXkodGhpcy5ib3VuZGFyeS5sZW5ndGgrOCksdGhpcy5zdGF0ZT10LlNUQVJUX0JPVU5EQVJZfXdyaXRlKGEpe2xldCBuPTA7Y29uc3Qgcj1hLmxlbmd0aDtsZXQgZD10aGlzLmluZGV4LHtsb29rYmVoaW5kOmwsYm91bmRhcnk6Yyxib3VuZGFyeUNoYXJzOnAsaW5kZXg6ZSxzdGF0ZTppLGZsYWdzOkF9PXRoaXM7Y29uc3QgSD10aGlzLmJvdW5kYXJ5Lmxlbmd0aCxPPUgtMSx5PWEubGVuZ3RoO2xldCBvLEw7Y29uc3QgZj1FKGg9Pnt0aGlzW2grXCJNYXJrXCJdPW59LFwibWFya1wiKSxzPUUoaD0+e2RlbGV0ZSB0aGlzW2grXCJNYXJrXCJdfSxcImNsZWFyXCIpLFQ9RSgoaCxTLF8sVSk9PnsoUz09PXZvaWQgMHx8UyE9PV8pJiZ0aGlzW2hdKFUmJlUuc3ViYXJyYXkoUyxfKSl9LFwiY2FsbGJhY2tcIiksYj1FKChoLFMpPT57Y29uc3QgXz1oK1wiTWFya1wiO18gaW4gdGhpcyYmKFM/KFQoaCx0aGlzW19dLG4sYSksZGVsZXRlIHRoaXNbX10pOihUKGgsdGhpc1tfXSxhLmxlbmd0aCxhKSx0aGlzW19dPTApKX0sXCJkYXRhQ2FsbGJhY2tcIik7Zm9yKG49MDtuPHI7bisrKXN3aXRjaChvPWFbbl0saSl7Y2FzZSB0LlNUQVJUX0JPVU5EQVJZOmlmKGU9PT1jLmxlbmd0aC0yKXtpZihvPT09UClBfD1SLkxBU1RfQk9VTkRBUlk7ZWxzZSBpZihvIT09TilyZXR1cm47ZSsrO2JyZWFrfWVsc2UgaWYoZS0xPT09Yy5sZW5ndGgtMil7aWYoQSZSLkxBU1RfQk9VTkRBUlkmJm89PT1QKWk9dC5FTkQsQT0wO2Vsc2UgaWYoIShBJlIuTEFTVF9CT1VOREFSWSkmJm89PT1nKWU9MCxUKFwib25QYXJ0QmVnaW5cIiksaT10LkhFQURFUl9GSUVMRF9TVEFSVDtlbHNlIHJldHVybjticmVha31vIT09Y1tlKzJdJiYoZT0tMiksbz09PWNbZSsyXSYmZSsrO2JyZWFrO2Nhc2UgdC5IRUFERVJfRklFTERfU1RBUlQ6aT10LkhFQURFUl9GSUVMRCxmKFwib25IZWFkZXJGaWVsZFwiKSxlPTA7Y2FzZSB0LkhFQURFUl9GSUVMRDppZihvPT09Til7cyhcIm9uSGVhZGVyRmllbGRcIiksaT10LkhFQURFUlNfQUxNT1NUX0RPTkU7YnJlYWt9aWYoZSsrLG89PT1QKWJyZWFrO2lmKG89PT1DKXtpZihlPT09MSlyZXR1cm47YihcIm9uSGVhZGVyRmllbGRcIiwhMCksaT10LkhFQURFUl9WQUxVRV9TVEFSVDticmVha31pZihMPSQobyksTDxJfHxMPk0pcmV0dXJuO2JyZWFrO2Nhc2UgdC5IRUFERVJfVkFMVUVfU1RBUlQ6aWYobz09PXgpYnJlYWs7ZihcIm9uSGVhZGVyVmFsdWVcIiksaT10LkhFQURFUl9WQUxVRTtjYXNlIHQuSEVBREVSX1ZBTFVFOm89PT1OJiYoYihcIm9uSGVhZGVyVmFsdWVcIiwhMCksVChcIm9uSGVhZGVyRW5kXCIpLGk9dC5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkUpO2JyZWFrO2Nhc2UgdC5IRUFERVJfVkFMVUVfQUxNT1NUX0RPTkU6aWYobyE9PWcpcmV0dXJuO2k9dC5IRUFERVJfRklFTERfU1RBUlQ7YnJlYWs7Y2FzZSB0LkhFQURFUlNfQUxNT1NUX0RPTkU6aWYobyE9PWcpcmV0dXJuO1QoXCJvbkhlYWRlcnNFbmRcIiksaT10LlBBUlRfREFUQV9TVEFSVDticmVhaztjYXNlIHQuUEFSVF9EQVRBX1NUQVJUOmk9dC5QQVJUX0RBVEEsZihcIm9uUGFydERhdGFcIik7Y2FzZSB0LlBBUlRfREFUQTppZihkPWUsZT09PTApe2ZvcihuKz1PO248eSYmIShhW25daW4gcCk7KW4rPUg7bi09TyxvPWFbbl19aWYoZTxjLmxlbmd0aCljW2VdPT09bz8oZT09PTAmJmIoXCJvblBhcnREYXRhXCIsITApLGUrKyk6ZT0wO2Vsc2UgaWYoZT09PWMubGVuZ3RoKWUrKyxvPT09Tj9BfD1SLlBBUlRfQk9VTkRBUlk6bz09PVA/QXw9Ui5MQVNUX0JPVU5EQVJZOmU9MDtlbHNlIGlmKGUtMT09PWMubGVuZ3RoKWlmKEEmUi5QQVJUX0JPVU5EQVJZKXtpZihlPTAsbz09PWcpe0EmPX5SLlBBUlRfQk9VTkRBUlksVChcIm9uUGFydEVuZFwiKSxUKFwib25QYXJ0QmVnaW5cIiksaT10LkhFQURFUl9GSUVMRF9TVEFSVDticmVha319ZWxzZSBBJlIuTEFTVF9CT1VOREFSWSYmbz09PVA/KFQoXCJvblBhcnRFbmRcIiksaT10LkVORCxBPTApOmU9MDtpZihlPjApbFtlLTFdPW87ZWxzZSBpZihkPjApe2NvbnN0IGg9bmV3IFVpbnQ4QXJyYXkobC5idWZmZXIsbC5ieXRlT2Zmc2V0LGwuYnl0ZUxlbmd0aCk7VChcIm9uUGFydERhdGFcIiwwLGQsaCksZD0wLGYoXCJvblBhcnREYXRhXCIpLG4tLX1icmVhaztjYXNlIHQuRU5EOmJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHN0YXRlIGVudGVyZWQ6ICR7aX1gKX1iKFwib25IZWFkZXJGaWVsZFwiKSxiKFwib25IZWFkZXJWYWx1ZVwiKSxiKFwib25QYXJ0RGF0YVwiKSx0aGlzLmluZGV4PWUsdGhpcy5zdGF0ZT1pLHRoaXMuZmxhZ3M9QX1lbmQoKXtpZih0aGlzLnN0YXRlPT09dC5IRUFERVJfRklFTERfU1RBUlQmJnRoaXMuaW5kZXg9PT0wfHx0aGlzLnN0YXRlPT09dC5QQVJUX0RBVEEmJnRoaXMuaW5kZXg9PT10aGlzLmJvdW5kYXJ5Lmxlbmd0aCl0aGlzLm9uUGFydEVuZCgpO2Vsc2UgaWYodGhpcy5zdGF0ZSE9PXQuRU5EKXRocm93IG5ldyBFcnJvcihcIk11bHRpcGFydFBhcnNlci5lbmQoKTogc3RyZWFtIGVuZGVkIHVuZXhwZWN0ZWRseVwiKX19O0UoRixcIk11bHRpcGFydFBhcnNlclwiKTtsZXQgaz1GO2Z1bmN0aW9uIHYodSl7Y29uc3QgYT11Lm1hdGNoKC9cXGJmaWxlbmFtZT0oXCIoLio/KVwifChbXigpPD5ALDs6XFxcXFwiL1tcXF0/PXt9XFxzXFx0XSspKSgkfDtcXHMpL2kpO2lmKCFhKXJldHVybjtjb25zdCBuPWFbMl18fGFbM118fFwiXCI7bGV0IHI9bi5zbGljZShuLmxhc3RJbmRleE9mKFwiXFxcXFwiKSsxKTtyZXR1cm4gcj1yLnJlcGxhY2UoLyUyMi9nLCdcIicpLHI9ci5yZXBsYWNlKC8mIyhcXGR7NH0pOy9nLChkLGwpPT5TdHJpbmcuZnJvbUNoYXJDb2RlKGwpKSxyfUUodixcIl9maWxlTmFtZVwiKTthc3luYyBmdW5jdGlvbiBaKHUsYSl7aWYoIS9tdWx0aXBhcnQvaS50ZXN0KGEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2hcIik7Y29uc3Qgbj1hLm1hdGNoKC9ib3VuZGFyeT0oPzpcIihbXlwiXSspXCJ8KFteO10rKSkvaSk7aWYoIW4pdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vIG9yIGJhZCBjb250ZW50LXR5cGUgaGVhZGVyLCBubyBtdWx0aXBhcnQgYm91bmRhcnlcIik7Y29uc3Qgcj1uZXcgayhuWzFdfHxuWzJdKTtsZXQgZCxsLGMscCxlLGk7Y29uc3QgQT1bXSxIPW5ldyBWLE89RShzPT57Yys9Zi5kZWNvZGUocyx7c3RyZWFtOiEwfSl9LFwib25QYXJ0RGF0YVwiKSx5PUUocz0+e0EucHVzaChzKX0sXCJhcHBlbmRUb0ZpbGVcIiksbz1FKCgpPT57Y29uc3Qgcz1uZXcgWShBLGkse3R5cGU6ZX0pO0guYXBwZW5kKHAscyl9LFwiYXBwZW5kRmlsZVRvRm9ybURhdGFcIiksTD1FKCgpPT57SC5hcHBlbmQocCxjKX0sXCJhcHBlbmRFbnRyeVRvRm9ybURhdGFcIiksZj1uZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtmLmRlY29kZSgpLHIub25QYXJ0QmVnaW49ZnVuY3Rpb24oKXtyLm9uUGFydERhdGE9TyxyLm9uUGFydEVuZD1MLGQ9XCJcIixsPVwiXCIsYz1cIlwiLHA9XCJcIixlPVwiXCIsaT1udWxsLEEubGVuZ3RoPTB9LHIub25IZWFkZXJGaWVsZD1mdW5jdGlvbihzKXtkKz1mLmRlY29kZShzLHtzdHJlYW06ITB9KX0sci5vbkhlYWRlclZhbHVlPWZ1bmN0aW9uKHMpe2wrPWYuZGVjb2RlKHMse3N0cmVhbTohMH0pfSxyLm9uSGVhZGVyRW5kPWZ1bmN0aW9uKCl7aWYobCs9Zi5kZWNvZGUoKSxkPWQudG9Mb3dlckNhc2UoKSxkPT09XCJjb250ZW50LWRpc3Bvc2l0aW9uXCIpe2NvbnN0IHM9bC5tYXRjaCgvXFxibmFtZT0oXCIoW15cIl0qKVwifChbXigpPD5ALDs6XFxcXFwiL1tcXF0/PXt9XFxzXFx0XSspKS9pKTtzJiYocD1zWzJdfHxzWzNdfHxcIlwiKSxpPXYobCksaSYmKHIub25QYXJ0RGF0YT15LHIub25QYXJ0RW5kPW8pfWVsc2UgZD09PVwiY29udGVudC10eXBlXCImJihlPWwpO2w9XCJcIixkPVwiXCJ9O2ZvciBhd2FpdChjb25zdCBzIG9mIHUpci53cml0ZShzKTtyZXR1cm4gci5lbmQoKSxIfUUoWixcInRvRm9ybURhdGFcIik7ZXhwb3J0e1ogYXMgdG9Gb3JtRGF0YX07XG4iXSwibmFtZXMiOlsiQiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiRSIsInUiLCJhIiwidmFsdWUiLCJjb25maWd1cmFibGUiLCJGb3JtRGF0YSIsIlYiLCJGaWxlIiwiWSIsIkQiLCJ0IiwiU1RBUlRfQk9VTkRBUlkiLCJIRUFERVJfRklFTERfU1RBUlQiLCJIRUFERVJfRklFTEQiLCJIRUFERVJfVkFMVUVfU1RBUlQiLCJIRUFERVJfVkFMVUUiLCJIRUFERVJfVkFMVUVfQUxNT1NUX0RPTkUiLCJIRUFERVJTX0FMTU9TVF9ET05FIiwiUEFSVF9EQVRBX1NUQVJUIiwiUEFSVF9EQVRBIiwiRU5EIiwidyIsIlIiLCJQQVJUX0JPVU5EQVJZIiwiTEFTVF9CT1VOREFSWSIsImciLCJOIiwieCIsIlAiLCJDIiwiSSIsIk0iLCIkIiwibSIsIkYiLCJjb25zdHJ1Y3RvciIsImluZGV4IiwiZmxhZ3MiLCJvbkhlYWRlckVuZCIsIm9uSGVhZGVyRmllbGQiLCJvbkhlYWRlcnNFbmQiLCJvbkhlYWRlclZhbHVlIiwib25QYXJ0QmVnaW4iLCJvblBhcnREYXRhIiwib25QYXJ0RW5kIiwiYm91bmRhcnlDaGFycyIsIm4iLCJVaW50OEFycmF5IiwibGVuZ3RoIiwiciIsImNoYXJDb2RlQXQiLCJib3VuZGFyeSIsImxvb2tiZWhpbmQiLCJzdGF0ZSIsIndyaXRlIiwiZCIsImwiLCJjIiwicCIsImUiLCJpIiwiQSIsIkgiLCJPIiwieSIsIm8iLCJMIiwiZiIsImgiLCJzIiwiVCIsIlMiLCJfIiwiVSIsInN1YmFycmF5IiwiYiIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiRXJyb3IiLCJlbmQiLCJrIiwidiIsIm1hdGNoIiwic2xpY2UiLCJsYXN0SW5kZXhPZiIsInJlcGxhY2UiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJaIiwidGVzdCIsIlR5cGVFcnJvciIsImRlY29kZSIsInN0cmVhbSIsInB1c2giLCJ0eXBlIiwiYXBwZW5kIiwiVGV4dERlY29kZXIiLCJ0b0xvd2VyQ2FzZSIsInRvRm9ybURhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch-native/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortController: () => (/* binding */ A),\n/* harmony export */   AbortError: () => (/* reexport safe */ _node_mjs__WEBPACK_IMPORTED_MODULE_0__.AbortError),\n/* harmony export */   Blob: () => (/* binding */ T),\n/* harmony export */   FetchError: () => (/* reexport safe */ _node_mjs__WEBPACK_IMPORTED_MODULE_0__.FetchError),\n/* harmony export */   File: () => (/* binding */ R),\n/* harmony export */   FormData: () => (/* binding */ u),\n/* harmony export */   Headers: () => (/* binding */ d),\n/* harmony export */   Request: () => (/* binding */ $),\n/* harmony export */   Response: () => (/* binding */ C),\n/* harmony export */   blobFrom: () => (/* reexport safe */ _node_mjs__WEBPACK_IMPORTED_MODULE_0__.blobFrom),\n/* harmony export */   blobFromSync: () => (/* reexport safe */ _node_mjs__WEBPACK_IMPORTED_MODULE_0__.blobFromSync),\n/* harmony export */   \"default\": () => (/* binding */ s),\n/* harmony export */   fetch: () => (/* binding */ s),\n/* harmony export */   fileFrom: () => (/* reexport safe */ _node_mjs__WEBPACK_IMPORTED_MODULE_0__.fileFrom),\n/* harmony export */   fileFromSync: () => (/* reexport safe */ _node_mjs__WEBPACK_IMPORTED_MODULE_0__.fileFromSync),\n/* harmony export */   isRedirect: () => (/* reexport safe */ _node_mjs__WEBPACK_IMPORTED_MODULE_0__.isRedirect)\n/* harmony export */ });\n/* harmony import */ var _node_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node.mjs */ \"(ssr)/./node_modules/node-fetch-native/dist/node.mjs\");\n/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:http */ \"node:http\");\n/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:https */ \"node:https\");\n/* harmony import */ var node_zlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:zlib */ \"node:zlib\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:buffer */ \"node:buffer\");\n/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:util */ \"node:util\");\n/* harmony import */ var _shared_node_fetch_native_1a4a356d_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shared/node-fetch-native.1a4a356d.mjs */ \"(ssr)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.1a4a356d.mjs\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_net__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! node:net */ \"node:net\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! node:path */ \"node:path\");\nvar a = Object.defineProperty;\nvar t = (e, r)=>a(e, \"name\", {\n        value: r,\n        configurable: !0\n    });\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar f = Object.defineProperty, g = t((e, r)=>f(e, \"name\", {\n        value: r,\n        configurable: !0\n    }), \"e\");\nconst o = !!globalThis.process?.env?.FORCE_NODE_FETCH;\nfunction l() {\n    return !o && globalThis.fetch ? globalThis.fetch : _node_mjs__WEBPACK_IMPORTED_MODULE_0__.fetch;\n}\nt(l, \"p\"), g(l, \"_getFetch\");\nconst s = l(), T = !o && globalThis.Blob || _node_mjs__WEBPACK_IMPORTED_MODULE_0__.Blob, R = !o && globalThis.File || _node_mjs__WEBPACK_IMPORTED_MODULE_0__.File, u = !o && globalThis.FormData || _node_mjs__WEBPACK_IMPORTED_MODULE_0__.FormData, d = !o && globalThis.Headers || _node_mjs__WEBPACK_IMPORTED_MODULE_0__.Headers, $ = !o && globalThis.Request || _node_mjs__WEBPACK_IMPORTED_MODULE_0__.Request, C = !o && globalThis.Response || _node_mjs__WEBPACK_IMPORTED_MODULE_0__.Response, A = !o && globalThis.AbortController || _node_mjs__WEBPACK_IMPORTED_MODULE_0__.AbortController;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLElBQUVDLE9BQU9DLGNBQWM7QUFBQyxJQUFJQyxJQUFFLENBQUNDLEdBQUVDLElBQUlMLEVBQUVJLEdBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQztBQUFxSTtBQUFxRztBQUFrQjtBQUFtQjtBQUFrQjtBQUFvQjtBQUFvQjtBQUFrQjtBQUFnRDtBQUFpQjtBQUFpQjtBQUFnQjtBQUFrQjtBQUFBLElBQUl3QixJQUFFOUIsT0FBT0MsY0FBYyxFQUFDOEIsSUFBRTdCLEVBQUUsQ0FBQ0MsR0FBRUMsSUFBSTBCLEVBQUUzQixHQUFFLFFBQU87UUFBQ0UsT0FBTUQ7UUFBRUUsY0FBYSxDQUFDO0lBQUMsSUFBRztBQUFLLE1BQU0wQixJQUFFLENBQUMsQ0FBQ0MsV0FBV0MsT0FBTyxFQUFFQyxLQUFLQztBQUFpQixTQUFTQztJQUFJLE9BQU0sQ0FBQ0wsS0FBR0MsV0FBV1osS0FBSyxHQUFDWSxXQUFXWixLQUFLLEdBQUNDLDRDQUFDQTtBQUFBO0FBQUNwQixFQUFFbUMsR0FBRSxNQUFLTixFQUFFTSxHQUFFO0FBQWEsTUFBTUMsSUFBRUQsS0FBSUUsSUFBRSxDQUFDUCxLQUFHQyxXQUFXMUIsSUFBSSxJQUFFQywyQ0FBQ0EsRUFBQ2dDLElBQUUsQ0FBQ1IsS0FBR0MsV0FBV3hCLElBQUksSUFBRUMsMkNBQUNBLEVBQUMrQixJQUFFLENBQUNULEtBQUdDLFdBQVd0QixRQUFRLElBQUVDLCtDQUFDQSxFQUFDOEIsSUFBRSxDQUFDVixLQUFHQyxXQUFXcEIsT0FBTyxJQUFFQyw4Q0FBQ0EsRUFBQzZCLElBQUUsQ0FBQ1gsS0FBR0MsV0FBV2xCLE9BQU8sSUFBRUMsOENBQUNBLEVBQUM0QixJQUFFLENBQUNaLEtBQUdDLFdBQVdoQixRQUFRLElBQUVDLCtDQUFDQSxFQUFDMkIsSUFBRSxDQUFDYixLQUFHQyxXQUFXZCxlQUFlLElBQUVDLHNEQUFDQTtBQUFnSSIsInNvdXJjZXMiOlsid2VicGFjazovL0Bwcml2eS1pby93YWdtaS1kZW1vLy4vbm9kZV9tb2R1bGVzL25vZGUtZmV0Y2gtbmF0aXZlL2Rpc3QvaW5kZXgubWpzPzA5OTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGE9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciB0PShlLHIpPT5hKGUsXCJuYW1lXCIse3ZhbHVlOnIsY29uZmlndXJhYmxlOiEwfSk7aW1wb3J0e0Jsb2IgYXMgaSxGaWxlIGFzIGIsRm9ybURhdGEgYXMgbSxIZWFkZXJzIGFzIHAsUmVxdWVzdCBhcyBuLFJlc3BvbnNlIGFzIGMsQWJvcnRDb250cm9sbGVyIGFzIGgsZmV0Y2ggYXMgRn1mcm9tXCIuL25vZGUubWpzXCI7ZXhwb3J0e0Fib3J0RXJyb3IsRmV0Y2hFcnJvcixibG9iRnJvbSxibG9iRnJvbVN5bmMsZmlsZUZyb20sZmlsZUZyb21TeW5jLGlzUmVkaXJlY3R9ZnJvbVwiLi9ub2RlLm1qc1wiO2ltcG9ydFwibm9kZTpodHRwXCI7aW1wb3J0XCJub2RlOmh0dHBzXCI7aW1wb3J0XCJub2RlOnpsaWJcIjtpbXBvcnRcIm5vZGU6c3RyZWFtXCI7aW1wb3J0XCJub2RlOmJ1ZmZlclwiO2ltcG9ydFwibm9kZTp1dGlsXCI7aW1wb3J0XCIuL3NoYXJlZC9ub2RlLWZldGNoLW5hdGl2ZS4xYTRhMzU2ZC5tanNcIjtpbXBvcnRcIm5vZGU6dXJsXCI7aW1wb3J0XCJub2RlOm5ldFwiO2ltcG9ydFwibm9kZTpmc1wiO2ltcG9ydFwibm9kZTpwYXRoXCI7dmFyIGY9T2JqZWN0LmRlZmluZVByb3BlcnR5LGc9dCgoZSxyKT0+ZihlLFwibmFtZVwiLHt2YWx1ZTpyLGNvbmZpZ3VyYWJsZTohMH0pLFwiZVwiKTtjb25zdCBvPSEhZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/LkZPUkNFX05PREVfRkVUQ0g7ZnVuY3Rpb24gbCgpe3JldHVybiFvJiZnbG9iYWxUaGlzLmZldGNoP2dsb2JhbFRoaXMuZmV0Y2g6Rn10KGwsXCJwXCIpLGcobCxcIl9nZXRGZXRjaFwiKTtjb25zdCBzPWwoKSxUPSFvJiZnbG9iYWxUaGlzLkJsb2J8fGksUj0hbyYmZ2xvYmFsVGhpcy5GaWxlfHxiLHU9IW8mJmdsb2JhbFRoaXMuRm9ybURhdGF8fG0sZD0hbyYmZ2xvYmFsVGhpcy5IZWFkZXJzfHxwLCQ9IW8mJmdsb2JhbFRoaXMuUmVxdWVzdHx8bixDPSFvJiZnbG9iYWxUaGlzLlJlc3BvbnNlfHxjLEE9IW8mJmdsb2JhbFRoaXMuQWJvcnRDb250cm9sbGVyfHxoO2V4cG9ydHtBIGFzIEFib3J0Q29udHJvbGxlcixUIGFzIEJsb2IsUiBhcyBGaWxlLHUgYXMgRm9ybURhdGEsZCBhcyBIZWFkZXJzLCQgYXMgUmVxdWVzdCxDIGFzIFJlc3BvbnNlLHMgYXMgZGVmYXVsdCxzIGFzIGZldGNofTtcbiJdLCJuYW1lcyI6WyJhIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ0IiwiZSIsInIiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIkJsb2IiLCJpIiwiRmlsZSIsImIiLCJGb3JtRGF0YSIsIm0iLCJIZWFkZXJzIiwicCIsIlJlcXVlc3QiLCJuIiwiUmVzcG9uc2UiLCJjIiwiQWJvcnRDb250cm9sbGVyIiwiaCIsImZldGNoIiwiRiIsIkFib3J0RXJyb3IiLCJGZXRjaEVycm9yIiwiYmxvYkZyb20iLCJibG9iRnJvbVN5bmMiLCJmaWxlRnJvbSIsImZpbGVGcm9tU3luYyIsImlzUmVkaXJlY3QiLCJmIiwiZyIsIm8iLCJnbG9iYWxUaGlzIiwicHJvY2VzcyIsImVudiIsIkZPUkNFX05PREVfRkVUQ0giLCJsIiwicyIsIlQiLCJSIiwidSIsImQiLCIkIiwiQyIsIkEiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch-native/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch-native/dist/node.mjs":
/*!******************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/node.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortController: () => (/* binding */ Mn),\n/* harmony export */   AbortError: () => (/* binding */ _r),\n/* harmony export */   Blob: () => (/* binding */ ut),\n/* harmony export */   FetchError: () => (/* binding */ G),\n/* harmony export */   File: () => (/* binding */ On),\n/* harmony export */   FormData: () => (/* binding */ br),\n/* harmony export */   Headers: () => (/* binding */ ye),\n/* harmony export */   Request: () => (/* binding */ dt),\n/* harmony export */   Response: () => (/* binding */ le),\n/* harmony export */   blobFrom: () => (/* binding */ hl),\n/* harmony export */   blobFromSync: () => (/* binding */ dl),\n/* harmony export */   \"default\": () => (/* binding */ Fi),\n/* harmony export */   fetch: () => (/* binding */ Fi),\n/* harmony export */   fileFrom: () => (/* binding */ pl),\n/* harmony export */   fileFromSync: () => (/* binding */ bl),\n/* harmony export */   isRedirect: () => (/* binding */ Ln)\n/* harmony export */ });\n/* harmony import */ var node_http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:http */ \"node:http\");\n/* harmony import */ var node_https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:https */ \"node:https\");\n/* harmony import */ var node_zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:zlib */ \"node:zlib\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var node_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:buffer */ \"node:buffer\");\n/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:util */ \"node:util\");\n/* harmony import */ var _shared_node_fetch_native_1a4a356d_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shared/node-fetch-native.1a4a356d.mjs */ \"(ssr)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.1a4a356d.mjs\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var node_net__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! node:net */ \"node:net\");\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node:path */ \"node:path\");\nvar As = Object.defineProperty;\nvar n = (i1, o)=>As(i1, \"name\", {\n        value: o,\n        configurable: !0\n    });\nvar fi = (i1, o, a)=>{\n    if (!o.has(i1)) throw TypeError(\"Cannot \" + a);\n};\nvar O = (i1, o, a)=>(fi(i1, o, \"read from private field\"), a ? a.call(i1) : o.get(i1)), be = (i1, o, a)=>{\n    if (o.has(i1)) throw TypeError(\"Cannot add the same private member more than once\");\n    o instanceof WeakSet ? o.add(i1) : o.set(i1, a);\n}, X = (i1, o, a, u)=>(fi(i1, o, \"write to private field\"), u ? u.call(i1, a) : o.set(i1, a), a);\nvar ve, kt, bt, Cr, Ve, Wt, qt, Ot, ee, zt, Ne, He, It;\n\n\n\n\n\n\n\n\n\n\n\nfunction js(i1) {\n    if (!/^data:/i.test(i1)) throw new TypeError('`uri` does not appear to be a Data URI (must begin with \"data:\")');\n    i1 = i1.replace(/\\r?\\n/g, \"\");\n    const o = i1.indexOf(\",\");\n    if (o === -1 || o <= 4) throw new TypeError(\"malformed data: URI\");\n    const a = i1.substring(5, o).split(\";\");\n    let u = \"\", l = !1;\n    const p = a[0] || \"text/plain\";\n    let h = p;\n    for(let E = 1; E < a.length; E++)a[E] === \"base64\" ? l = !0 : a[E] && (h += `;${a[E]}`, a[E].indexOf(\"charset=\") === 0 && (u = a[E].substring(8)));\n    !a[0] && !u.length && (h += \";charset=US-ASCII\", u = \"US-ASCII\");\n    const g = l ? \"base64\" : \"ascii\", A = unescape(i1.substring(o + 1)), w = Buffer.from(A, g);\n    return w.type = p, w.typeFull = h, w.charset = u, w;\n}\nn(js, \"dataUriToBuffer\");\nvar pr = {\n    exports: {}\n}; /**\n * @license\n * web-streams-polyfill v3.3.3\n * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.\n * This code is released under the MIT license.\n * SPDX-License-Identifier: MIT\n */ \nvar di;\nfunction Ls() {\n    return di || (di = 1, function(i1, o) {\n        (function(a, u) {\n            u(o);\n        })(_shared_node_fetch_native_1a4a356d_mjs__WEBPACK_IMPORTED_MODULE_6__.c, function(a) {\n            function u() {}\n            n(u, \"noop\");\n            function l(e) {\n                return typeof e == \"object\" && e !== null || typeof e == \"function\";\n            }\n            n(l, \"typeIsObject\");\n            const p = u;\n            function h(e, t) {\n                try {\n                    Object.defineProperty(e, \"name\", {\n                        value: t,\n                        configurable: !0\n                    });\n                } catch  {}\n            }\n            n(h, \"setFunctionName\");\n            const g = Promise, A = Promise.prototype.then, w = Promise.reject.bind(g);\n            function E(e) {\n                return new g(e);\n            }\n            n(E, \"newPromise\");\n            function T(e) {\n                return E((t)=>t(e));\n            }\n            n(T, \"promiseResolvedWith\");\n            function b(e) {\n                return w(e);\n            }\n            n(b, \"promiseRejectedWith\");\n            function q(e, t, r) {\n                return A.call(e, t, r);\n            }\n            n(q, \"PerformPromiseThen\");\n            function _(e, t, r) {\n                q(q(e, t, r), void 0, p);\n            }\n            n(_, \"uponPromise\");\n            function V(e, t) {\n                _(e, t);\n            }\n            n(V, \"uponFulfillment\");\n            function I(e, t) {\n                _(e, void 0, t);\n            }\n            n(I, \"uponRejection\");\n            function F(e, t, r) {\n                return q(e, t, r);\n            }\n            n(F, \"transformPromiseWith\");\n            function Q(e) {\n                q(e, void 0, p);\n            }\n            n(Q, \"setPromiseIsHandledToTrue\");\n            let ge = n((e)=>{\n                if (typeof queueMicrotask == \"function\") ge = queueMicrotask;\n                else {\n                    const t = T(void 0);\n                    ge = n((r)=>q(t, r), \"_queueMicrotask\");\n                }\n                return ge(e);\n            }, \"_queueMicrotask\");\n            function z(e, t, r) {\n                if (typeof e != \"function\") throw new TypeError(\"Argument is not a function\");\n                return Function.prototype.apply.call(e, t, r);\n            }\n            n(z, \"reflectCall\");\n            function j(e, t, r) {\n                try {\n                    return T(z(e, t, r));\n                } catch (s) {\n                    return b(s);\n                }\n            }\n            n(j, \"promiseCall\");\n            const U = 16384, bn = class bn {\n                constructor(){\n                    this._cursor = 0, this._size = 0, this._front = {\n                        _elements: [],\n                        _next: void 0\n                    }, this._back = this._front, this._cursor = 0, this._size = 0;\n                }\n                get length() {\n                    return this._size;\n                }\n                push(t) {\n                    const r = this._back;\n                    let s = r;\n                    r._elements.length === U - 1 && (s = {\n                        _elements: [],\n                        _next: void 0\n                    }), r._elements.push(t), s !== r && (this._back = s, r._next = s), ++this._size;\n                }\n                shift() {\n                    const t = this._front;\n                    let r = t;\n                    const s = this._cursor;\n                    let f = s + 1;\n                    const c = t._elements, d = c[s];\n                    return f === U && (r = t._next, f = 0), --this._size, this._cursor = f, t !== r && (this._front = r), c[s] = void 0, d;\n                }\n                forEach(t) {\n                    let r = this._cursor, s = this._front, f = s._elements;\n                    for(; (r !== f.length || s._next !== void 0) && !(r === f.length && (s = s._next, f = s._elements, r = 0, f.length === 0));)t(f[r]), ++r;\n                }\n                peek() {\n                    const t = this._front, r = this._cursor;\n                    return t._elements[r];\n                }\n            };\n            n(bn, \"SimpleQueue\");\n            let D = bn;\n            const Ft = Symbol(\"[[AbortSteps]]\"), Qn = Symbol(\"[[ErrorSteps]]\"), Ar = Symbol(\"[[CancelSteps]]\"), Br = Symbol(\"[[PullSteps]]\"), kr = Symbol(\"[[ReleaseSteps]]\");\n            function Yn(e, t) {\n                e._ownerReadableStream = t, t._reader = e, t._state === \"readable\" ? qr(e) : t._state === \"closed\" ? Li(e) : Gn(e, t._storedError);\n            }\n            n(Yn, \"ReadableStreamReaderGenericInitialize\");\n            function Wr(e, t) {\n                const r = e._ownerReadableStream;\n                return ie(r, t);\n            }\n            n(Wr, \"ReadableStreamReaderGenericCancel\");\n            function _e(e) {\n                const t = e._ownerReadableStream;\n                t._state === \"readable\" ? Or(e, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")) : $i(e, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")), t._readableStreamController[kr](), t._reader = void 0, e._ownerReadableStream = void 0;\n            }\n            n(_e, \"ReadableStreamReaderGenericRelease\");\n            function jt(e) {\n                return new TypeError(\"Cannot \" + e + \" a stream using a released reader\");\n            }\n            n(jt, \"readerLockException\");\n            function qr(e) {\n                e._closedPromise = E((t, r)=>{\n                    e._closedPromise_resolve = t, e._closedPromise_reject = r;\n                });\n            }\n            n(qr, \"defaultReaderClosedPromiseInitialize\");\n            function Gn(e, t) {\n                qr(e), Or(e, t);\n            }\n            n(Gn, \"defaultReaderClosedPromiseInitializeAsRejected\");\n            function Li(e) {\n                qr(e), Zn(e);\n            }\n            n(Li, \"defaultReaderClosedPromiseInitializeAsResolved\");\n            function Or(e, t) {\n                e._closedPromise_reject !== void 0 && (Q(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0);\n            }\n            n(Or, \"defaultReaderClosedPromiseReject\");\n            function $i(e, t) {\n                Gn(e, t);\n            }\n            n($i, \"defaultReaderClosedPromiseResetToRejected\");\n            function Zn(e) {\n                e._closedPromise_resolve !== void 0 && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0);\n            }\n            n(Zn, \"defaultReaderClosedPromiseResolve\");\n            const Kn = Number.isFinite || function(e) {\n                return typeof e == \"number\" && isFinite(e);\n            }, Di = Math.trunc || function(e) {\n                return e < 0 ? Math.ceil(e) : Math.floor(e);\n            };\n            function Mi(e) {\n                return typeof e == \"object\" || typeof e == \"function\";\n            }\n            n(Mi, \"isDictionary\");\n            function ue(e, t) {\n                if (e !== void 0 && !Mi(e)) throw new TypeError(`${t} is not an object.`);\n            }\n            n(ue, \"assertDictionary\");\n            function Z(e, t) {\n                if (typeof e != \"function\") throw new TypeError(`${t} is not a function.`);\n            }\n            n(Z, \"assertFunction\");\n            function Ui(e) {\n                return typeof e == \"object\" && e !== null || typeof e == \"function\";\n            }\n            n(Ui, \"isObject\");\n            function Jn(e, t) {\n                if (!Ui(e)) throw new TypeError(`${t} is not an object.`);\n            }\n            n(Jn, \"assertObject\");\n            function Se(e, t, r) {\n                if (e === void 0) throw new TypeError(`Parameter ${t} is required in '${r}'.`);\n            }\n            n(Se, \"assertRequiredArgument\");\n            function zr(e, t, r) {\n                if (e === void 0) throw new TypeError(`${t} is required in '${r}'.`);\n            }\n            n(zr, \"assertRequiredField\");\n            function Ir(e) {\n                return Number(e);\n            }\n            n(Ir, \"convertUnrestrictedDouble\");\n            function Xn(e) {\n                return e === 0 ? 0 : e;\n            }\n            n(Xn, \"censorNegativeZero\");\n            function xi(e) {\n                return Xn(Di(e));\n            }\n            n(xi, \"integerPart\");\n            function Fr(e, t) {\n                const s = Number.MAX_SAFE_INTEGER;\n                let f = Number(e);\n                if (f = Xn(f), !Kn(f)) throw new TypeError(`${t} is not a finite number`);\n                if (f = xi(f), f < 0 || f > s) throw new TypeError(`${t} is outside the accepted range of 0 to ${s}, inclusive`);\n                return !Kn(f) || f === 0 ? 0 : f;\n            }\n            n(Fr, \"convertUnsignedLongLongWithEnforceRange\");\n            function jr(e, t) {\n                if (!We(e)) throw new TypeError(`${t} is not a ReadableStream.`);\n            }\n            n(jr, \"assertReadableStream\");\n            function Qe(e) {\n                return new fe(e);\n            }\n            n(Qe, \"AcquireReadableStreamDefaultReader\");\n            function eo(e, t) {\n                e._reader._readRequests.push(t);\n            }\n            n(eo, \"ReadableStreamAddReadRequest\");\n            function Lr(e, t, r) {\n                const f = e._reader._readRequests.shift();\n                r ? f._closeSteps() : f._chunkSteps(t);\n            }\n            n(Lr, \"ReadableStreamFulfillReadRequest\");\n            function Lt(e) {\n                return e._reader._readRequests.length;\n            }\n            n(Lt, \"ReadableStreamGetNumReadRequests\");\n            function to(e) {\n                const t = e._reader;\n                return !(t === void 0 || !Ee(t));\n            }\n            n(to, \"ReadableStreamHasDefaultReader\");\n            const mn = class mn {\n                constructor(t){\n                    if (Se(t, 1, \"ReadableStreamDefaultReader\"), jr(t, \"First parameter\"), qe(t)) throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    Yn(this, t), this._readRequests = new D;\n                }\n                get closed() {\n                    return Ee(this) ? this._closedPromise : b($t(\"closed\"));\n                }\n                cancel(t = void 0) {\n                    return Ee(this) ? this._ownerReadableStream === void 0 ? b(jt(\"cancel\")) : Wr(this, t) : b($t(\"cancel\"));\n                }\n                read() {\n                    if (!Ee(this)) return b($t(\"read\"));\n                    if (this._ownerReadableStream === void 0) return b(jt(\"read from\"));\n                    let t, r;\n                    const s = E((c, d)=>{\n                        t = c, r = d;\n                    });\n                    return mt(this, {\n                        _chunkSteps: (c)=>t({\n                                value: c,\n                                done: !1\n                            }),\n                        _closeSteps: ()=>t({\n                                value: void 0,\n                                done: !0\n                            }),\n                        _errorSteps: (c)=>r(c)\n                    }), s;\n                }\n                releaseLock() {\n                    if (!Ee(this)) throw $t(\"releaseLock\");\n                    this._ownerReadableStream !== void 0 && Ni(this);\n                }\n            };\n            n(mn, \"ReadableStreamDefaultReader\");\n            let fe = mn;\n            Object.defineProperties(fe.prototype, {\n                cancel: {\n                    enumerable: !0\n                },\n                read: {\n                    enumerable: !0\n                },\n                releaseLock: {\n                    enumerable: !0\n                },\n                closed: {\n                    enumerable: !0\n                }\n            }), h(fe.prototype.cancel, \"cancel\"), h(fe.prototype.read, \"read\"), h(fe.prototype.releaseLock, \"releaseLock\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(fe.prototype, Symbol.toStringTag, {\n                value: \"ReadableStreamDefaultReader\",\n                configurable: !0\n            });\n            function Ee(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_readRequests\") ? !1 : e instanceof fe;\n            }\n            n(Ee, \"IsReadableStreamDefaultReader\");\n            function mt(e, t) {\n                const r = e._ownerReadableStream;\n                r._disturbed = !0, r._state === \"closed\" ? t._closeSteps() : r._state === \"errored\" ? t._errorSteps(r._storedError) : r._readableStreamController[Br](t);\n            }\n            n(mt, \"ReadableStreamDefaultReaderRead\");\n            function Ni(e) {\n                _e(e);\n                const t = new TypeError(\"Reader was released\");\n                ro(e, t);\n            }\n            n(Ni, \"ReadableStreamDefaultReaderRelease\");\n            function ro(e, t) {\n                const r = e._readRequests;\n                e._readRequests = new D, r.forEach((s)=>{\n                    s._errorSteps(t);\n                });\n            }\n            n(ro, \"ReadableStreamDefaultReaderErrorReadRequests\");\n            function $t(e) {\n                return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`);\n            }\n            n($t, \"defaultReaderBrandCheckException\");\n            const Hi = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype), yn = class yn {\n                constructor(t, r){\n                    this._ongoingPromise = void 0, this._isFinished = !1, this._reader = t, this._preventCancel = r;\n                }\n                next() {\n                    const t = n(()=>this._nextSteps(), \"nextSteps\");\n                    return this._ongoingPromise = this._ongoingPromise ? F(this._ongoingPromise, t, t) : t(), this._ongoingPromise;\n                }\n                return(t) {\n                    const r = n(()=>this._returnSteps(t), \"returnSteps\");\n                    return this._ongoingPromise ? F(this._ongoingPromise, r, r) : r();\n                }\n                _nextSteps() {\n                    if (this._isFinished) return Promise.resolve({\n                        value: void 0,\n                        done: !0\n                    });\n                    const t = this._reader;\n                    let r, s;\n                    const f = E((d, m)=>{\n                        r = d, s = m;\n                    });\n                    return mt(t, {\n                        _chunkSteps: (d)=>{\n                            this._ongoingPromise = void 0, ge(()=>r({\n                                    value: d,\n                                    done: !1\n                                }));\n                        },\n                        _closeSteps: ()=>{\n                            this._ongoingPromise = void 0, this._isFinished = !0, _e(t), r({\n                                value: void 0,\n                                done: !0\n                            });\n                        },\n                        _errorSteps: (d)=>{\n                            this._ongoingPromise = void 0, this._isFinished = !0, _e(t), s(d);\n                        }\n                    }), f;\n                }\n                _returnSteps(t) {\n                    if (this._isFinished) return Promise.resolve({\n                        value: t,\n                        done: !0\n                    });\n                    this._isFinished = !0;\n                    const r = this._reader;\n                    if (!this._preventCancel) {\n                        const s = Wr(r, t);\n                        return _e(r), F(s, ()=>({\n                                value: t,\n                                done: !0\n                            }));\n                    }\n                    return _e(r), T({\n                        value: t,\n                        done: !0\n                    });\n                }\n            };\n            n(yn, \"ReadableStreamAsyncIteratorImpl\");\n            let Dt = yn;\n            const no = {\n                next () {\n                    return oo(this) ? this._asyncIteratorImpl.next() : b(io(\"next\"));\n                },\n                return (e) {\n                    return oo(this) ? this._asyncIteratorImpl.return(e) : b(io(\"return\"));\n                }\n            };\n            Object.setPrototypeOf(no, Hi);\n            function Vi(e, t) {\n                const r = Qe(e), s = new Dt(r, t), f = Object.create(no);\n                return f._asyncIteratorImpl = s, f;\n            }\n            n(Vi, \"AcquireReadableStreamAsyncIterator\");\n            function oo(e) {\n                if (!l(e) || !Object.prototype.hasOwnProperty.call(e, \"_asyncIteratorImpl\")) return !1;\n                try {\n                    return e._asyncIteratorImpl instanceof Dt;\n                } catch  {\n                    return !1;\n                }\n            }\n            n(oo, \"IsReadableStreamAsyncIterator\");\n            function io(e) {\n                return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`);\n            }\n            n(io, \"streamAsyncIteratorBrandCheckException\");\n            const ao = Number.isNaN || function(e) {\n                return e !== e;\n            };\n            var $r, Dr, Mr;\n            function yt(e) {\n                return e.slice();\n            }\n            n(yt, \"CreateArrayFromList\");\n            function so(e, t, r, s, f) {\n                new Uint8Array(e).set(new Uint8Array(r, s, f), t);\n            }\n            n(so, \"CopyDataBlockBytes\");\n            let we = n((e)=>(typeof e.transfer == \"function\" ? we = n((t)=>t.transfer(), \"TransferArrayBuffer\") : typeof structuredClone == \"function\" ? we = n((t)=>structuredClone(t, {\n                        transfer: [\n                            t\n                        ]\n                    }), \"TransferArrayBuffer\") : we = n((t)=>t, \"TransferArrayBuffer\"), we(e)), \"TransferArrayBuffer\"), Ae = n((e)=>(typeof e.detached == \"boolean\" ? Ae = n((t)=>t.detached, \"IsDetachedBuffer\") : Ae = n((t)=>t.byteLength === 0, \"IsDetachedBuffer\"), Ae(e)), \"IsDetachedBuffer\");\n            function lo(e, t, r) {\n                if (e.slice) return e.slice(t, r);\n                const s = r - t, f = new ArrayBuffer(s);\n                return so(f, 0, e, t, s), f;\n            }\n            n(lo, \"ArrayBufferSlice\");\n            function Mt(e, t) {\n                const r = e[t];\n                if (r != null) {\n                    if (typeof r != \"function\") throw new TypeError(`${String(t)} is not a function`);\n                    return r;\n                }\n            }\n            n(Mt, \"GetMethod\");\n            function Qi(e) {\n                const t = {\n                    [Symbol.iterator]: ()=>e.iterator\n                }, r = async function*() {\n                    return yield* t;\n                }(), s = r.next;\n                return {\n                    iterator: r,\n                    nextMethod: s,\n                    done: !1\n                };\n            }\n            n(Qi, \"CreateAsyncFromSyncIterator\");\n            const Ur = (Mr = ($r = Symbol.asyncIterator) !== null && $r !== void 0 ? $r : (Dr = Symbol.for) === null || Dr === void 0 ? void 0 : Dr.call(Symbol, \"Symbol.asyncIterator\")) !== null && Mr !== void 0 ? Mr : \"@@asyncIterator\";\n            function uo(e, t = \"sync\", r) {\n                if (r === void 0) if (t === \"async\") {\n                    if (r = Mt(e, Ur), r === void 0) {\n                        const c = Mt(e, Symbol.iterator), d = uo(e, \"sync\", c);\n                        return Qi(d);\n                    }\n                } else r = Mt(e, Symbol.iterator);\n                if (r === void 0) throw new TypeError(\"The object is not iterable\");\n                const s = z(r, e, []);\n                if (!l(s)) throw new TypeError(\"The iterator method must return an object\");\n                const f = s.next;\n                return {\n                    iterator: s,\n                    nextMethod: f,\n                    done: !1\n                };\n            }\n            n(uo, \"GetIterator\");\n            function Yi(e) {\n                const t = z(e.nextMethod, e.iterator, []);\n                if (!l(t)) throw new TypeError(\"The iterator.next() method must return an object\");\n                return t;\n            }\n            n(Yi, \"IteratorNext\");\n            function Gi(e) {\n                return !!e.done;\n            }\n            n(Gi, \"IteratorComplete\");\n            function Zi(e) {\n                return e.value;\n            }\n            n(Zi, \"IteratorValue\");\n            function Ki(e) {\n                return !(typeof e != \"number\" || ao(e) || e < 0);\n            }\n            n(Ki, \"IsNonNegativeNumber\");\n            function fo(e) {\n                const t = lo(e.buffer, e.byteOffset, e.byteOffset + e.byteLength);\n                return new Uint8Array(t);\n            }\n            n(fo, \"CloneAsUint8Array\");\n            function xr(e) {\n                const t = e._queue.shift();\n                return e._queueTotalSize -= t.size, e._queueTotalSize < 0 && (e._queueTotalSize = 0), t.value;\n            }\n            n(xr, \"DequeueValue\");\n            function Nr(e, t, r) {\n                if (!Ki(r) || r === 1 / 0) throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n                e._queue.push({\n                    value: t,\n                    size: r\n                }), e._queueTotalSize += r;\n            }\n            n(Nr, \"EnqueueValueWithSize\");\n            function Ji(e) {\n                return e._queue.peek().value;\n            }\n            n(Ji, \"PeekQueueValue\");\n            function Be(e) {\n                e._queue = new D, e._queueTotalSize = 0;\n            }\n            n(Be, \"ResetQueue\");\n            function co(e) {\n                return e === DataView;\n            }\n            n(co, \"isDataViewConstructor\");\n            function Xi(e) {\n                return co(e.constructor);\n            }\n            n(Xi, \"isDataView\");\n            function ea(e) {\n                return co(e) ? 1 : e.BYTES_PER_ELEMENT;\n            }\n            n(ea, \"arrayBufferViewElementSize\");\n            const gn = class gn {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get view() {\n                    if (!Hr(this)) throw Zr(\"view\");\n                    return this._view;\n                }\n                respond(t) {\n                    if (!Hr(this)) throw Zr(\"respond\");\n                    if (Se(t, 1, \"respond\"), t = Fr(t, \"First parameter\"), this._associatedReadableByteStreamController === void 0) throw new TypeError(\"This BYOB request has been invalidated\");\n                    if (Ae(this._view.buffer)) throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be used as a response\");\n                    Ht(this._associatedReadableByteStreamController, t);\n                }\n                respondWithNewView(t) {\n                    if (!Hr(this)) throw Zr(\"respondWithNewView\");\n                    if (Se(t, 1, \"respondWithNewView\"), !ArrayBuffer.isView(t)) throw new TypeError(\"You can only respond with array buffer views\");\n                    if (this._associatedReadableByteStreamController === void 0) throw new TypeError(\"This BYOB request has been invalidated\");\n                    if (Ae(t.buffer)) throw new TypeError(\"The given view's buffer has been detached and so cannot be used as a response\");\n                    Vt(this._associatedReadableByteStreamController, t);\n                }\n            };\n            n(gn, \"ReadableStreamBYOBRequest\");\n            let Re = gn;\n            Object.defineProperties(Re.prototype, {\n                respond: {\n                    enumerable: !0\n                },\n                respondWithNewView: {\n                    enumerable: !0\n                },\n                view: {\n                    enumerable: !0\n                }\n            }), h(Re.prototype.respond, \"respond\"), h(Re.prototype.respondWithNewView, \"respondWithNewView\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(Re.prototype, Symbol.toStringTag, {\n                value: \"ReadableStreamBYOBRequest\",\n                configurable: !0\n            });\n            const _n = class _n {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get byobRequest() {\n                    if (!ze(this)) throw _t(\"byobRequest\");\n                    return Gr(this);\n                }\n                get desiredSize() {\n                    if (!ze(this)) throw _t(\"desiredSize\");\n                    return Ro(this);\n                }\n                close() {\n                    if (!ze(this)) throw _t(\"close\");\n                    if (this._closeRequested) throw new TypeError(\"The stream has already been closed; do not close it again!\");\n                    const t = this._controlledReadableByteStream._state;\n                    if (t !== \"readable\") throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be closed`);\n                    gt(this);\n                }\n                enqueue(t) {\n                    if (!ze(this)) throw _t(\"enqueue\");\n                    if (Se(t, 1, \"enqueue\"), !ArrayBuffer.isView(t)) throw new TypeError(\"chunk must be an array buffer view\");\n                    if (t.byteLength === 0) throw new TypeError(\"chunk must have non-zero byteLength\");\n                    if (t.buffer.byteLength === 0) throw new TypeError(\"chunk's buffer must have non-zero byteLength\");\n                    if (this._closeRequested) throw new TypeError(\"stream is closed or draining\");\n                    const r = this._controlledReadableByteStream._state;\n                    if (r !== \"readable\") throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);\n                    Nt(this, t);\n                }\n                error(t = void 0) {\n                    if (!ze(this)) throw _t(\"error\");\n                    K(this, t);\n                }\n                [Ar](t) {\n                    ho(this), Be(this);\n                    const r = this._cancelAlgorithm(t);\n                    return xt(this), r;\n                }\n                [Br](t) {\n                    const r = this._controlledReadableByteStream;\n                    if (this._queueTotalSize > 0) {\n                        wo(this, t);\n                        return;\n                    }\n                    const s = this._autoAllocateChunkSize;\n                    if (s !== void 0) {\n                        let f;\n                        try {\n                            f = new ArrayBuffer(s);\n                        } catch (d) {\n                            t._errorSteps(d);\n                            return;\n                        }\n                        const c = {\n                            buffer: f,\n                            bufferByteLength: s,\n                            byteOffset: 0,\n                            byteLength: s,\n                            bytesFilled: 0,\n                            minimumFill: 1,\n                            elementSize: 1,\n                            viewConstructor: Uint8Array,\n                            readerType: \"default\"\n                        };\n                        this._pendingPullIntos.push(c);\n                    }\n                    eo(r, t), Ie(this);\n                }\n                [kr]() {\n                    if (this._pendingPullIntos.length > 0) {\n                        const t = this._pendingPullIntos.peek();\n                        t.readerType = \"none\", this._pendingPullIntos = new D, this._pendingPullIntos.push(t);\n                    }\n                }\n            };\n            n(_n, \"ReadableByteStreamController\");\n            let te = _n;\n            Object.defineProperties(te.prototype, {\n                close: {\n                    enumerable: !0\n                },\n                enqueue: {\n                    enumerable: !0\n                },\n                error: {\n                    enumerable: !0\n                },\n                byobRequest: {\n                    enumerable: !0\n                },\n                desiredSize: {\n                    enumerable: !0\n                }\n            }), h(te.prototype.close, \"close\"), h(te.prototype.enqueue, \"enqueue\"), h(te.prototype.error, \"error\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(te.prototype, Symbol.toStringTag, {\n                value: \"ReadableByteStreamController\",\n                configurable: !0\n            });\n            function ze(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_controlledReadableByteStream\") ? !1 : e instanceof te;\n            }\n            n(ze, \"IsReadableByteStreamController\");\n            function Hr(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_associatedReadableByteStreamController\") ? !1 : e instanceof Re;\n            }\n            n(Hr, \"IsReadableStreamBYOBRequest\");\n            function Ie(e) {\n                if (!ia(e)) return;\n                if (e._pulling) {\n                    e._pullAgain = !0;\n                    return;\n                }\n                e._pulling = !0;\n                const r = e._pullAlgorithm();\n                _(r, ()=>(e._pulling = !1, e._pullAgain && (e._pullAgain = !1, Ie(e)), null), (s)=>(K(e, s), null));\n            }\n            n(Ie, \"ReadableByteStreamControllerCallPullIfNeeded\");\n            function ho(e) {\n                Qr(e), e._pendingPullIntos = new D;\n            }\n            n(ho, \"ReadableByteStreamControllerClearPendingPullIntos\");\n            function Vr(e, t) {\n                let r = !1;\n                e._state === \"closed\" && (r = !0);\n                const s = po(t);\n                t.readerType === \"default\" ? Lr(e, s, r) : ca(e, s, r);\n            }\n            n(Vr, \"ReadableByteStreamControllerCommitPullIntoDescriptor\");\n            function po(e) {\n                const t = e.bytesFilled, r = e.elementSize;\n                return new e.viewConstructor(e.buffer, e.byteOffset, t / r);\n            }\n            n(po, \"ReadableByteStreamControllerConvertPullIntoDescriptor\");\n            function Ut(e, t, r, s) {\n                e._queue.push({\n                    buffer: t,\n                    byteOffset: r,\n                    byteLength: s\n                }), e._queueTotalSize += s;\n            }\n            n(Ut, \"ReadableByteStreamControllerEnqueueChunkToQueue\");\n            function bo(e, t, r, s) {\n                let f;\n                try {\n                    f = lo(t, r, r + s);\n                } catch (c) {\n                    throw K(e, c), c;\n                }\n                Ut(e, f, 0, s);\n            }\n            n(bo, \"ReadableByteStreamControllerEnqueueClonedChunkToQueue\");\n            function mo(e, t) {\n                t.bytesFilled > 0 && bo(e, t.buffer, t.byteOffset, t.bytesFilled), Ye(e);\n            }\n            n(mo, \"ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue\");\n            function yo(e, t) {\n                const r = Math.min(e._queueTotalSize, t.byteLength - t.bytesFilled), s = t.bytesFilled + r;\n                let f = r, c = !1;\n                const d = s % t.elementSize, m = s - d;\n                m >= t.minimumFill && (f = m - t.bytesFilled, c = !0);\n                const R = e._queue;\n                for(; f > 0;){\n                    const y = R.peek(), C = Math.min(f, y.byteLength), P = t.byteOffset + t.bytesFilled;\n                    so(t.buffer, P, y.buffer, y.byteOffset, C), y.byteLength === C ? R.shift() : (y.byteOffset += C, y.byteLength -= C), e._queueTotalSize -= C, go(e, C, t), f -= C;\n                }\n                return c;\n            }\n            n(yo, \"ReadableByteStreamControllerFillPullIntoDescriptorFromQueue\");\n            function go(e, t, r) {\n                r.bytesFilled += t;\n            }\n            n(go, \"ReadableByteStreamControllerFillHeadPullIntoDescriptor\");\n            function _o(e) {\n                e._queueTotalSize === 0 && e._closeRequested ? (xt(e), Pt(e._controlledReadableByteStream)) : Ie(e);\n            }\n            n(_o, \"ReadableByteStreamControllerHandleQueueDrain\");\n            function Qr(e) {\n                e._byobRequest !== null && (e._byobRequest._associatedReadableByteStreamController = void 0, e._byobRequest._view = null, e._byobRequest = null);\n            }\n            n(Qr, \"ReadableByteStreamControllerInvalidateBYOBRequest\");\n            function Yr(e) {\n                for(; e._pendingPullIntos.length > 0;){\n                    if (e._queueTotalSize === 0) return;\n                    const t = e._pendingPullIntos.peek();\n                    yo(e, t) && (Ye(e), Vr(e._controlledReadableByteStream, t));\n                }\n            }\n            n(Yr, \"ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue\");\n            function ta(e) {\n                const t = e._controlledReadableByteStream._reader;\n                for(; t._readRequests.length > 0;){\n                    if (e._queueTotalSize === 0) return;\n                    const r = t._readRequests.shift();\n                    wo(e, r);\n                }\n            }\n            n(ta, \"ReadableByteStreamControllerProcessReadRequestsUsingQueue\");\n            function ra(e, t, r, s) {\n                const f = e._controlledReadableByteStream, c = t.constructor, d = ea(c), { byteOffset: m, byteLength: R } = t, y = r * d;\n                let C;\n                try {\n                    C = we(t.buffer);\n                } catch (B) {\n                    s._errorSteps(B);\n                    return;\n                }\n                const P = {\n                    buffer: C,\n                    bufferByteLength: C.byteLength,\n                    byteOffset: m,\n                    byteLength: R,\n                    bytesFilled: 0,\n                    minimumFill: y,\n                    elementSize: d,\n                    viewConstructor: c,\n                    readerType: \"byob\"\n                };\n                if (e._pendingPullIntos.length > 0) {\n                    e._pendingPullIntos.push(P), Po(f, s);\n                    return;\n                }\n                if (f._state === \"closed\") {\n                    const B = new c(P.buffer, P.byteOffset, 0);\n                    s._closeSteps(B);\n                    return;\n                }\n                if (e._queueTotalSize > 0) {\n                    if (yo(e, P)) {\n                        const B = po(P);\n                        _o(e), s._chunkSteps(B);\n                        return;\n                    }\n                    if (e._closeRequested) {\n                        const B = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                        K(e, B), s._errorSteps(B);\n                        return;\n                    }\n                }\n                e._pendingPullIntos.push(P), Po(f, s), Ie(e);\n            }\n            n(ra, \"ReadableByteStreamControllerPullInto\");\n            function na(e, t) {\n                t.readerType === \"none\" && Ye(e);\n                const r = e._controlledReadableByteStream;\n                if (Kr(r)) for(; vo(r) > 0;){\n                    const s = Ye(e);\n                    Vr(r, s);\n                }\n            }\n            n(na, \"ReadableByteStreamControllerRespondInClosedState\");\n            function oa(e, t, r) {\n                if (go(e, t, r), r.readerType === \"none\") {\n                    mo(e, r), Yr(e);\n                    return;\n                }\n                if (r.bytesFilled < r.minimumFill) return;\n                Ye(e);\n                const s = r.bytesFilled % r.elementSize;\n                if (s > 0) {\n                    const f = r.byteOffset + r.bytesFilled;\n                    bo(e, r.buffer, f - s, s);\n                }\n                r.bytesFilled -= s, Vr(e._controlledReadableByteStream, r), Yr(e);\n            }\n            n(oa, \"ReadableByteStreamControllerRespondInReadableState\");\n            function So(e, t) {\n                const r = e._pendingPullIntos.peek();\n                Qr(e), e._controlledReadableByteStream._state === \"closed\" ? na(e, r) : oa(e, t, r), Ie(e);\n            }\n            n(So, \"ReadableByteStreamControllerRespondInternal\");\n            function Ye(e) {\n                return e._pendingPullIntos.shift();\n            }\n            n(Ye, \"ReadableByteStreamControllerShiftPendingPullInto\");\n            function ia(e) {\n                const t = e._controlledReadableByteStream;\n                return t._state !== \"readable\" || e._closeRequested || !e._started ? !1 : !!(to(t) && Lt(t) > 0 || Kr(t) && vo(t) > 0 || Ro(e) > 0);\n            }\n            n(ia, \"ReadableByteStreamControllerShouldCallPull\");\n            function xt(e) {\n                e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0;\n            }\n            n(xt, \"ReadableByteStreamControllerClearAlgorithms\");\n            function gt(e) {\n                const t = e._controlledReadableByteStream;\n                if (!(e._closeRequested || t._state !== \"readable\")) {\n                    if (e._queueTotalSize > 0) {\n                        e._closeRequested = !0;\n                        return;\n                    }\n                    if (e._pendingPullIntos.length > 0) {\n                        const r = e._pendingPullIntos.peek();\n                        if (r.bytesFilled % r.elementSize !== 0) {\n                            const s = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                            throw K(e, s), s;\n                        }\n                    }\n                    xt(e), Pt(t);\n                }\n            }\n            n(gt, \"ReadableByteStreamControllerClose\");\n            function Nt(e, t) {\n                const r = e._controlledReadableByteStream;\n                if (e._closeRequested || r._state !== \"readable\") return;\n                const { buffer: s, byteOffset: f, byteLength: c } = t;\n                if (Ae(s)) throw new TypeError(\"chunk's buffer is detached and so cannot be enqueued\");\n                const d = we(s);\n                if (e._pendingPullIntos.length > 0) {\n                    const m = e._pendingPullIntos.peek();\n                    if (Ae(m.buffer)) throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk\");\n                    Qr(e), m.buffer = we(m.buffer), m.readerType === \"none\" && mo(e, m);\n                }\n                if (to(r)) if (ta(e), Lt(r) === 0) Ut(e, d, f, c);\n                else {\n                    e._pendingPullIntos.length > 0 && Ye(e);\n                    const m = new Uint8Array(d, f, c);\n                    Lr(r, m, !1);\n                }\n                else Kr(r) ? (Ut(e, d, f, c), Yr(e)) : Ut(e, d, f, c);\n                Ie(e);\n            }\n            n(Nt, \"ReadableByteStreamControllerEnqueue\");\n            function K(e, t) {\n                const r = e._controlledReadableByteStream;\n                r._state === \"readable\" && (ho(e), Be(e), xt(e), Zo(r, t));\n            }\n            n(K, \"ReadableByteStreamControllerError\");\n            function wo(e, t) {\n                const r = e._queue.shift();\n                e._queueTotalSize -= r.byteLength, _o(e);\n                const s = new Uint8Array(r.buffer, r.byteOffset, r.byteLength);\n                t._chunkSteps(s);\n            }\n            n(wo, \"ReadableByteStreamControllerFillReadRequestFromQueue\");\n            function Gr(e) {\n                if (e._byobRequest === null && e._pendingPullIntos.length > 0) {\n                    const t = e._pendingPullIntos.peek(), r = new Uint8Array(t.buffer, t.byteOffset + t.bytesFilled, t.byteLength - t.bytesFilled), s = Object.create(Re.prototype);\n                    sa(s, e, r), e._byobRequest = s;\n                }\n                return e._byobRequest;\n            }\n            n(Gr, \"ReadableByteStreamControllerGetBYOBRequest\");\n            function Ro(e) {\n                const t = e._controlledReadableByteStream._state;\n                return t === \"errored\" ? null : t === \"closed\" ? 0 : e._strategyHWM - e._queueTotalSize;\n            }\n            n(Ro, \"ReadableByteStreamControllerGetDesiredSize\");\n            function Ht(e, t) {\n                const r = e._pendingPullIntos.peek();\n                if (e._controlledReadableByteStream._state === \"closed\") {\n                    if (t !== 0) throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n                } else {\n                    if (t === 0) throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n                    if (r.bytesFilled + t > r.byteLength) throw new RangeError(\"bytesWritten out of range\");\n                }\n                r.buffer = we(r.buffer), So(e, t);\n            }\n            n(Ht, \"ReadableByteStreamControllerRespond\");\n            function Vt(e, t) {\n                const r = e._pendingPullIntos.peek();\n                if (e._controlledReadableByteStream._state === \"closed\") {\n                    if (t.byteLength !== 0) throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n                } else if (t.byteLength === 0) throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n                if (r.byteOffset + r.bytesFilled !== t.byteOffset) throw new RangeError(\"The region specified by view does not match byobRequest\");\n                if (r.bufferByteLength !== t.buffer.byteLength) throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n                if (r.bytesFilled + t.byteLength > r.byteLength) throw new RangeError(\"The region specified by view is larger than byobRequest\");\n                const f = t.byteLength;\n                r.buffer = we(t.buffer), So(e, f);\n            }\n            n(Vt, \"ReadableByteStreamControllerRespondWithNewView\");\n            function To(e, t, r, s, f, c, d) {\n                t._controlledReadableByteStream = e, t._pullAgain = !1, t._pulling = !1, t._byobRequest = null, t._queue = t._queueTotalSize = void 0, Be(t), t._closeRequested = !1, t._started = !1, t._strategyHWM = c, t._pullAlgorithm = s, t._cancelAlgorithm = f, t._autoAllocateChunkSize = d, t._pendingPullIntos = new D, e._readableStreamController = t;\n                const m = r();\n                _(T(m), ()=>(t._started = !0, Ie(t), null), (R)=>(K(t, R), null));\n            }\n            n(To, \"SetUpReadableByteStreamController\");\n            function aa(e, t, r) {\n                const s = Object.create(te.prototype);\n                let f, c, d;\n                t.start !== void 0 ? f = n(()=>t.start(s), \"startAlgorithm\") : f = n(()=>{}, \"startAlgorithm\"), t.pull !== void 0 ? c = n(()=>t.pull(s), \"pullAlgorithm\") : c = n(()=>T(void 0), \"pullAlgorithm\"), t.cancel !== void 0 ? d = n((R)=>t.cancel(R), \"cancelAlgorithm\") : d = n(()=>T(void 0), \"cancelAlgorithm\");\n                const m = t.autoAllocateChunkSize;\n                if (m === 0) throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n                To(e, s, f, c, d, r, m);\n            }\n            n(aa, \"SetUpReadableByteStreamControllerFromUnderlyingSource\");\n            function sa(e, t, r) {\n                e._associatedReadableByteStreamController = t, e._view = r;\n            }\n            n(sa, \"SetUpReadableStreamBYOBRequest\");\n            function Zr(e) {\n                return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`);\n            }\n            n(Zr, \"byobRequestBrandCheckException\");\n            function _t(e) {\n                return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`);\n            }\n            n(_t, \"byteStreamControllerBrandCheckException\");\n            function la(e, t) {\n                ue(e, t);\n                const r = e?.mode;\n                return {\n                    mode: r === void 0 ? void 0 : ua(r, `${t} has member 'mode' that`)\n                };\n            }\n            n(la, \"convertReaderOptions\");\n            function ua(e, t) {\n                if (e = `${e}`, e !== \"byob\") throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);\n                return e;\n            }\n            n(ua, \"convertReadableStreamReaderMode\");\n            function fa(e, t) {\n                var r;\n                ue(e, t);\n                const s = (r = e?.min) !== null && r !== void 0 ? r : 1;\n                return {\n                    min: Fr(s, `${t} has member 'min' that`)\n                };\n            }\n            n(fa, \"convertByobReadOptions\");\n            function Co(e) {\n                return new ce(e);\n            }\n            n(Co, \"AcquireReadableStreamBYOBReader\");\n            function Po(e, t) {\n                e._reader._readIntoRequests.push(t);\n            }\n            n(Po, \"ReadableStreamAddReadIntoRequest\");\n            function ca(e, t, r) {\n                const f = e._reader._readIntoRequests.shift();\n                r ? f._closeSteps(t) : f._chunkSteps(t);\n            }\n            n(ca, \"ReadableStreamFulfillReadIntoRequest\");\n            function vo(e) {\n                return e._reader._readIntoRequests.length;\n            }\n            n(vo, \"ReadableStreamGetNumReadIntoRequests\");\n            function Kr(e) {\n                const t = e._reader;\n                return !(t === void 0 || !Fe(t));\n            }\n            n(Kr, \"ReadableStreamHasBYOBReader\");\n            const Sn = class Sn {\n                constructor(t){\n                    if (Se(t, 1, \"ReadableStreamBYOBReader\"), jr(t, \"First parameter\"), qe(t)) throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n                    if (!ze(t._readableStreamController)) throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");\n                    Yn(this, t), this._readIntoRequests = new D;\n                }\n                get closed() {\n                    return Fe(this) ? this._closedPromise : b(Qt(\"closed\"));\n                }\n                cancel(t = void 0) {\n                    return Fe(this) ? this._ownerReadableStream === void 0 ? b(jt(\"cancel\")) : Wr(this, t) : b(Qt(\"cancel\"));\n                }\n                read(t, r = {}) {\n                    if (!Fe(this)) return b(Qt(\"read\"));\n                    if (!ArrayBuffer.isView(t)) return b(new TypeError(\"view must be an array buffer view\"));\n                    if (t.byteLength === 0) return b(new TypeError(\"view must have non-zero byteLength\"));\n                    if (t.buffer.byteLength === 0) return b(new TypeError(\"view's buffer must have non-zero byteLength\"));\n                    if (Ae(t.buffer)) return b(new TypeError(\"view's buffer has been detached\"));\n                    let s;\n                    try {\n                        s = fa(r, \"options\");\n                    } catch (y) {\n                        return b(y);\n                    }\n                    const f = s.min;\n                    if (f === 0) return b(new TypeError(\"options.min must be greater than 0\"));\n                    if (Xi(t)) {\n                        if (f > t.byteLength) return b(new RangeError(\"options.min must be less than or equal to view's byteLength\"));\n                    } else if (f > t.length) return b(new RangeError(\"options.min must be less than or equal to view's length\"));\n                    if (this._ownerReadableStream === void 0) return b(jt(\"read from\"));\n                    let c, d;\n                    const m = E((y, C)=>{\n                        c = y, d = C;\n                    });\n                    return Eo(this, t, f, {\n                        _chunkSteps: (y)=>c({\n                                value: y,\n                                done: !1\n                            }),\n                        _closeSteps: (y)=>c({\n                                value: y,\n                                done: !0\n                            }),\n                        _errorSteps: (y)=>d(y)\n                    }), m;\n                }\n                releaseLock() {\n                    if (!Fe(this)) throw Qt(\"releaseLock\");\n                    this._ownerReadableStream !== void 0 && da(this);\n                }\n            };\n            n(Sn, \"ReadableStreamBYOBReader\");\n            let ce = Sn;\n            Object.defineProperties(ce.prototype, {\n                cancel: {\n                    enumerable: !0\n                },\n                read: {\n                    enumerable: !0\n                },\n                releaseLock: {\n                    enumerable: !0\n                },\n                closed: {\n                    enumerable: !0\n                }\n            }), h(ce.prototype.cancel, \"cancel\"), h(ce.prototype.read, \"read\"), h(ce.prototype.releaseLock, \"releaseLock\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(ce.prototype, Symbol.toStringTag, {\n                value: \"ReadableStreamBYOBReader\",\n                configurable: !0\n            });\n            function Fe(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_readIntoRequests\") ? !1 : e instanceof ce;\n            }\n            n(Fe, \"IsReadableStreamBYOBReader\");\n            function Eo(e, t, r, s) {\n                const f = e._ownerReadableStream;\n                f._disturbed = !0, f._state === \"errored\" ? s._errorSteps(f._storedError) : ra(f._readableStreamController, t, r, s);\n            }\n            n(Eo, \"ReadableStreamBYOBReaderRead\");\n            function da(e) {\n                _e(e);\n                const t = new TypeError(\"Reader was released\");\n                Ao(e, t);\n            }\n            n(da, \"ReadableStreamBYOBReaderRelease\");\n            function Ao(e, t) {\n                const r = e._readIntoRequests;\n                e._readIntoRequests = new D, r.forEach((s)=>{\n                    s._errorSteps(t);\n                });\n            }\n            n(Ao, \"ReadableStreamBYOBReaderErrorReadIntoRequests\");\n            function Qt(e) {\n                return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`);\n            }\n            n(Qt, \"byobReaderBrandCheckException\");\n            function St(e, t) {\n                const { highWaterMark: r } = e;\n                if (r === void 0) return t;\n                if (ao(r) || r < 0) throw new RangeError(\"Invalid highWaterMark\");\n                return r;\n            }\n            n(St, \"ExtractHighWaterMark\");\n            function Yt(e) {\n                const { size: t } = e;\n                return t || (()=>1);\n            }\n            n(Yt, \"ExtractSizeAlgorithm\");\n            function Gt(e, t) {\n                ue(e, t);\n                const r = e?.highWaterMark, s = e?.size;\n                return {\n                    highWaterMark: r === void 0 ? void 0 : Ir(r),\n                    size: s === void 0 ? void 0 : ha(s, `${t} has member 'size' that`)\n                };\n            }\n            n(Gt, \"convertQueuingStrategy\");\n            function ha(e, t) {\n                return Z(e, t), (r)=>Ir(e(r));\n            }\n            n(ha, \"convertQueuingStrategySize\");\n            function pa(e, t) {\n                ue(e, t);\n                const r = e?.abort, s = e?.close, f = e?.start, c = e?.type, d = e?.write;\n                return {\n                    abort: r === void 0 ? void 0 : ba(r, e, `${t} has member 'abort' that`),\n                    close: s === void 0 ? void 0 : ma(s, e, `${t} has member 'close' that`),\n                    start: f === void 0 ? void 0 : ya(f, e, `${t} has member 'start' that`),\n                    write: d === void 0 ? void 0 : ga(d, e, `${t} has member 'write' that`),\n                    type: c\n                };\n            }\n            n(pa, \"convertUnderlyingSink\");\n            function ba(e, t, r) {\n                return Z(e, r), (s)=>j(e, t, [\n                        s\n                    ]);\n            }\n            n(ba, \"convertUnderlyingSinkAbortCallback\");\n            function ma(e, t, r) {\n                return Z(e, r), ()=>j(e, t, []);\n            }\n            n(ma, \"convertUnderlyingSinkCloseCallback\");\n            function ya(e, t, r) {\n                return Z(e, r), (s)=>z(e, t, [\n                        s\n                    ]);\n            }\n            n(ya, \"convertUnderlyingSinkStartCallback\");\n            function ga(e, t, r) {\n                return Z(e, r), (s, f)=>j(e, t, [\n                        s,\n                        f\n                    ]);\n            }\n            n(ga, \"convertUnderlyingSinkWriteCallback\");\n            function Bo(e, t) {\n                if (!Ge(e)) throw new TypeError(`${t} is not a WritableStream.`);\n            }\n            n(Bo, \"assertWritableStream\");\n            function _a(e) {\n                if (typeof e != \"object\" || e === null) return !1;\n                try {\n                    return typeof e.aborted == \"boolean\";\n                } catch  {\n                    return !1;\n                }\n            }\n            n(_a, \"isAbortSignal\");\n            const Sa = typeof AbortController == \"function\";\n            function wa() {\n                if (Sa) return new AbortController;\n            }\n            n(wa, \"createAbortController\");\n            const wn = class wn {\n                constructor(t = {}, r = {}){\n                    t === void 0 ? t = null : Jn(t, \"First parameter\");\n                    const s = Gt(r, \"Second parameter\"), f = pa(t, \"First parameter\");\n                    if (Wo(this), f.type !== void 0) throw new RangeError(\"Invalid type is specified\");\n                    const d = Yt(s), m = St(s, 1);\n                    Ia(this, f, m, d);\n                }\n                get locked() {\n                    if (!Ge(this)) throw er(\"locked\");\n                    return Ze(this);\n                }\n                abort(t = void 0) {\n                    return Ge(this) ? Ze(this) ? b(new TypeError(\"Cannot abort a stream that already has a writer\")) : Zt(this, t) : b(er(\"abort\"));\n                }\n                close() {\n                    return Ge(this) ? Ze(this) ? b(new TypeError(\"Cannot close a stream that already has a writer\")) : he(this) ? b(new TypeError(\"Cannot close an already-closing stream\")) : qo(this) : b(er(\"close\"));\n                }\n                getWriter() {\n                    if (!Ge(this)) throw er(\"getWriter\");\n                    return ko(this);\n                }\n            };\n            n(wn, \"WritableStream\");\n            let de = wn;\n            Object.defineProperties(de.prototype, {\n                abort: {\n                    enumerable: !0\n                },\n                close: {\n                    enumerable: !0\n                },\n                getWriter: {\n                    enumerable: !0\n                },\n                locked: {\n                    enumerable: !0\n                }\n            }), h(de.prototype.abort, \"abort\"), h(de.prototype.close, \"close\"), h(de.prototype.getWriter, \"getWriter\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(de.prototype, Symbol.toStringTag, {\n                value: \"WritableStream\",\n                configurable: !0\n            });\n            function ko(e) {\n                return new re(e);\n            }\n            n(ko, \"AcquireWritableStreamDefaultWriter\");\n            function Ra(e, t, r, s, f = 1, c = ()=>1) {\n                const d = Object.create(de.prototype);\n                Wo(d);\n                const m = Object.create(ke.prototype);\n                return Lo(d, m, e, t, r, s, f, c), d;\n            }\n            n(Ra, \"CreateWritableStream\");\n            function Wo(e) {\n                e._state = \"writable\", e._storedError = void 0, e._writer = void 0, e._writableStreamController = void 0, e._writeRequests = new D, e._inFlightWriteRequest = void 0, e._closeRequest = void 0, e._inFlightCloseRequest = void 0, e._pendingAbortRequest = void 0, e._backpressure = !1;\n            }\n            n(Wo, \"InitializeWritableStream\");\n            function Ge(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_writableStreamController\") ? !1 : e instanceof de;\n            }\n            n(Ge, \"IsWritableStream\");\n            function Ze(e) {\n                return e._writer !== void 0;\n            }\n            n(Ze, \"IsWritableStreamLocked\");\n            function Zt(e, t) {\n                var r;\n                if (e._state === \"closed\" || e._state === \"errored\") return T(void 0);\n                e._writableStreamController._abortReason = t, (r = e._writableStreamController._abortController) === null || r === void 0 || r.abort(t);\n                const s = e._state;\n                if (s === \"closed\" || s === \"errored\") return T(void 0);\n                if (e._pendingAbortRequest !== void 0) return e._pendingAbortRequest._promise;\n                let f = !1;\n                s === \"erroring\" && (f = !0, t = void 0);\n                const c = E((d, m)=>{\n                    e._pendingAbortRequest = {\n                        _promise: void 0,\n                        _resolve: d,\n                        _reject: m,\n                        _reason: t,\n                        _wasAlreadyErroring: f\n                    };\n                });\n                return e._pendingAbortRequest._promise = c, f || Xr(e, t), c;\n            }\n            n(Zt, \"WritableStreamAbort\");\n            function qo(e) {\n                const t = e._state;\n                if (t === \"closed\" || t === \"errored\") return b(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));\n                const r = E((f, c)=>{\n                    const d = {\n                        _resolve: f,\n                        _reject: c\n                    };\n                    e._closeRequest = d;\n                }), s = e._writer;\n                return s !== void 0 && e._backpressure && t === \"writable\" && ln(s), Fa(e._writableStreamController), r;\n            }\n            n(qo, \"WritableStreamClose\");\n            function Ta(e) {\n                return E((r, s)=>{\n                    const f = {\n                        _resolve: r,\n                        _reject: s\n                    };\n                    e._writeRequests.push(f);\n                });\n            }\n            n(Ta, \"WritableStreamAddWriteRequest\");\n            function Jr(e, t) {\n                if (e._state === \"writable\") {\n                    Xr(e, t);\n                    return;\n                }\n                en(e);\n            }\n            n(Jr, \"WritableStreamDealWithRejection\");\n            function Xr(e, t) {\n                const r = e._writableStreamController;\n                e._state = \"erroring\", e._storedError = t;\n                const s = e._writer;\n                s !== void 0 && zo(s, t), !Aa(e) && r._started && en(e);\n            }\n            n(Xr, \"WritableStreamStartErroring\");\n            function en(e) {\n                e._state = \"errored\", e._writableStreamController[Qn]();\n                const t = e._storedError;\n                if (e._writeRequests.forEach((f)=>{\n                    f._reject(t);\n                }), e._writeRequests = new D, e._pendingAbortRequest === void 0) {\n                    Kt(e);\n                    return;\n                }\n                const r = e._pendingAbortRequest;\n                if (e._pendingAbortRequest = void 0, r._wasAlreadyErroring) {\n                    r._reject(t), Kt(e);\n                    return;\n                }\n                const s = e._writableStreamController[Ft](r._reason);\n                _(s, ()=>(r._resolve(), Kt(e), null), (f)=>(r._reject(f), Kt(e), null));\n            }\n            n(en, \"WritableStreamFinishErroring\");\n            function Ca(e) {\n                e._inFlightWriteRequest._resolve(void 0), e._inFlightWriteRequest = void 0;\n            }\n            n(Ca, \"WritableStreamFinishInFlightWrite\");\n            function Pa(e, t) {\n                e._inFlightWriteRequest._reject(t), e._inFlightWriteRequest = void 0, Jr(e, t);\n            }\n            n(Pa, \"WritableStreamFinishInFlightWriteWithError\");\n            function va(e) {\n                e._inFlightCloseRequest._resolve(void 0), e._inFlightCloseRequest = void 0, e._state === \"erroring\" && (e._storedError = void 0, e._pendingAbortRequest !== void 0 && (e._pendingAbortRequest._resolve(), e._pendingAbortRequest = void 0)), e._state = \"closed\";\n                const r = e._writer;\n                r !== void 0 && Uo(r);\n            }\n            n(va, \"WritableStreamFinishInFlightClose\");\n            function Ea(e, t) {\n                e._inFlightCloseRequest._reject(t), e._inFlightCloseRequest = void 0, e._pendingAbortRequest !== void 0 && (e._pendingAbortRequest._reject(t), e._pendingAbortRequest = void 0), Jr(e, t);\n            }\n            n(Ea, \"WritableStreamFinishInFlightCloseWithError\");\n            function he(e) {\n                return !(e._closeRequest === void 0 && e._inFlightCloseRequest === void 0);\n            }\n            n(he, \"WritableStreamCloseQueuedOrInFlight\");\n            function Aa(e) {\n                return !(e._inFlightWriteRequest === void 0 && e._inFlightCloseRequest === void 0);\n            }\n            n(Aa, \"WritableStreamHasOperationMarkedInFlight\");\n            function Ba(e) {\n                e._inFlightCloseRequest = e._closeRequest, e._closeRequest = void 0;\n            }\n            n(Ba, \"WritableStreamMarkCloseRequestInFlight\");\n            function ka(e) {\n                e._inFlightWriteRequest = e._writeRequests.shift();\n            }\n            n(ka, \"WritableStreamMarkFirstWriteRequestInFlight\");\n            function Kt(e) {\n                e._closeRequest !== void 0 && (e._closeRequest._reject(e._storedError), e._closeRequest = void 0);\n                const t = e._writer;\n                t !== void 0 && an(t, e._storedError);\n            }\n            n(Kt, \"WritableStreamRejectCloseAndClosedPromiseIfNeeded\");\n            function tn(e, t) {\n                const r = e._writer;\n                r !== void 0 && t !== e._backpressure && (t ? xa(r) : ln(r)), e._backpressure = t;\n            }\n            n(tn, \"WritableStreamUpdateBackpressure\");\n            const Rn = class Rn {\n                constructor(t){\n                    if (Se(t, 1, \"WritableStreamDefaultWriter\"), Bo(t, \"First parameter\"), Ze(t)) throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n                    this._ownerWritableStream = t, t._writer = this;\n                    const r = t._state;\n                    if (r === \"writable\") !he(t) && t._backpressure ? rr(this) : xo(this), tr(this);\n                    else if (r === \"erroring\") sn(this, t._storedError), tr(this);\n                    else if (r === \"closed\") xo(this), Ma(this);\n                    else {\n                        const s = t._storedError;\n                        sn(this, s), Mo(this, s);\n                    }\n                }\n                get closed() {\n                    return je(this) ? this._closedPromise : b(Le(\"closed\"));\n                }\n                get desiredSize() {\n                    if (!je(this)) throw Le(\"desiredSize\");\n                    if (this._ownerWritableStream === void 0) throw Rt(\"desiredSize\");\n                    return za(this);\n                }\n                get ready() {\n                    return je(this) ? this._readyPromise : b(Le(\"ready\"));\n                }\n                abort(t = void 0) {\n                    return je(this) ? this._ownerWritableStream === void 0 ? b(Rt(\"abort\")) : Wa(this, t) : b(Le(\"abort\"));\n                }\n                close() {\n                    if (!je(this)) return b(Le(\"close\"));\n                    const t = this._ownerWritableStream;\n                    return t === void 0 ? b(Rt(\"close\")) : he(t) ? b(new TypeError(\"Cannot close an already-closing stream\")) : Oo(this);\n                }\n                releaseLock() {\n                    if (!je(this)) throw Le(\"releaseLock\");\n                    this._ownerWritableStream !== void 0 && Io(this);\n                }\n                write(t = void 0) {\n                    return je(this) ? this._ownerWritableStream === void 0 ? b(Rt(\"write to\")) : Fo(this, t) : b(Le(\"write\"));\n                }\n            };\n            n(Rn, \"WritableStreamDefaultWriter\");\n            let re = Rn;\n            Object.defineProperties(re.prototype, {\n                abort: {\n                    enumerable: !0\n                },\n                close: {\n                    enumerable: !0\n                },\n                releaseLock: {\n                    enumerable: !0\n                },\n                write: {\n                    enumerable: !0\n                },\n                closed: {\n                    enumerable: !0\n                },\n                desiredSize: {\n                    enumerable: !0\n                },\n                ready: {\n                    enumerable: !0\n                }\n            }), h(re.prototype.abort, \"abort\"), h(re.prototype.close, \"close\"), h(re.prototype.releaseLock, \"releaseLock\"), h(re.prototype.write, \"write\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(re.prototype, Symbol.toStringTag, {\n                value: \"WritableStreamDefaultWriter\",\n                configurable: !0\n            });\n            function je(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_ownerWritableStream\") ? !1 : e instanceof re;\n            }\n            n(je, \"IsWritableStreamDefaultWriter\");\n            function Wa(e, t) {\n                const r = e._ownerWritableStream;\n                return Zt(r, t);\n            }\n            n(Wa, \"WritableStreamDefaultWriterAbort\");\n            function Oo(e) {\n                const t = e._ownerWritableStream;\n                return qo(t);\n            }\n            n(Oo, \"WritableStreamDefaultWriterClose\");\n            function qa(e) {\n                const t = e._ownerWritableStream, r = t._state;\n                return he(t) || r === \"closed\" ? T(void 0) : r === \"errored\" ? b(t._storedError) : Oo(e);\n            }\n            n(qa, \"WritableStreamDefaultWriterCloseWithErrorPropagation\");\n            function Oa(e, t) {\n                e._closedPromiseState === \"pending\" ? an(e, t) : Ua(e, t);\n            }\n            n(Oa, \"WritableStreamDefaultWriterEnsureClosedPromiseRejected\");\n            function zo(e, t) {\n                e._readyPromiseState === \"pending\" ? No(e, t) : Na(e, t);\n            }\n            n(zo, \"WritableStreamDefaultWriterEnsureReadyPromiseRejected\");\n            function za(e) {\n                const t = e._ownerWritableStream, r = t._state;\n                return r === \"errored\" || r === \"erroring\" ? null : r === \"closed\" ? 0 : $o(t._writableStreamController);\n            }\n            n(za, \"WritableStreamDefaultWriterGetDesiredSize\");\n            function Io(e) {\n                const t = e._ownerWritableStream, r = new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");\n                zo(e, r), Oa(e, r), t._writer = void 0, e._ownerWritableStream = void 0;\n            }\n            n(Io, \"WritableStreamDefaultWriterRelease\");\n            function Fo(e, t) {\n                const r = e._ownerWritableStream, s = r._writableStreamController, f = ja(s, t);\n                if (r !== e._ownerWritableStream) return b(Rt(\"write to\"));\n                const c = r._state;\n                if (c === \"errored\") return b(r._storedError);\n                if (he(r) || c === \"closed\") return b(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n                if (c === \"erroring\") return b(r._storedError);\n                const d = Ta(r);\n                return La(s, t, f), d;\n            }\n            n(Fo, \"WritableStreamDefaultWriterWrite\");\n            const jo = {}, Tn = class Tn {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get abortReason() {\n                    if (!rn(this)) throw on(\"abortReason\");\n                    return this._abortReason;\n                }\n                get signal() {\n                    if (!rn(this)) throw on(\"signal\");\n                    if (this._abortController === void 0) throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n                    return this._abortController.signal;\n                }\n                error(t = void 0) {\n                    if (!rn(this)) throw on(\"error\");\n                    this._controlledWritableStream._state === \"writable\" && Do(this, t);\n                }\n                [Ft](t) {\n                    const r = this._abortAlgorithm(t);\n                    return Jt(this), r;\n                }\n                [Qn]() {\n                    Be(this);\n                }\n            };\n            n(Tn, \"WritableStreamDefaultController\");\n            let ke = Tn;\n            Object.defineProperties(ke.prototype, {\n                abortReason: {\n                    enumerable: !0\n                },\n                signal: {\n                    enumerable: !0\n                },\n                error: {\n                    enumerable: !0\n                }\n            }), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(ke.prototype, Symbol.toStringTag, {\n                value: \"WritableStreamDefaultController\",\n                configurable: !0\n            });\n            function rn(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_controlledWritableStream\") ? !1 : e instanceof ke;\n            }\n            n(rn, \"IsWritableStreamDefaultController\");\n            function Lo(e, t, r, s, f, c, d, m) {\n                t._controlledWritableStream = e, e._writableStreamController = t, t._queue = void 0, t._queueTotalSize = void 0, Be(t), t._abortReason = void 0, t._abortController = wa(), t._started = !1, t._strategySizeAlgorithm = m, t._strategyHWM = d, t._writeAlgorithm = s, t._closeAlgorithm = f, t._abortAlgorithm = c;\n                const R = nn(t);\n                tn(e, R);\n                const y = r(), C = T(y);\n                _(C, ()=>(t._started = !0, Xt(t), null), (P)=>(t._started = !0, Jr(e, P), null));\n            }\n            n(Lo, \"SetUpWritableStreamDefaultController\");\n            function Ia(e, t, r, s) {\n                const f = Object.create(ke.prototype);\n                let c, d, m, R;\n                t.start !== void 0 ? c = n(()=>t.start(f), \"startAlgorithm\") : c = n(()=>{}, \"startAlgorithm\"), t.write !== void 0 ? d = n((y)=>t.write(y, f), \"writeAlgorithm\") : d = n(()=>T(void 0), \"writeAlgorithm\"), t.close !== void 0 ? m = n(()=>t.close(), \"closeAlgorithm\") : m = n(()=>T(void 0), \"closeAlgorithm\"), t.abort !== void 0 ? R = n((y)=>t.abort(y), \"abortAlgorithm\") : R = n(()=>T(void 0), \"abortAlgorithm\"), Lo(e, f, c, d, m, R, r, s);\n            }\n            n(Ia, \"SetUpWritableStreamDefaultControllerFromUnderlyingSink\");\n            function Jt(e) {\n                e._writeAlgorithm = void 0, e._closeAlgorithm = void 0, e._abortAlgorithm = void 0, e._strategySizeAlgorithm = void 0;\n            }\n            n(Jt, \"WritableStreamDefaultControllerClearAlgorithms\");\n            function Fa(e) {\n                Nr(e, jo, 0), Xt(e);\n            }\n            n(Fa, \"WritableStreamDefaultControllerClose\");\n            function ja(e, t) {\n                try {\n                    return e._strategySizeAlgorithm(t);\n                } catch (r) {\n                    return wt(e, r), 1;\n                }\n            }\n            n(ja, \"WritableStreamDefaultControllerGetChunkSize\");\n            function $o(e) {\n                return e._strategyHWM - e._queueTotalSize;\n            }\n            n($o, \"WritableStreamDefaultControllerGetDesiredSize\");\n            function La(e, t, r) {\n                try {\n                    Nr(e, t, r);\n                } catch (f) {\n                    wt(e, f);\n                    return;\n                }\n                const s = e._controlledWritableStream;\n                if (!he(s) && s._state === \"writable\") {\n                    const f = nn(e);\n                    tn(s, f);\n                }\n                Xt(e);\n            }\n            n(La, \"WritableStreamDefaultControllerWrite\");\n            function Xt(e) {\n                const t = e._controlledWritableStream;\n                if (!e._started || t._inFlightWriteRequest !== void 0) return;\n                if (t._state === \"erroring\") {\n                    en(t);\n                    return;\n                }\n                if (e._queue.length === 0) return;\n                const s = Ji(e);\n                s === jo ? $a(e) : Da(e, s);\n            }\n            n(Xt, \"WritableStreamDefaultControllerAdvanceQueueIfNeeded\");\n            function wt(e, t) {\n                e._controlledWritableStream._state === \"writable\" && Do(e, t);\n            }\n            n(wt, \"WritableStreamDefaultControllerErrorIfNeeded\");\n            function $a(e) {\n                const t = e._controlledWritableStream;\n                Ba(t), xr(e);\n                const r = e._closeAlgorithm();\n                Jt(e), _(r, ()=>(va(t), null), (s)=>(Ea(t, s), null));\n            }\n            n($a, \"WritableStreamDefaultControllerProcessClose\");\n            function Da(e, t) {\n                const r = e._controlledWritableStream;\n                ka(r);\n                const s = e._writeAlgorithm(t);\n                _(s, ()=>{\n                    Ca(r);\n                    const f = r._state;\n                    if (xr(e), !he(r) && f === \"writable\") {\n                        const c = nn(e);\n                        tn(r, c);\n                    }\n                    return Xt(e), null;\n                }, (f)=>(r._state === \"writable\" && Jt(e), Pa(r, f), null));\n            }\n            n(Da, \"WritableStreamDefaultControllerProcessWrite\");\n            function nn(e) {\n                return $o(e) <= 0;\n            }\n            n(nn, \"WritableStreamDefaultControllerGetBackpressure\");\n            function Do(e, t) {\n                const r = e._controlledWritableStream;\n                Jt(e), Xr(r, t);\n            }\n            n(Do, \"WritableStreamDefaultControllerError\");\n            function er(e) {\n                return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`);\n            }\n            n(er, \"streamBrandCheckException$2\");\n            function on(e) {\n                return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`);\n            }\n            n(on, \"defaultControllerBrandCheckException$2\");\n            function Le(e) {\n                return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`);\n            }\n            n(Le, \"defaultWriterBrandCheckException\");\n            function Rt(e) {\n                return new TypeError(\"Cannot \" + e + \" a stream using a released writer\");\n            }\n            n(Rt, \"defaultWriterLockException\");\n            function tr(e) {\n                e._closedPromise = E((t, r)=>{\n                    e._closedPromise_resolve = t, e._closedPromise_reject = r, e._closedPromiseState = \"pending\";\n                });\n            }\n            n(tr, \"defaultWriterClosedPromiseInitialize\");\n            function Mo(e, t) {\n                tr(e), an(e, t);\n            }\n            n(Mo, \"defaultWriterClosedPromiseInitializeAsRejected\");\n            function Ma(e) {\n                tr(e), Uo(e);\n            }\n            n(Ma, \"defaultWriterClosedPromiseInitializeAsResolved\");\n            function an(e, t) {\n                e._closedPromise_reject !== void 0 && (Q(e._closedPromise), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = \"rejected\");\n            }\n            n(an, \"defaultWriterClosedPromiseReject\");\n            function Ua(e, t) {\n                Mo(e, t);\n            }\n            n(Ua, \"defaultWriterClosedPromiseResetToRejected\");\n            function Uo(e) {\n                e._closedPromise_resolve !== void 0 && (e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = \"resolved\");\n            }\n            n(Uo, \"defaultWriterClosedPromiseResolve\");\n            function rr(e) {\n                e._readyPromise = E((t, r)=>{\n                    e._readyPromise_resolve = t, e._readyPromise_reject = r;\n                }), e._readyPromiseState = \"pending\";\n            }\n            n(rr, \"defaultWriterReadyPromiseInitialize\");\n            function sn(e, t) {\n                rr(e), No(e, t);\n            }\n            n(sn, \"defaultWriterReadyPromiseInitializeAsRejected\");\n            function xo(e) {\n                rr(e), ln(e);\n            }\n            n(xo, \"defaultWriterReadyPromiseInitializeAsResolved\");\n            function No(e, t) {\n                e._readyPromise_reject !== void 0 && (Q(e._readyPromise), e._readyPromise_reject(t), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = \"rejected\");\n            }\n            n(No, \"defaultWriterReadyPromiseReject\");\n            function xa(e) {\n                rr(e);\n            }\n            n(xa, \"defaultWriterReadyPromiseReset\");\n            function Na(e, t) {\n                sn(e, t);\n            }\n            n(Na, \"defaultWriterReadyPromiseResetToRejected\");\n            function ln(e) {\n                e._readyPromise_resolve !== void 0 && (e._readyPromise_resolve(void 0), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = \"fulfilled\");\n            }\n            n(ln, \"defaultWriterReadyPromiseResolve\");\n            function Ha() {\n                if (typeof globalThis < \"u\") return globalThis;\n                if (typeof self < \"u\") return self;\n                if (typeof _shared_node_fetch_native_1a4a356d_mjs__WEBPACK_IMPORTED_MODULE_6__.c < \"u\") return _shared_node_fetch_native_1a4a356d_mjs__WEBPACK_IMPORTED_MODULE_6__.c;\n            }\n            n(Ha, \"getGlobals\");\n            const un = Ha();\n            function Va(e) {\n                if (!(typeof e == \"function\" || typeof e == \"object\") || e.name !== \"DOMException\") return !1;\n                try {\n                    return new e, !0;\n                } catch  {\n                    return !1;\n                }\n            }\n            n(Va, \"isDOMExceptionConstructor\");\n            function Qa() {\n                const e = un?.DOMException;\n                return Va(e) ? e : void 0;\n            }\n            n(Qa, \"getFromGlobal\");\n            function Ya() {\n                const e = n(function(r, s) {\n                    this.message = r || \"\", this.name = s || \"Error\", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);\n                }, \"DOMException\");\n                return h(e, \"DOMException\"), e.prototype = Object.create(Error.prototype), Object.defineProperty(e.prototype, \"constructor\", {\n                    value: e,\n                    writable: !0,\n                    configurable: !0\n                }), e;\n            }\n            n(Ya, \"createPolyfill\");\n            const Ga = Qa() || Ya();\n            function Ho(e, t, r, s, f, c) {\n                const d = Qe(e), m = ko(t);\n                e._disturbed = !0;\n                let R = !1, y = T(void 0);\n                return E((C, P)=>{\n                    let B;\n                    if (c !== void 0) {\n                        if (B = n(()=>{\n                            const S = c.reason !== void 0 ? c.reason : new Ga(\"Aborted\", \"AbortError\"), v = [];\n                            s || v.push(()=>t._state === \"writable\" ? Zt(t, S) : T(void 0)), f || v.push(()=>e._state === \"readable\" ? ie(e, S) : T(void 0)), N(()=>Promise.all(v.map((k)=>k())), !0, S);\n                        }, \"abortAlgorithm\"), c.aborted) {\n                            B();\n                            return;\n                        }\n                        c.addEventListener(\"abort\", B);\n                    }\n                    function ae() {\n                        return E((S, v)=>{\n                            function k(Y) {\n                                Y ? S() : q(nt(), k, v);\n                            }\n                            n(k, \"next\"), k(!1);\n                        });\n                    }\n                    n(ae, \"pipeLoop\");\n                    function nt() {\n                        return R ? T(!0) : q(m._readyPromise, ()=>E((S, v)=>{\n                                mt(d, {\n                                    _chunkSteps: (k)=>{\n                                        y = q(Fo(m, k), void 0, u), S(!1);\n                                    },\n                                    _closeSteps: ()=>S(!0),\n                                    _errorSteps: v\n                                });\n                            }));\n                    }\n                    if (n(nt, \"pipeStep\"), Te(e, d._closedPromise, (S)=>(s ? J(!0, S) : N(()=>Zt(t, S), !0, S), null)), Te(t, m._closedPromise, (S)=>(f ? J(!0, S) : N(()=>ie(e, S), !0, S), null)), x(e, d._closedPromise, ()=>(r ? J() : N(()=>qa(m)), null)), he(t) || t._state === \"closed\") {\n                        const S = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                        f ? J(!0, S) : N(()=>ie(e, S), !0, S);\n                    }\n                    Q(ae());\n                    function Oe() {\n                        const S = y;\n                        return q(y, ()=>S !== y ? Oe() : void 0);\n                    }\n                    n(Oe, \"waitForWritesToFinish\");\n                    function Te(S, v, k) {\n                        S._state === \"errored\" ? k(S._storedError) : I(v, k);\n                    }\n                    n(Te, \"isOrBecomesErrored\");\n                    function x(S, v, k) {\n                        S._state === \"closed\" ? k() : V(v, k);\n                    }\n                    n(x, \"isOrBecomesClosed\");\n                    function N(S, v, k) {\n                        if (R) return;\n                        R = !0, t._state === \"writable\" && !he(t) ? V(Oe(), Y) : Y();\n                        function Y() {\n                            return _(S(), ()=>Ce(v, k), (ot)=>Ce(!0, ot)), null;\n                        }\n                        n(Y, \"doTheRest\");\n                    }\n                    n(N, \"shutdownWithAction\");\n                    function J(S, v) {\n                        R || (R = !0, t._state === \"writable\" && !he(t) ? V(Oe(), ()=>Ce(S, v)) : Ce(S, v));\n                    }\n                    n(J, \"shutdown\");\n                    function Ce(S, v) {\n                        return Io(m), _e(d), c !== void 0 && c.removeEventListener(\"abort\", B), S ? P(v) : C(void 0), null;\n                    }\n                    n(Ce, \"finalize\");\n                });\n            }\n            n(Ho, \"ReadableStreamPipeTo\");\n            const Cn = class Cn {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get desiredSize() {\n                    if (!nr(this)) throw ir(\"desiredSize\");\n                    return fn(this);\n                }\n                close() {\n                    if (!nr(this)) throw ir(\"close\");\n                    if (!Je(this)) throw new TypeError(\"The stream is not in a state that permits close\");\n                    $e(this);\n                }\n                enqueue(t = void 0) {\n                    if (!nr(this)) throw ir(\"enqueue\");\n                    if (!Je(this)) throw new TypeError(\"The stream is not in a state that permits enqueue\");\n                    return Ke(this, t);\n                }\n                error(t = void 0) {\n                    if (!nr(this)) throw ir(\"error\");\n                    oe(this, t);\n                }\n                [Ar](t) {\n                    Be(this);\n                    const r = this._cancelAlgorithm(t);\n                    return or(this), r;\n                }\n                [Br](t) {\n                    const r = this._controlledReadableStream;\n                    if (this._queue.length > 0) {\n                        const s = xr(this);\n                        this._closeRequested && this._queue.length === 0 ? (or(this), Pt(r)) : Tt(this), t._chunkSteps(s);\n                    } else eo(r, t), Tt(this);\n                }\n                [kr]() {}\n            };\n            n(Cn, \"ReadableStreamDefaultController\");\n            let ne = Cn;\n            Object.defineProperties(ne.prototype, {\n                close: {\n                    enumerable: !0\n                },\n                enqueue: {\n                    enumerable: !0\n                },\n                error: {\n                    enumerable: !0\n                },\n                desiredSize: {\n                    enumerable: !0\n                }\n            }), h(ne.prototype.close, \"close\"), h(ne.prototype.enqueue, \"enqueue\"), h(ne.prototype.error, \"error\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(ne.prototype, Symbol.toStringTag, {\n                value: \"ReadableStreamDefaultController\",\n                configurable: !0\n            });\n            function nr(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_controlledReadableStream\") ? !1 : e instanceof ne;\n            }\n            n(nr, \"IsReadableStreamDefaultController\");\n            function Tt(e) {\n                if (!Vo(e)) return;\n                if (e._pulling) {\n                    e._pullAgain = !0;\n                    return;\n                }\n                e._pulling = !0;\n                const r = e._pullAlgorithm();\n                _(r, ()=>(e._pulling = !1, e._pullAgain && (e._pullAgain = !1, Tt(e)), null), (s)=>(oe(e, s), null));\n            }\n            n(Tt, \"ReadableStreamDefaultControllerCallPullIfNeeded\");\n            function Vo(e) {\n                const t = e._controlledReadableStream;\n                return !Je(e) || !e._started ? !1 : !!(qe(t) && Lt(t) > 0 || fn(e) > 0);\n            }\n            n(Vo, \"ReadableStreamDefaultControllerShouldCallPull\");\n            function or(e) {\n                e._pullAlgorithm = void 0, e._cancelAlgorithm = void 0, e._strategySizeAlgorithm = void 0;\n            }\n            n(or, \"ReadableStreamDefaultControllerClearAlgorithms\");\n            function $e(e) {\n                if (!Je(e)) return;\n                const t = e._controlledReadableStream;\n                e._closeRequested = !0, e._queue.length === 0 && (or(e), Pt(t));\n            }\n            n($e, \"ReadableStreamDefaultControllerClose\");\n            function Ke(e, t) {\n                if (!Je(e)) return;\n                const r = e._controlledReadableStream;\n                if (qe(r) && Lt(r) > 0) Lr(r, t, !1);\n                else {\n                    let s;\n                    try {\n                        s = e._strategySizeAlgorithm(t);\n                    } catch (f) {\n                        throw oe(e, f), f;\n                    }\n                    try {\n                        Nr(e, t, s);\n                    } catch (f) {\n                        throw oe(e, f), f;\n                    }\n                }\n                Tt(e);\n            }\n            n(Ke, \"ReadableStreamDefaultControllerEnqueue\");\n            function oe(e, t) {\n                const r = e._controlledReadableStream;\n                r._state === \"readable\" && (Be(e), or(e), Zo(r, t));\n            }\n            n(oe, \"ReadableStreamDefaultControllerError\");\n            function fn(e) {\n                const t = e._controlledReadableStream._state;\n                return t === \"errored\" ? null : t === \"closed\" ? 0 : e._strategyHWM - e._queueTotalSize;\n            }\n            n(fn, \"ReadableStreamDefaultControllerGetDesiredSize\");\n            function Za(e) {\n                return !Vo(e);\n            }\n            n(Za, \"ReadableStreamDefaultControllerHasBackpressure\");\n            function Je(e) {\n                const t = e._controlledReadableStream._state;\n                return !e._closeRequested && t === \"readable\";\n            }\n            n(Je, \"ReadableStreamDefaultControllerCanCloseOrEnqueue\");\n            function Qo(e, t, r, s, f, c, d) {\n                t._controlledReadableStream = e, t._queue = void 0, t._queueTotalSize = void 0, Be(t), t._started = !1, t._closeRequested = !1, t._pullAgain = !1, t._pulling = !1, t._strategySizeAlgorithm = d, t._strategyHWM = c, t._pullAlgorithm = s, t._cancelAlgorithm = f, e._readableStreamController = t;\n                const m = r();\n                _(T(m), ()=>(t._started = !0, Tt(t), null), (R)=>(oe(t, R), null));\n            }\n            n(Qo, \"SetUpReadableStreamDefaultController\");\n            function Ka(e, t, r, s) {\n                const f = Object.create(ne.prototype);\n                let c, d, m;\n                t.start !== void 0 ? c = n(()=>t.start(f), \"startAlgorithm\") : c = n(()=>{}, \"startAlgorithm\"), t.pull !== void 0 ? d = n(()=>t.pull(f), \"pullAlgorithm\") : d = n(()=>T(void 0), \"pullAlgorithm\"), t.cancel !== void 0 ? m = n((R)=>t.cancel(R), \"cancelAlgorithm\") : m = n(()=>T(void 0), \"cancelAlgorithm\"), Qo(e, f, c, d, m, r, s);\n            }\n            n(Ka, \"SetUpReadableStreamDefaultControllerFromUnderlyingSource\");\n            function ir(e) {\n                return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`);\n            }\n            n(ir, \"defaultControllerBrandCheckException$1\");\n            function Ja(e, t) {\n                return ze(e._readableStreamController) ? es(e) : Xa(e);\n            }\n            n(Ja, \"ReadableStreamTee\");\n            function Xa(e, t) {\n                const r = Qe(e);\n                let s = !1, f = !1, c = !1, d = !1, m, R, y, C, P;\n                const B = E((x)=>{\n                    P = x;\n                });\n                function ae() {\n                    return s ? (f = !0, T(void 0)) : (s = !0, mt(r, {\n                        _chunkSteps: (N)=>{\n                            ge(()=>{\n                                f = !1;\n                                const J = N, Ce = N;\n                                c || Ke(y._readableStreamController, J), d || Ke(C._readableStreamController, Ce), s = !1, f && ae();\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            s = !1, c || $e(y._readableStreamController), d || $e(C._readableStreamController), (!c || !d) && P(void 0);\n                        },\n                        _errorSteps: ()=>{\n                            s = !1;\n                        }\n                    }), T(void 0));\n                }\n                n(ae, \"pullAlgorithm\");\n                function nt(x) {\n                    if (c = !0, m = x, d) {\n                        const N = yt([\n                            m,\n                            R\n                        ]), J = ie(e, N);\n                        P(J);\n                    }\n                    return B;\n                }\n                n(nt, \"cancel1Algorithm\");\n                function Oe(x) {\n                    if (d = !0, R = x, c) {\n                        const N = yt([\n                            m,\n                            R\n                        ]), J = ie(e, N);\n                        P(J);\n                    }\n                    return B;\n                }\n                n(Oe, \"cancel2Algorithm\");\n                function Te() {}\n                return n(Te, \"startAlgorithm\"), y = Ct(Te, ae, nt), C = Ct(Te, ae, Oe), I(r._closedPromise, (x)=>(oe(y._readableStreamController, x), oe(C._readableStreamController, x), (!c || !d) && P(void 0), null)), [\n                    y,\n                    C\n                ];\n            }\n            n(Xa, \"ReadableStreamDefaultTee\");\n            function es(e) {\n                let t = Qe(e), r = !1, s = !1, f = !1, c = !1, d = !1, m, R, y, C, P;\n                const B = E((S)=>{\n                    P = S;\n                });\n                function ae(S) {\n                    I(S._closedPromise, (v)=>(S !== t || (K(y._readableStreamController, v), K(C._readableStreamController, v), (!c || !d) && P(void 0)), null));\n                }\n                n(ae, \"forwardReaderError\");\n                function nt() {\n                    Fe(t) && (_e(t), t = Qe(e), ae(t)), mt(t, {\n                        _chunkSteps: (v)=>{\n                            ge(()=>{\n                                s = !1, f = !1;\n                                const k = v;\n                                let Y = v;\n                                if (!c && !d) try {\n                                    Y = fo(v);\n                                } catch (ot) {\n                                    K(y._readableStreamController, ot), K(C._readableStreamController, ot), P(ie(e, ot));\n                                    return;\n                                }\n                                c || Nt(y._readableStreamController, k), d || Nt(C._readableStreamController, Y), r = !1, s ? Te() : f && x();\n                            });\n                        },\n                        _closeSteps: ()=>{\n                            r = !1, c || gt(y._readableStreamController), d || gt(C._readableStreamController), y._readableStreamController._pendingPullIntos.length > 0 && Ht(y._readableStreamController, 0), C._readableStreamController._pendingPullIntos.length > 0 && Ht(C._readableStreamController, 0), (!c || !d) && P(void 0);\n                        },\n                        _errorSteps: ()=>{\n                            r = !1;\n                        }\n                    });\n                }\n                n(nt, \"pullWithDefaultReader\");\n                function Oe(S, v) {\n                    Ee(t) && (_e(t), t = Co(e), ae(t));\n                    const k = v ? C : y, Y = v ? y : C;\n                    Eo(t, S, 1, {\n                        _chunkSteps: (it)=>{\n                            ge(()=>{\n                                s = !1, f = !1;\n                                const at = v ? d : c;\n                                if (v ? c : d) at || Vt(k._readableStreamController, it);\n                                else {\n                                    let ui;\n                                    try {\n                                        ui = fo(it);\n                                    } catch (kn) {\n                                        K(k._readableStreamController, kn), K(Y._readableStreamController, kn), P(ie(e, kn));\n                                        return;\n                                    }\n                                    at || Vt(k._readableStreamController, it), Nt(Y._readableStreamController, ui);\n                                }\n                                r = !1, s ? Te() : f && x();\n                            });\n                        },\n                        _closeSteps: (it)=>{\n                            r = !1;\n                            const at = v ? d : c, fr = v ? c : d;\n                            at || gt(k._readableStreamController), fr || gt(Y._readableStreamController), it !== void 0 && (at || Vt(k._readableStreamController, it), !fr && Y._readableStreamController._pendingPullIntos.length > 0 && Ht(Y._readableStreamController, 0)), (!at || !fr) && P(void 0);\n                        },\n                        _errorSteps: ()=>{\n                            r = !1;\n                        }\n                    });\n                }\n                n(Oe, \"pullWithBYOBReader\");\n                function Te() {\n                    if (r) return s = !0, T(void 0);\n                    r = !0;\n                    const S = Gr(y._readableStreamController);\n                    return S === null ? nt() : Oe(S._view, !1), T(void 0);\n                }\n                n(Te, \"pull1Algorithm\");\n                function x() {\n                    if (r) return f = !0, T(void 0);\n                    r = !0;\n                    const S = Gr(C._readableStreamController);\n                    return S === null ? nt() : Oe(S._view, !0), T(void 0);\n                }\n                n(x, \"pull2Algorithm\");\n                function N(S) {\n                    if (c = !0, m = S, d) {\n                        const v = yt([\n                            m,\n                            R\n                        ]), k = ie(e, v);\n                        P(k);\n                    }\n                    return B;\n                }\n                n(N, \"cancel1Algorithm\");\n                function J(S) {\n                    if (d = !0, R = S, c) {\n                        const v = yt([\n                            m,\n                            R\n                        ]), k = ie(e, v);\n                        P(k);\n                    }\n                    return B;\n                }\n                n(J, \"cancel2Algorithm\");\n                function Ce() {}\n                return n(Ce, \"startAlgorithm\"), y = Go(Ce, Te, N), C = Go(Ce, x, J), ae(t), [\n                    y,\n                    C\n                ];\n            }\n            n(es, \"ReadableByteStreamTee\");\n            function ts(e) {\n                return l(e) && typeof e.getReader < \"u\";\n            }\n            n(ts, \"isReadableStreamLike\");\n            function rs(e) {\n                return ts(e) ? os(e.getReader()) : ns(e);\n            }\n            n(rs, \"ReadableStreamFrom\");\n            function ns(e) {\n                let t;\n                const r = uo(e, \"async\"), s = u;\n                function f() {\n                    let d;\n                    try {\n                        d = Yi(r);\n                    } catch (R) {\n                        return b(R);\n                    }\n                    const m = T(d);\n                    return F(m, (R)=>{\n                        if (!l(R)) throw new TypeError(\"The promise returned by the iterator.next() method must fulfill with an object\");\n                        if (Gi(R)) $e(t._readableStreamController);\n                        else {\n                            const C = Zi(R);\n                            Ke(t._readableStreamController, C);\n                        }\n                    });\n                }\n                n(f, \"pullAlgorithm\");\n                function c(d) {\n                    const m = r.iterator;\n                    let R;\n                    try {\n                        R = Mt(m, \"return\");\n                    } catch (P) {\n                        return b(P);\n                    }\n                    if (R === void 0) return T(void 0);\n                    let y;\n                    try {\n                        y = z(R, m, [\n                            d\n                        ]);\n                    } catch (P) {\n                        return b(P);\n                    }\n                    const C = T(y);\n                    return F(C, (P)=>{\n                        if (!l(P)) throw new TypeError(\"The promise returned by the iterator.return() method must fulfill with an object\");\n                    });\n                }\n                return n(c, \"cancelAlgorithm\"), t = Ct(s, f, c, 0), t;\n            }\n            n(ns, \"ReadableStreamFromIterable\");\n            function os(e) {\n                let t;\n                const r = u;\n                function s() {\n                    let c;\n                    try {\n                        c = e.read();\n                    } catch (d) {\n                        return b(d);\n                    }\n                    return F(c, (d)=>{\n                        if (!l(d)) throw new TypeError(\"The promise returned by the reader.read() method must fulfill with an object\");\n                        if (d.done) $e(t._readableStreamController);\n                        else {\n                            const m = d.value;\n                            Ke(t._readableStreamController, m);\n                        }\n                    });\n                }\n                n(s, \"pullAlgorithm\");\n                function f(c) {\n                    try {\n                        return T(e.cancel(c));\n                    } catch (d) {\n                        return b(d);\n                    }\n                }\n                return n(f, \"cancelAlgorithm\"), t = Ct(r, s, f, 0), t;\n            }\n            n(os, \"ReadableStreamFromDefaultReader\");\n            function is(e, t) {\n                ue(e, t);\n                const r = e, s = r?.autoAllocateChunkSize, f = r?.cancel, c = r?.pull, d = r?.start, m = r?.type;\n                return {\n                    autoAllocateChunkSize: s === void 0 ? void 0 : Fr(s, `${t} has member 'autoAllocateChunkSize' that`),\n                    cancel: f === void 0 ? void 0 : as(f, r, `${t} has member 'cancel' that`),\n                    pull: c === void 0 ? void 0 : ss(c, r, `${t} has member 'pull' that`),\n                    start: d === void 0 ? void 0 : ls(d, r, `${t} has member 'start' that`),\n                    type: m === void 0 ? void 0 : us(m, `${t} has member 'type' that`)\n                };\n            }\n            n(is, \"convertUnderlyingDefaultOrByteSource\");\n            function as(e, t, r) {\n                return Z(e, r), (s)=>j(e, t, [\n                        s\n                    ]);\n            }\n            n(as, \"convertUnderlyingSourceCancelCallback\");\n            function ss(e, t, r) {\n                return Z(e, r), (s)=>j(e, t, [\n                        s\n                    ]);\n            }\n            n(ss, \"convertUnderlyingSourcePullCallback\");\n            function ls(e, t, r) {\n                return Z(e, r), (s)=>z(e, t, [\n                        s\n                    ]);\n            }\n            n(ls, \"convertUnderlyingSourceStartCallback\");\n            function us(e, t) {\n                if (e = `${e}`, e !== \"bytes\") throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);\n                return e;\n            }\n            n(us, \"convertReadableStreamType\");\n            function fs(e, t) {\n                return ue(e, t), {\n                    preventCancel: !!e?.preventCancel\n                };\n            }\n            n(fs, \"convertIteratorOptions\");\n            function Yo(e, t) {\n                ue(e, t);\n                const r = e?.preventAbort, s = e?.preventCancel, f = e?.preventClose, c = e?.signal;\n                return c !== void 0 && cs(c, `${t} has member 'signal' that`), {\n                    preventAbort: !!r,\n                    preventCancel: !!s,\n                    preventClose: !!f,\n                    signal: c\n                };\n            }\n            n(Yo, \"convertPipeOptions\");\n            function cs(e, t) {\n                if (!_a(e)) throw new TypeError(`${t} is not an AbortSignal.`);\n            }\n            n(cs, \"assertAbortSignal\");\n            function ds(e, t) {\n                ue(e, t);\n                const r = e?.readable;\n                zr(r, \"readable\", \"ReadableWritablePair\"), jr(r, `${t} has member 'readable' that`);\n                const s = e?.writable;\n                return zr(s, \"writable\", \"ReadableWritablePair\"), Bo(s, `${t} has member 'writable' that`), {\n                    readable: r,\n                    writable: s\n                };\n            }\n            n(ds, \"convertReadableWritablePair\");\n            const Pn = class Pn {\n                constructor(t = {}, r = {}){\n                    t === void 0 ? t = null : Jn(t, \"First parameter\");\n                    const s = Gt(r, \"Second parameter\"), f = is(t, \"First parameter\");\n                    if (cn(this), f.type === \"bytes\") {\n                        if (s.size !== void 0) throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                        const c = St(s, 0);\n                        aa(this, f, c);\n                    } else {\n                        const c = Yt(s), d = St(s, 1);\n                        Ka(this, f, d, c);\n                    }\n                }\n                get locked() {\n                    if (!We(this)) throw De(\"locked\");\n                    return qe(this);\n                }\n                cancel(t = void 0) {\n                    return We(this) ? qe(this) ? b(new TypeError(\"Cannot cancel a stream that already has a reader\")) : ie(this, t) : b(De(\"cancel\"));\n                }\n                getReader(t = void 0) {\n                    if (!We(this)) throw De(\"getReader\");\n                    return la(t, \"First parameter\").mode === void 0 ? Qe(this) : Co(this);\n                }\n                pipeThrough(t, r = {}) {\n                    if (!We(this)) throw De(\"pipeThrough\");\n                    Se(t, 1, \"pipeThrough\");\n                    const s = ds(t, \"First parameter\"), f = Yo(r, \"Second parameter\");\n                    if (qe(this)) throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n                    if (Ze(s.writable)) throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n                    const c = Ho(this, s.writable, f.preventClose, f.preventAbort, f.preventCancel, f.signal);\n                    return Q(c), s.readable;\n                }\n                pipeTo(t, r = {}) {\n                    if (!We(this)) return b(De(\"pipeTo\"));\n                    if (t === void 0) return b(\"Parameter 1 is required in 'pipeTo'.\");\n                    if (!Ge(t)) return b(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));\n                    let s;\n                    try {\n                        s = Yo(r, \"Second parameter\");\n                    } catch (f) {\n                        return b(f);\n                    }\n                    return qe(this) ? b(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\")) : Ze(t) ? b(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\")) : Ho(this, t, s.preventClose, s.preventAbort, s.preventCancel, s.signal);\n                }\n                tee() {\n                    if (!We(this)) throw De(\"tee\");\n                    const t = Ja(this);\n                    return yt(t);\n                }\n                values(t = void 0) {\n                    if (!We(this)) throw De(\"values\");\n                    const r = fs(t, \"First parameter\");\n                    return Vi(this, r.preventCancel);\n                }\n                [Ur](t) {\n                    return this.values(t);\n                }\n                static from(t) {\n                    return rs(t);\n                }\n            };\n            n(Pn, \"ReadableStream\");\n            let L = Pn;\n            Object.defineProperties(L, {\n                from: {\n                    enumerable: !0\n                }\n            }), Object.defineProperties(L.prototype, {\n                cancel: {\n                    enumerable: !0\n                },\n                getReader: {\n                    enumerable: !0\n                },\n                pipeThrough: {\n                    enumerable: !0\n                },\n                pipeTo: {\n                    enumerable: !0\n                },\n                tee: {\n                    enumerable: !0\n                },\n                values: {\n                    enumerable: !0\n                },\n                locked: {\n                    enumerable: !0\n                }\n            }), h(L.from, \"from\"), h(L.prototype.cancel, \"cancel\"), h(L.prototype.getReader, \"getReader\"), h(L.prototype.pipeThrough, \"pipeThrough\"), h(L.prototype.pipeTo, \"pipeTo\"), h(L.prototype.tee, \"tee\"), h(L.prototype.values, \"values\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(L.prototype, Symbol.toStringTag, {\n                value: \"ReadableStream\",\n                configurable: !0\n            }), Object.defineProperty(L.prototype, Ur, {\n                value: L.prototype.values,\n                writable: !0,\n                configurable: !0\n            });\n            function Ct(e, t, r, s = 1, f = ()=>1) {\n                const c = Object.create(L.prototype);\n                cn(c);\n                const d = Object.create(ne.prototype);\n                return Qo(c, d, e, t, r, s, f), c;\n            }\n            n(Ct, \"CreateReadableStream\");\n            function Go(e, t, r) {\n                const s = Object.create(L.prototype);\n                cn(s);\n                const f = Object.create(te.prototype);\n                return To(s, f, e, t, r, 0, void 0), s;\n            }\n            n(Go, \"CreateReadableByteStream\");\n            function cn(e) {\n                e._state = \"readable\", e._reader = void 0, e._storedError = void 0, e._disturbed = !1;\n            }\n            n(cn, \"InitializeReadableStream\");\n            function We(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_readableStreamController\") ? !1 : e instanceof L;\n            }\n            n(We, \"IsReadableStream\");\n            function qe(e) {\n                return e._reader !== void 0;\n            }\n            n(qe, \"IsReadableStreamLocked\");\n            function ie(e, t) {\n                if (e._disturbed = !0, e._state === \"closed\") return T(void 0);\n                if (e._state === \"errored\") return b(e._storedError);\n                Pt(e);\n                const r = e._reader;\n                if (r !== void 0 && Fe(r)) {\n                    const f = r._readIntoRequests;\n                    r._readIntoRequests = new D, f.forEach((c)=>{\n                        c._closeSteps(void 0);\n                    });\n                }\n                const s = e._readableStreamController[Ar](t);\n                return F(s, u);\n            }\n            n(ie, \"ReadableStreamCancel\");\n            function Pt(e) {\n                e._state = \"closed\";\n                const t = e._reader;\n                if (t !== void 0 && (Zn(t), Ee(t))) {\n                    const r = t._readRequests;\n                    t._readRequests = new D, r.forEach((s)=>{\n                        s._closeSteps();\n                    });\n                }\n            }\n            n(Pt, \"ReadableStreamClose\");\n            function Zo(e, t) {\n                e._state = \"errored\", e._storedError = t;\n                const r = e._reader;\n                r !== void 0 && (Or(r, t), Ee(r) ? ro(r, t) : Ao(r, t));\n            }\n            n(Zo, \"ReadableStreamError\");\n            function De(e) {\n                return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`);\n            }\n            n(De, \"streamBrandCheckException$1\");\n            function Ko(e, t) {\n                ue(e, t);\n                const r = e?.highWaterMark;\n                return zr(r, \"highWaterMark\", \"QueuingStrategyInit\"), {\n                    highWaterMark: Ir(r)\n                };\n            }\n            n(Ko, \"convertQueuingStrategyInit\");\n            const Jo = n((e)=>e.byteLength, \"byteLengthSizeFunction\");\n            h(Jo, \"size\");\n            const vn = class vn {\n                constructor(t){\n                    Se(t, 1, \"ByteLengthQueuingStrategy\"), t = Ko(t, \"First parameter\"), this._byteLengthQueuingStrategyHighWaterMark = t.highWaterMark;\n                }\n                get highWaterMark() {\n                    if (!ei(this)) throw Xo(\"highWaterMark\");\n                    return this._byteLengthQueuingStrategyHighWaterMark;\n                }\n                get size() {\n                    if (!ei(this)) throw Xo(\"size\");\n                    return Jo;\n                }\n            };\n            n(vn, \"ByteLengthQueuingStrategy\");\n            let Xe = vn;\n            Object.defineProperties(Xe.prototype, {\n                highWaterMark: {\n                    enumerable: !0\n                },\n                size: {\n                    enumerable: !0\n                }\n            }), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(Xe.prototype, Symbol.toStringTag, {\n                value: \"ByteLengthQueuingStrategy\",\n                configurable: !0\n            });\n            function Xo(e) {\n                return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`);\n            }\n            n(Xo, \"byteLengthBrandCheckException\");\n            function ei(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_byteLengthQueuingStrategyHighWaterMark\") ? !1 : e instanceof Xe;\n            }\n            n(ei, \"IsByteLengthQueuingStrategy\");\n            const ti = n(()=>1, \"countSizeFunction\");\n            h(ti, \"size\");\n            const En = class En {\n                constructor(t){\n                    Se(t, 1, \"CountQueuingStrategy\"), t = Ko(t, \"First parameter\"), this._countQueuingStrategyHighWaterMark = t.highWaterMark;\n                }\n                get highWaterMark() {\n                    if (!ni(this)) throw ri(\"highWaterMark\");\n                    return this._countQueuingStrategyHighWaterMark;\n                }\n                get size() {\n                    if (!ni(this)) throw ri(\"size\");\n                    return ti;\n                }\n            };\n            n(En, \"CountQueuingStrategy\");\n            let et = En;\n            Object.defineProperties(et.prototype, {\n                highWaterMark: {\n                    enumerable: !0\n                },\n                size: {\n                    enumerable: !0\n                }\n            }), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(et.prototype, Symbol.toStringTag, {\n                value: \"CountQueuingStrategy\",\n                configurable: !0\n            });\n            function ri(e) {\n                return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`);\n            }\n            n(ri, \"countBrandCheckException\");\n            function ni(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_countQueuingStrategyHighWaterMark\") ? !1 : e instanceof et;\n            }\n            n(ni, \"IsCountQueuingStrategy\");\n            function hs(e, t) {\n                ue(e, t);\n                const r = e?.cancel, s = e?.flush, f = e?.readableType, c = e?.start, d = e?.transform, m = e?.writableType;\n                return {\n                    cancel: r === void 0 ? void 0 : ys(r, e, `${t} has member 'cancel' that`),\n                    flush: s === void 0 ? void 0 : ps(s, e, `${t} has member 'flush' that`),\n                    readableType: f,\n                    start: c === void 0 ? void 0 : bs(c, e, `${t} has member 'start' that`),\n                    transform: d === void 0 ? void 0 : ms(d, e, `${t} has member 'transform' that`),\n                    writableType: m\n                };\n            }\n            n(hs, \"convertTransformer\");\n            function ps(e, t, r) {\n                return Z(e, r), (s)=>j(e, t, [\n                        s\n                    ]);\n            }\n            n(ps, \"convertTransformerFlushCallback\");\n            function bs(e, t, r) {\n                return Z(e, r), (s)=>z(e, t, [\n                        s\n                    ]);\n            }\n            n(bs, \"convertTransformerStartCallback\");\n            function ms(e, t, r) {\n                return Z(e, r), (s, f)=>j(e, t, [\n                        s,\n                        f\n                    ]);\n            }\n            n(ms, \"convertTransformerTransformCallback\");\n            function ys(e, t, r) {\n                return Z(e, r), (s)=>j(e, t, [\n                        s\n                    ]);\n            }\n            n(ys, \"convertTransformerCancelCallback\");\n            const An = class An {\n                constructor(t = {}, r = {}, s = {}){\n                    t === void 0 && (t = null);\n                    const f = Gt(r, \"Second parameter\"), c = Gt(s, \"Third parameter\"), d = hs(t, \"First parameter\");\n                    if (d.readableType !== void 0) throw new RangeError(\"Invalid readableType specified\");\n                    if (d.writableType !== void 0) throw new RangeError(\"Invalid writableType specified\");\n                    const m = St(c, 0), R = Yt(c), y = St(f, 1), C = Yt(f);\n                    let P;\n                    const B = E((ae)=>{\n                        P = ae;\n                    });\n                    gs(this, B, y, C, m, R), Ss(this, d), d.start !== void 0 ? P(d.start(this._transformStreamController)) : P(void 0);\n                }\n                get readable() {\n                    if (!oi(this)) throw li(\"readable\");\n                    return this._readable;\n                }\n                get writable() {\n                    if (!oi(this)) throw li(\"writable\");\n                    return this._writable;\n                }\n            };\n            n(An, \"TransformStream\");\n            let tt = An;\n            Object.defineProperties(tt.prototype, {\n                readable: {\n                    enumerable: !0\n                },\n                writable: {\n                    enumerable: !0\n                }\n            }), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(tt.prototype, Symbol.toStringTag, {\n                value: \"TransformStream\",\n                configurable: !0\n            });\n            function gs(e, t, r, s, f, c) {\n                function d() {\n                    return t;\n                }\n                n(d, \"startAlgorithm\");\n                function m(B) {\n                    return Ts(e, B);\n                }\n                n(m, \"writeAlgorithm\");\n                function R(B) {\n                    return Cs(e, B);\n                }\n                n(R, \"abortAlgorithm\");\n                function y() {\n                    return Ps(e);\n                }\n                n(y, \"closeAlgorithm\"), e._writable = Ra(d, m, y, R, r, s);\n                function C() {\n                    return vs(e);\n                }\n                n(C, \"pullAlgorithm\");\n                function P(B) {\n                    return Es(e, B);\n                }\n                n(P, \"cancelAlgorithm\"), e._readable = Ct(d, C, P, f, c), e._backpressure = void 0, e._backpressureChangePromise = void 0, e._backpressureChangePromise_resolve = void 0, ar(e, !0), e._transformStreamController = void 0;\n            }\n            n(gs, \"InitializeTransformStream\");\n            function oi(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_transformStreamController\") ? !1 : e instanceof tt;\n            }\n            n(oi, \"IsTransformStream\");\n            function ii(e, t) {\n                oe(e._readable._readableStreamController, t), dn(e, t);\n            }\n            n(ii, \"TransformStreamError\");\n            function dn(e, t) {\n                lr(e._transformStreamController), wt(e._writable._writableStreamController, t), hn(e);\n            }\n            n(dn, \"TransformStreamErrorWritableAndUnblockWrite\");\n            function hn(e) {\n                e._backpressure && ar(e, !1);\n            }\n            n(hn, \"TransformStreamUnblockWrite\");\n            function ar(e, t) {\n                e._backpressureChangePromise !== void 0 && e._backpressureChangePromise_resolve(), e._backpressureChangePromise = E((r)=>{\n                    e._backpressureChangePromise_resolve = r;\n                }), e._backpressure = t;\n            }\n            n(ar, \"TransformStreamSetBackpressure\");\n            const Bn = class Bn {\n                constructor(){\n                    throw new TypeError(\"Illegal constructor\");\n                }\n                get desiredSize() {\n                    if (!sr(this)) throw ur(\"desiredSize\");\n                    const t = this._controlledTransformStream._readable._readableStreamController;\n                    return fn(t);\n                }\n                enqueue(t = void 0) {\n                    if (!sr(this)) throw ur(\"enqueue\");\n                    ai(this, t);\n                }\n                error(t = void 0) {\n                    if (!sr(this)) throw ur(\"error\");\n                    ws(this, t);\n                }\n                terminate() {\n                    if (!sr(this)) throw ur(\"terminate\");\n                    Rs(this);\n                }\n            };\n            n(Bn, \"TransformStreamDefaultController\");\n            let pe = Bn;\n            Object.defineProperties(pe.prototype, {\n                enqueue: {\n                    enumerable: !0\n                },\n                error: {\n                    enumerable: !0\n                },\n                terminate: {\n                    enumerable: !0\n                },\n                desiredSize: {\n                    enumerable: !0\n                }\n            }), h(pe.prototype.enqueue, \"enqueue\"), h(pe.prototype.error, \"error\"), h(pe.prototype.terminate, \"terminate\"), typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(pe.prototype, Symbol.toStringTag, {\n                value: \"TransformStreamDefaultController\",\n                configurable: !0\n            });\n            function sr(e) {\n                return !l(e) || !Object.prototype.hasOwnProperty.call(e, \"_controlledTransformStream\") ? !1 : e instanceof pe;\n            }\n            n(sr, \"IsTransformStreamDefaultController\");\n            function _s(e, t, r, s, f) {\n                t._controlledTransformStream = e, e._transformStreamController = t, t._transformAlgorithm = r, t._flushAlgorithm = s, t._cancelAlgorithm = f, t._finishPromise = void 0, t._finishPromise_resolve = void 0, t._finishPromise_reject = void 0;\n            }\n            n(_s, \"SetUpTransformStreamDefaultController\");\n            function Ss(e, t) {\n                const r = Object.create(pe.prototype);\n                let s, f, c;\n                t.transform !== void 0 ? s = n((d)=>t.transform(d, r), \"transformAlgorithm\") : s = n((d)=>{\n                    try {\n                        return ai(r, d), T(void 0);\n                    } catch (m) {\n                        return b(m);\n                    }\n                }, \"transformAlgorithm\"), t.flush !== void 0 ? f = n(()=>t.flush(r), \"flushAlgorithm\") : f = n(()=>T(void 0), \"flushAlgorithm\"), t.cancel !== void 0 ? c = n((d)=>t.cancel(d), \"cancelAlgorithm\") : c = n(()=>T(void 0), \"cancelAlgorithm\"), _s(e, r, s, f, c);\n            }\n            n(Ss, \"SetUpTransformStreamDefaultControllerFromTransformer\");\n            function lr(e) {\n                e._transformAlgorithm = void 0, e._flushAlgorithm = void 0, e._cancelAlgorithm = void 0;\n            }\n            n(lr, \"TransformStreamDefaultControllerClearAlgorithms\");\n            function ai(e, t) {\n                const r = e._controlledTransformStream, s = r._readable._readableStreamController;\n                if (!Je(s)) throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n                try {\n                    Ke(s, t);\n                } catch (c) {\n                    throw dn(r, c), r._readable._storedError;\n                }\n                Za(s) !== r._backpressure && ar(r, !0);\n            }\n            n(ai, \"TransformStreamDefaultControllerEnqueue\");\n            function ws(e, t) {\n                ii(e._controlledTransformStream, t);\n            }\n            n(ws, \"TransformStreamDefaultControllerError\");\n            function si(e, t) {\n                const r = e._transformAlgorithm(t);\n                return F(r, void 0, (s)=>{\n                    throw ii(e._controlledTransformStream, s), s;\n                });\n            }\n            n(si, \"TransformStreamDefaultControllerPerformTransform\");\n            function Rs(e) {\n                const t = e._controlledTransformStream, r = t._readable._readableStreamController;\n                $e(r);\n                const s = new TypeError(\"TransformStream terminated\");\n                dn(t, s);\n            }\n            n(Rs, \"TransformStreamDefaultControllerTerminate\");\n            function Ts(e, t) {\n                const r = e._transformStreamController;\n                if (e._backpressure) {\n                    const s = e._backpressureChangePromise;\n                    return F(s, ()=>{\n                        const f = e._writable;\n                        if (f._state === \"erroring\") throw f._storedError;\n                        return si(r, t);\n                    });\n                }\n                return si(r, t);\n            }\n            n(Ts, \"TransformStreamDefaultSinkWriteAlgorithm\");\n            function Cs(e, t) {\n                const r = e._transformStreamController;\n                if (r._finishPromise !== void 0) return r._finishPromise;\n                const s = e._readable;\n                r._finishPromise = E((c, d)=>{\n                    r._finishPromise_resolve = c, r._finishPromise_reject = d;\n                });\n                const f = r._cancelAlgorithm(t);\n                return lr(r), _(f, ()=>(s._state === \"errored\" ? rt(r, s._storedError) : (oe(s._readableStreamController, t), pn(r)), null), (c)=>(oe(s._readableStreamController, c), rt(r, c), null)), r._finishPromise;\n            }\n            n(Cs, \"TransformStreamDefaultSinkAbortAlgorithm\");\n            function Ps(e) {\n                const t = e._transformStreamController;\n                if (t._finishPromise !== void 0) return t._finishPromise;\n                const r = e._readable;\n                t._finishPromise = E((f, c)=>{\n                    t._finishPromise_resolve = f, t._finishPromise_reject = c;\n                });\n                const s = t._flushAlgorithm();\n                return lr(t), _(s, ()=>(r._state === \"errored\" ? rt(t, r._storedError) : ($e(r._readableStreamController), pn(t)), null), (f)=>(oe(r._readableStreamController, f), rt(t, f), null)), t._finishPromise;\n            }\n            n(Ps, \"TransformStreamDefaultSinkCloseAlgorithm\");\n            function vs(e) {\n                return ar(e, !1), e._backpressureChangePromise;\n            }\n            n(vs, \"TransformStreamDefaultSourcePullAlgorithm\");\n            function Es(e, t) {\n                const r = e._transformStreamController;\n                if (r._finishPromise !== void 0) return r._finishPromise;\n                const s = e._writable;\n                r._finishPromise = E((c, d)=>{\n                    r._finishPromise_resolve = c, r._finishPromise_reject = d;\n                });\n                const f = r._cancelAlgorithm(t);\n                return lr(r), _(f, ()=>(s._state === \"errored\" ? rt(r, s._storedError) : (wt(s._writableStreamController, t), hn(e), pn(r)), null), (c)=>(wt(s._writableStreamController, c), hn(e), rt(r, c), null)), r._finishPromise;\n            }\n            n(Es, \"TransformStreamDefaultSourceCancelAlgorithm\");\n            function ur(e) {\n                return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`);\n            }\n            n(ur, \"defaultControllerBrandCheckException\");\n            function pn(e) {\n                e._finishPromise_resolve !== void 0 && (e._finishPromise_resolve(), e._finishPromise_resolve = void 0, e._finishPromise_reject = void 0);\n            }\n            n(pn, \"defaultControllerFinishPromiseResolve\");\n            function rt(e, t) {\n                e._finishPromise_reject !== void 0 && (Q(e._finishPromise), e._finishPromise_reject(t), e._finishPromise_resolve = void 0, e._finishPromise_reject = void 0);\n            }\n            n(rt, \"defaultControllerFinishPromiseReject\");\n            function li(e) {\n                return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`);\n            }\n            n(li, \"streamBrandCheckException\"), a.ByteLengthQueuingStrategy = Xe, a.CountQueuingStrategy = et, a.ReadableByteStreamController = te, a.ReadableStream = L, a.ReadableStreamBYOBReader = ce, a.ReadableStreamBYOBRequest = Re, a.ReadableStreamDefaultController = ne, a.ReadableStreamDefaultReader = fe, a.TransformStream = tt, a.TransformStreamDefaultController = pe, a.WritableStream = de, a.WritableStreamDefaultController = ke, a.WritableStreamDefaultWriter = re;\n        });\n    }(pr, pr.exports)), pr.exports;\n}\nn(Ls, \"requirePonyfill_es2018\");\nconst $s = 65536;\nif (!globalThis.ReadableStream) try {\n    const i1 = require(\"node:process\"), { emitWarning: o } = i1;\n    try {\n        i1.emitWarning = ()=>{}, Object.assign(globalThis, require(\"node:stream/web\")), i1.emitWarning = o;\n    } catch (a) {\n        throw i1.emitWarning = o, a;\n    }\n} catch  {\n    Object.assign(globalThis, Ls());\n}\ntry {\n    const { Blob: i1 } = require(\"buffer\");\n    i1 && !i1.prototype.stream && (i1.prototype.stream = n(function(a) {\n        let u = 0;\n        const l = this;\n        return new ReadableStream({\n            type: \"bytes\",\n            async pull (p) {\n                const g = await l.slice(u, Math.min(l.size, u + $s)).arrayBuffer();\n                u += g.byteLength, p.enqueue(new Uint8Array(g)), u === l.size && p.close();\n            }\n        });\n    }, \"name\"));\n} catch  {} /*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ \nconst hi = 65536;\nasync function* qn(i1, o = !0) {\n    for (const a of i1)if (\"stream\" in a) yield* a.stream();\n    else if (ArrayBuffer.isView(a)) if (o) {\n        let u = a.byteOffset;\n        const l = a.byteOffset + a.byteLength;\n        for(; u !== l;){\n            const p = Math.min(l - u, hi), h = a.buffer.slice(u, u + p);\n            u += h.byteLength, yield new Uint8Array(h);\n        }\n    } else yield a;\n    else {\n        let u = 0, l = a;\n        for(; u !== l.size;){\n            const h = await l.slice(u, Math.min(l.size, u + hi)).arrayBuffer();\n            u += h.byteLength, yield new Uint8Array(h);\n        }\n    }\n}\nn(qn, \"toIterator\");\nconst pi = (Ve = class {\n    constructor(o = [], a = {}){\n        be(this, ve, []);\n        be(this, kt, \"\");\n        be(this, bt, 0);\n        be(this, Cr, \"transparent\");\n        if (typeof o != \"object\" || o === null) throw new TypeError(\"Failed to construct 'Blob': The provided value cannot be converted to a sequence.\");\n        if (typeof o[Symbol.iterator] != \"function\") throw new TypeError(\"Failed to construct 'Blob': The object must have a callable @@iterator property.\");\n        if (typeof a != \"object\" && typeof a != \"function\") throw new TypeError(\"Failed to construct 'Blob': parameter 2 cannot convert to dictionary.\");\n        a === null && (a = {});\n        const u = new TextEncoder;\n        for (const p of o){\n            let h;\n            ArrayBuffer.isView(p) ? h = new Uint8Array(p.buffer.slice(p.byteOffset, p.byteOffset + p.byteLength)) : p instanceof ArrayBuffer ? h = new Uint8Array(p.slice(0)) : p instanceof Ve ? h = p : h = u.encode(`${p}`), X(this, bt, O(this, bt) + (ArrayBuffer.isView(h) ? h.byteLength : h.size)), O(this, ve).push(h);\n        }\n        X(this, Cr, `${a.endings === void 0 ? \"transparent\" : a.endings}`);\n        const l = a.type === void 0 ? \"\" : String(a.type);\n        X(this, kt, /^[\\x20-\\x7E]*$/.test(l) ? l : \"\");\n    }\n    get size() {\n        return O(this, bt);\n    }\n    get type() {\n        return O(this, kt);\n    }\n    async text() {\n        const o = new TextDecoder;\n        let a = \"\";\n        for await (const u of qn(O(this, ve), !1))a += o.decode(u, {\n            stream: !0\n        });\n        return a += o.decode(), a;\n    }\n    async arrayBuffer() {\n        const o = new Uint8Array(this.size);\n        let a = 0;\n        for await (const u of qn(O(this, ve), !1))o.set(u, a), a += u.length;\n        return o.buffer;\n    }\n    stream() {\n        const o = qn(O(this, ve), !0);\n        return new globalThis.ReadableStream({\n            type: \"bytes\",\n            async pull (a) {\n                const u = await o.next();\n                u.done ? a.close() : a.enqueue(u.value);\n            },\n            async cancel () {\n                await o.return();\n            }\n        });\n    }\n    slice(o = 0, a = this.size, u = \"\") {\n        const { size: l } = this;\n        let p = o < 0 ? Math.max(l + o, 0) : Math.min(o, l), h = a < 0 ? Math.max(l + a, 0) : Math.min(a, l);\n        const g = Math.max(h - p, 0), A = O(this, ve), w = [];\n        let E = 0;\n        for (const b of A){\n            if (E >= g) break;\n            const q = ArrayBuffer.isView(b) ? b.byteLength : b.size;\n            if (p && q <= p) p -= q, h -= q;\n            else {\n                let _;\n                ArrayBuffer.isView(b) ? (_ = b.subarray(p, Math.min(q, h)), E += _.byteLength) : (_ = b.slice(p, Math.min(q, h)), E += _.size), h -= q, w.push(_), p = 0;\n            }\n        }\n        const T = new Ve([], {\n            type: String(u).toLowerCase()\n        });\n        return X(T, bt, g), X(T, ve, w), T;\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n    static [Symbol.hasInstance](o) {\n        return o && typeof o == \"object\" && typeof o.constructor == \"function\" && (typeof o.stream == \"function\" || typeof o.arrayBuffer == \"function\") && /^(Blob|File)$/.test(o[Symbol.toStringTag]);\n    }\n}, ve = new WeakMap, kt = new WeakMap, bt = new WeakMap, Cr = new WeakMap, n(Ve, \"Blob\"), Ve);\nObject.defineProperties(pi.prototype, {\n    size: {\n        enumerable: !0\n    },\n    type: {\n        enumerable: !0\n    },\n    slice: {\n        enumerable: !0\n    }\n});\nconst Ds = pi, ut = Ds, Ms = (Ot = class extends ut {\n    constructor(a, u, l = {}){\n        if (arguments.length < 2) throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);\n        super(a, l);\n        be(this, Wt, 0);\n        be(this, qt, \"\");\n        l === null && (l = {});\n        const p = l.lastModified === void 0 ? Date.now() : Number(l.lastModified);\n        Number.isNaN(p) || X(this, Wt, p), X(this, qt, String(u));\n    }\n    get name() {\n        return O(this, qt);\n    }\n    get lastModified() {\n        return O(this, Wt);\n    }\n    get [Symbol.toStringTag]() {\n        return \"File\";\n    }\n    static [Symbol.hasInstance](a) {\n        return !!a && a instanceof ut && /^(File)$/.test(a[Symbol.toStringTag]);\n    }\n}, Wt = new WeakMap, qt = new WeakMap, n(Ot, \"File\"), Ot), Us = Ms, On = Us; /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ \nvar { toStringTag: Et, iterator: xs, hasInstance: Ns } = Symbol, bi = Math.random, Hs = \"append,set,get,getAll,delete,keys,values,entries,forEach,constructor\".split(\",\"), mi = n((i1, o, a)=>(i1 += \"\", /^(Blob|File)$/.test(o && o[Et]) ? [\n        (a = a !== void 0 ? a + \"\" : o[Et] == \"File\" ? o.name : \"blob\", i1),\n        o.name !== a || o[Et] == \"blob\" ? new On([\n            o\n        ], a, o) : o\n    ] : [\n        i1,\n        o + \"\"\n    ]), \"f\"), zn = n((i1, o)=>(o ? i1 : i1.replace(/\\r?\\n|\\r/g, `\\r\n`)).replace(/\\n/g, \"%0A\").replace(/\\r/g, \"%0D\").replace(/\"/g, \"%22\"), \"e$1\"), Me = n((i1, o, a)=>{\n    if (o.length < a) throw new TypeError(`Failed to execute '${i1}' on 'FormData': ${a} arguments required, but only ${o.length} present.`);\n}, \"x\");\nconst br = (zt = class {\n    constructor(...o){\n        be(this, ee, []);\n        if (o.length) throw new TypeError(\"Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.\");\n    }\n    get [Et]() {\n        return \"FormData\";\n    }\n    [xs]() {\n        return this.entries();\n    }\n    static [Ns](o) {\n        return o && typeof o == \"object\" && o[Et] === \"FormData\" && !Hs.some((a)=>typeof o[a] != \"function\");\n    }\n    append(...o) {\n        Me(\"append\", arguments, 2), O(this, ee).push(mi(...o));\n    }\n    delete(o) {\n        Me(\"delete\", arguments, 1), o += \"\", X(this, ee, O(this, ee).filter(([a])=>a !== o));\n    }\n    get(o) {\n        Me(\"get\", arguments, 1), o += \"\";\n        for(var a = O(this, ee), u = a.length, l = 0; l < u; l++)if (a[l][0] === o) return a[l][1];\n        return null;\n    }\n    getAll(o, a) {\n        return Me(\"getAll\", arguments, 1), a = [], o += \"\", O(this, ee).forEach((u)=>u[0] === o && a.push(u[1])), a;\n    }\n    has(o) {\n        return Me(\"has\", arguments, 1), o += \"\", O(this, ee).some((a)=>a[0] === o);\n    }\n    forEach(o, a) {\n        Me(\"forEach\", arguments, 1);\n        for (var [u, l] of this)o.call(a, l, u, this);\n    }\n    set(...o) {\n        Me(\"set\", arguments, 2);\n        var a = [], u = !0;\n        o = mi(...o), O(this, ee).forEach((l)=>{\n            l[0] === o[0] ? u && (u = !a.push(o)) : a.push(l);\n        }), u && a.push(o), X(this, ee, a);\n    }\n    *entries() {\n        yield* O(this, ee);\n    }\n    *keys() {\n        for (var [o] of this)yield o;\n    }\n    *values() {\n        for (var [, o] of this)yield o;\n    }\n}, ee = new WeakMap, n(zt, \"FormData\"), zt);\nfunction Vs(i1, o = ut) {\n    var a = `${bi()}${bi()}`.replace(/\\./g, \"\").slice(-28).padStart(32, \"-\"), u = [], l = `--${a}\\r\nContent-Disposition: form-data; name=\"`;\n    return i1.forEach((p, h)=>typeof p == \"string\" ? u.push(l + zn(h) + `\"\\r\n\\r\n${p.replace(/\\r(?!\\n)|(?<!\\r)\\n/g, `\\r\n`)}\\r\n`) : u.push(l + zn(h) + `\"; filename=\"${zn(p.name, 1)}\"\\r\nContent-Type: ${p.type || \"application/octet-stream\"}\\r\n\\r\n`, p, `\\r\n`)), u.push(`--${a}--`), new o(u, {\n        type: \"multipart/form-data; boundary=\" + a\n    });\n}\nn(Vs, \"formDataToBlob\");\nconst Un = class Un extends Error {\n    constructor(o, a){\n        super(o), Error.captureStackTrace(this, this.constructor), this.type = a;\n    }\n    get name() {\n        return this.constructor.name;\n    }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n};\nn(Un, \"FetchBaseError\");\nlet ft = Un;\nconst xn = class xn extends ft {\n    constructor(o, a, u){\n        super(o, a), u && (this.code = this.errno = u.code, this.erroredSysCall = u.syscall);\n    }\n};\nn(xn, \"FetchError\");\nlet G = xn;\nconst mr = Symbol.toStringTag, yi = n((i1)=>typeof i1 == \"object\" && typeof i1.append == \"function\" && typeof i1.delete == \"function\" && typeof i1.get == \"function\" && typeof i1.getAll == \"function\" && typeof i1.has == \"function\" && typeof i1.set == \"function\" && typeof i1.sort == \"function\" && i1[mr] === \"URLSearchParams\", \"isURLSearchParameters\"), yr = n((i1)=>i1 && typeof i1 == \"object\" && typeof i1.arrayBuffer == \"function\" && typeof i1.type == \"string\" && typeof i1.stream == \"function\" && typeof i1.constructor == \"function\" && /^(Blob|File)$/.test(i1[mr]), \"isBlob\"), Qs = n((i1)=>typeof i1 == \"object\" && (i1[mr] === \"AbortSignal\" || i1[mr] === \"EventTarget\"), \"isAbortSignal\"), Ys = n((i1, o)=>{\n    const a = new URL(o).hostname, u = new URL(i1).hostname;\n    return a === u || a.endsWith(`.${u}`);\n}, \"isDomainOrSubdomain\"), Gs = n((i1, o)=>{\n    const a = new URL(o).protocol, u = new URL(i1).protocol;\n    return a === u;\n}, \"isSameProtocol\"), Zs = (0,node_util__WEBPACK_IMPORTED_MODULE_5__.promisify)(node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline), H = Symbol(\"Body internals\"), Nn = class Nn {\n    constructor(o, { size: a = 0 } = {}){\n        let u = null;\n        o === null ? o = null : yi(o) ? o = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from(o.toString()) : yr(o) || node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.isBuffer(o) || (node_util__WEBPACK_IMPORTED_MODULE_5__.types.isAnyArrayBuffer(o) ? o = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from(o) : ArrayBuffer.isView(o) ? o = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from(o.buffer, o.byteOffset, o.byteLength) : o instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__ || (o instanceof br ? (o = Vs(o), u = o.type.split(\"=\")[1]) : o = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from(String(o))));\n        let l = o;\n        node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.isBuffer(o) ? l = node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable.from(o) : yr(o) && (l = node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable.from(o.stream())), this[H] = {\n            body: o,\n            stream: l,\n            boundary: u,\n            disturbed: !1,\n            error: null\n        }, this.size = a, o instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__ && o.on(\"error\", (p)=>{\n            const h = p instanceof ft ? p : new G(`Invalid response body while trying to fetch ${this.url}: ${p.message}`, \"system\", p);\n            this[H].error = h;\n        });\n    }\n    get body() {\n        return this[H].stream;\n    }\n    get bodyUsed() {\n        return this[H].disturbed;\n    }\n    async arrayBuffer() {\n        const { buffer: o, byteOffset: a, byteLength: u } = await In(this);\n        return o.slice(a, a + u);\n    }\n    async formData() {\n        const o = this.headers.get(\"content-type\");\n        if (o.startsWith(\"application/x-www-form-urlencoded\")) {\n            const u = new br, l = new URLSearchParams(await this.text());\n            for (const [p, h] of l)u.append(p, h);\n            return u;\n        }\n        const { toFormData: a } = await __webpack_require__.e(/*! import() */ \"vendor-chunks/node-fetch-native\").then(__webpack_require__.bind(__webpack_require__, /*! ./chunks/multipart-parser.mjs */ \"(ssr)/./node_modules/node-fetch-native/dist/chunks/multipart-parser.mjs\"));\n        return a(this.body, o);\n    }\n    async blob() {\n        const o = this.headers && this.headers.get(\"content-type\") || this[H].body && this[H].body.type || \"\", a = await this.arrayBuffer();\n        return new ut([\n            a\n        ], {\n            type: o\n        });\n    }\n    async json() {\n        const o = await this.text();\n        return JSON.parse(o);\n    }\n    async text() {\n        const o = await In(this);\n        return new TextDecoder().decode(o);\n    }\n    buffer() {\n        return In(this);\n    }\n};\nn(Nn, \"Body\");\nlet Ue = Nn;\nUe.prototype.buffer = (0,node_util__WEBPACK_IMPORTED_MODULE_5__.deprecate)(Ue.prototype.buffer, \"Please use 'response.arrayBuffer()' instead of 'response.buffer()'\", \"node-fetch#buffer\"), Object.defineProperties(Ue.prototype, {\n    body: {\n        enumerable: !0\n    },\n    bodyUsed: {\n        enumerable: !0\n    },\n    arrayBuffer: {\n        enumerable: !0\n    },\n    blob: {\n        enumerable: !0\n    },\n    json: {\n        enumerable: !0\n    },\n    text: {\n        enumerable: !0\n    },\n    data: {\n        get: (0,node_util__WEBPACK_IMPORTED_MODULE_5__.deprecate)(()=>{}, \"data doesn't exist, use json(), text(), arrayBuffer(), or body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (response)\")\n    }\n});\nasync function In(i1) {\n    if (i1[H].disturbed) throw new TypeError(`body used already for: ${i1.url}`);\n    if (i1[H].disturbed = !0, i1[H].error) throw i1[H].error;\n    const { body: o } = i1;\n    if (o === null) return node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.alloc(0);\n    if (!(o instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__)) return node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.alloc(0);\n    const a = [];\n    let u = 0;\n    try {\n        for await (const l of o){\n            if (i1.size > 0 && u + l.length > i1.size) {\n                const p = new G(`content size at ${i1.url} over limit: ${i1.size}`, \"max-size\");\n                throw o.destroy(p), p;\n            }\n            u += l.length, a.push(l);\n        }\n    } catch (l) {\n        throw l instanceof ft ? l : new G(`Invalid response body while trying to fetch ${i1.url}: ${l.message}`, \"system\", l);\n    }\n    if (o.readableEnded === !0 || o._readableState.ended === !0) try {\n        return a.every((l)=>typeof l == \"string\") ? node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from(a.join(\"\")) : node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.concat(a, u);\n    } catch (l) {\n        throw new G(`Could not create Buffer from response body for ${i1.url}: ${l.message}`, \"system\", l);\n    }\n    else throw new G(`Premature close of server response while trying to fetch ${i1.url}`);\n}\nn(In, \"consumeBody\");\nconst Fn = n((i1, o)=>{\n    let a, u, { body: l } = i1[H];\n    if (i1.bodyUsed) throw new Error(\"cannot clone body after it is used\");\n    return l instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__ && typeof l.getBoundary != \"function\" && (a = new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough({\n        highWaterMark: o\n    }), u = new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough({\n        highWaterMark: o\n    }), l.pipe(a), l.pipe(u), i1[H].stream = a, l = u), l;\n}, \"clone\"), Ks = (0,node_util__WEBPACK_IMPORTED_MODULE_5__.deprecate)((i1)=>i1.getBoundary(), \"form-data doesn't follow the spec and requires special treatment. Use alternative package\", \"https://github.com/node-fetch/node-fetch/issues/1167\"), gi = n((i1, o)=>i1 === null ? null : typeof i1 == \"string\" ? \"text/plain;charset=UTF-8\" : yi(i1) ? \"application/x-www-form-urlencoded;charset=UTF-8\" : yr(i1) ? i1.type || null : node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.isBuffer(i1) || node_util__WEBPACK_IMPORTED_MODULE_5__.types.isAnyArrayBuffer(i1) || ArrayBuffer.isView(i1) ? null : i1 instanceof br ? `multipart/form-data; boundary=${o[H].boundary}` : i1 && typeof i1.getBoundary == \"function\" ? `multipart/form-data;boundary=${Ks(i1)}` : i1 instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__ ? null : \"text/plain;charset=UTF-8\", \"extractContentType\"), Js = n((i1)=>{\n    const { body: o } = i1[H];\n    return o === null ? 0 : yr(o) ? o.size : node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.isBuffer(o) ? o.length : o && typeof o.getLengthSync == \"function\" && o.hasKnownLength && o.hasKnownLength() ? o.getLengthSync() : null;\n}, \"getTotalBytes\"), Xs = n(async (i1, { body: o })=>{\n    o === null ? i1.end() : await Zs(o, i1);\n}, \"writeToStream\"), gr = typeof node_http__WEBPACK_IMPORTED_MODULE_0__.validateHeaderName == \"function\" ? node_http__WEBPACK_IMPORTED_MODULE_0__.validateHeaderName : (i1)=>{\n    if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(i1)) {\n        const o = new TypeError(`Header name must be a valid HTTP token [${i1}]`);\n        throw Object.defineProperty(o, \"code\", {\n            value: \"ERR_INVALID_HTTP_TOKEN\"\n        }), o;\n    }\n}, jn = typeof node_http__WEBPACK_IMPORTED_MODULE_0__.validateHeaderValue == \"function\" ? node_http__WEBPACK_IMPORTED_MODULE_0__.validateHeaderValue : (i1, o)=>{\n    if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(o)) {\n        const a = new TypeError(`Invalid character in header content [\"${i1}\"]`);\n        throw Object.defineProperty(a, \"code\", {\n            value: \"ERR_INVALID_CHAR\"\n        }), a;\n    }\n}, Pr = class Pr extends URLSearchParams {\n    constructor(o){\n        let a = [];\n        if (o instanceof Pr) {\n            const u = o.raw();\n            for (const [l, p] of Object.entries(u))a.push(...p.map((h)=>[\n                    l,\n                    h\n                ]));\n        } else if (o != null) if (typeof o == \"object\" && !node_util__WEBPACK_IMPORTED_MODULE_5__.types.isBoxedPrimitive(o)) {\n            const u = o[Symbol.iterator];\n            if (u == null) a.push(...Object.entries(o));\n            else {\n                if (typeof u != \"function\") throw new TypeError(\"Header pairs must be iterable\");\n                a = [\n                    ...o\n                ].map((l)=>{\n                    if (typeof l != \"object\" || node_util__WEBPACK_IMPORTED_MODULE_5__.types.isBoxedPrimitive(l)) throw new TypeError(\"Each header pair must be an iterable object\");\n                    return [\n                        ...l\n                    ];\n                }).map((l)=>{\n                    if (l.length !== 2) throw new TypeError(\"Each header pair must be a name/value tuple\");\n                    return [\n                        ...l\n                    ];\n                });\n            }\n        } else throw new TypeError(\"Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)\");\n        return a = a.length > 0 ? a.map(([u, l])=>(gr(u), jn(u, String(l)), [\n                String(u).toLowerCase(),\n                String(l)\n            ])) : void 0, super(a), new Proxy(this, {\n            get (u, l, p) {\n                switch(l){\n                    case \"append\":\n                    case \"set\":\n                        return (h, g)=>(gr(h), jn(h, String(g)), URLSearchParams.prototype[l].call(u, String(h).toLowerCase(), String(g)));\n                    case \"delete\":\n                    case \"has\":\n                    case \"getAll\":\n                        return (h)=>(gr(h), URLSearchParams.prototype[l].call(u, String(h).toLowerCase()));\n                    case \"keys\":\n                        return ()=>(u.sort(), new Set(URLSearchParams.prototype.keys.call(u)).keys());\n                    default:\n                        return Reflect.get(u, l, p);\n                }\n            }\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return this.constructor.name;\n    }\n    toString() {\n        return Object.prototype.toString.call(this);\n    }\n    get(o) {\n        const a = this.getAll(o);\n        if (a.length === 0) return null;\n        let u = a.join(\", \");\n        return /^content-encoding$/i.test(o) && (u = u.toLowerCase()), u;\n    }\n    forEach(o, a = void 0) {\n        for (const u of this.keys())Reflect.apply(o, a, [\n            this.get(u),\n            u,\n            this\n        ]);\n    }\n    *values() {\n        for (const o of this.keys())yield this.get(o);\n    }\n    *entries() {\n        for (const o of this.keys())yield [\n            o,\n            this.get(o)\n        ];\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    raw() {\n        return [\n            ...this.keys()\n        ].reduce((o, a)=>(o[a] = this.getAll(a), o), {});\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n        return [\n            ...this.keys()\n        ].reduce((o, a)=>{\n            const u = this.getAll(a);\n            return a === \"host\" ? o[a] = u[0] : o[a] = u.length > 1 ? u : u[0], o;\n        }, {});\n    }\n};\nn(Pr, \"Headers\");\nlet ye = Pr;\nObject.defineProperties(ye.prototype, [\n    \"get\",\n    \"entries\",\n    \"forEach\",\n    \"values\"\n].reduce((i1, o)=>(i1[o] = {\n        enumerable: !0\n    }, i1), {}));\nfunction el(i1 = []) {\n    return new ye(i1.reduce((o, a, u, l)=>(u % 2 === 0 && o.push(l.slice(u, u + 2)), o), []).filter(([o, a])=>{\n        try {\n            return gr(o), jn(o, String(a)), !0;\n        } catch  {\n            return !1;\n        }\n    }));\n}\nn(el, \"fromRawHeaders\");\nconst tl = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]), Ln = n((i1)=>tl.has(i1), \"isRedirect\"), se = Symbol(\"Response internals\"), xe = class xe extends Ue {\n    constructor(o = null, a = {}){\n        super(o, a);\n        const u = a.status != null ? a.status : 200, l = new ye(a.headers);\n        if (o !== null && !l.has(\"Content-Type\")) {\n            const p = gi(o, this);\n            p && l.append(\"Content-Type\", p);\n        }\n        this[se] = {\n            type: \"default\",\n            url: a.url,\n            status: u,\n            statusText: a.statusText || \"\",\n            headers: l,\n            counter: a.counter,\n            highWaterMark: a.highWaterMark\n        };\n    }\n    get type() {\n        return this[se].type;\n    }\n    get url() {\n        return this[se].url || \"\";\n    }\n    get status() {\n        return this[se].status;\n    }\n    get ok() {\n        return this[se].status >= 200 && this[se].status < 300;\n    }\n    get redirected() {\n        return this[se].counter > 0;\n    }\n    get statusText() {\n        return this[se].statusText;\n    }\n    get headers() {\n        return this[se].headers;\n    }\n    get highWaterMark() {\n        return this[se].highWaterMark;\n    }\n    clone() {\n        return new xe(Fn(this, this.highWaterMark), {\n            type: this.type,\n            url: this.url,\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            ok: this.ok,\n            redirected: this.redirected,\n            size: this.size,\n            highWaterMark: this.highWaterMark\n        });\n    }\n    static redirect(o, a = 302) {\n        if (!Ln(a)) throw new RangeError('Failed to execute \"redirect\" on \"response\": Invalid status code');\n        return new xe(null, {\n            headers: {\n                location: new URL(o).toString()\n            },\n            status: a\n        });\n    }\n    static error() {\n        const o = new xe(null, {\n            status: 0,\n            statusText: \"\"\n        });\n        return o[se].type = \"error\", o;\n    }\n    static json(o = void 0, a = {}) {\n        const u = JSON.stringify(o);\n        if (u === void 0) throw new TypeError(\"data is not JSON serializable\");\n        const l = new ye(a && a.headers);\n        return l.has(\"content-type\") || l.set(\"content-type\", \"application/json\"), new xe(u, {\n            ...a,\n            headers: l\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Response\";\n    }\n};\nn(xe, \"Response\");\nlet le = xe;\nObject.defineProperties(le.prototype, {\n    type: {\n        enumerable: !0\n    },\n    url: {\n        enumerable: !0\n    },\n    status: {\n        enumerable: !0\n    },\n    ok: {\n        enumerable: !0\n    },\n    redirected: {\n        enumerable: !0\n    },\n    statusText: {\n        enumerable: !0\n    },\n    headers: {\n        enumerable: !0\n    },\n    clone: {\n        enumerable: !0\n    }\n});\nconst rl = n((i1)=>{\n    if (i1.search) return i1.search;\n    const o = i1.href.length - 1, a = i1.hash || (i1.href[o] === \"#\" ? \"#\" : \"\");\n    return i1.href[o - a.length] === \"?\" ? \"?\" : \"\";\n}, \"getSearch\");\nfunction _i(i1, o = !1) {\n    return i1 == null || (i1 = new URL(i1), /^(about|blob|data):$/.test(i1.protocol)) ? \"no-referrer\" : (i1.username = \"\", i1.password = \"\", i1.hash = \"\", o && (i1.pathname = \"\", i1.search = \"\"), i1);\n}\nn(_i, \"stripURLForUseAsAReferrer\");\nconst Si = new Set([\n    \"\",\n    \"no-referrer\",\n    \"no-referrer-when-downgrade\",\n    \"same-origin\",\n    \"origin\",\n    \"strict-origin\",\n    \"origin-when-cross-origin\",\n    \"strict-origin-when-cross-origin\",\n    \"unsafe-url\"\n]), nl = \"strict-origin-when-cross-origin\";\nfunction ol(i1) {\n    if (!Si.has(i1)) throw new TypeError(`Invalid referrerPolicy: ${i1}`);\n    return i1;\n}\nn(ol, \"validateReferrerPolicy\");\nfunction il(i1) {\n    if (/^(http|ws)s:$/.test(i1.protocol)) return !0;\n    const o = i1.host.replace(/(^\\[)|(]$)/g, \"\"), a = (0,node_net__WEBPACK_IMPORTED_MODULE_8__.isIP)(o);\n    return a === 4 && /^127\\./.test(o) || a === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(o) ? !0 : i1.host === \"localhost\" || i1.host.endsWith(\".localhost\") ? !1 : i1.protocol === \"file:\";\n}\nn(il, \"isOriginPotentiallyTrustworthy\");\nfunction ct(i1) {\n    return /^about:(blank|srcdoc)$/.test(i1) || i1.protocol === \"data:\" || /^(blob|filesystem):$/.test(i1.protocol) ? !0 : il(i1);\n}\nn(ct, \"isUrlPotentiallyTrustworthy\");\nfunction al(i1, { referrerURLCallback: o, referrerOriginCallback: a } = {}) {\n    if (i1.referrer === \"no-referrer\" || i1.referrerPolicy === \"\") return null;\n    const u = i1.referrerPolicy;\n    if (i1.referrer === \"about:client\") return \"no-referrer\";\n    const l = i1.referrer;\n    let p = _i(l), h = _i(l, !0);\n    p.toString().length > 4096 && (p = h), o && (p = o(p)), a && (h = a(h));\n    const g = new URL(i1.url);\n    switch(u){\n        case \"no-referrer\":\n            return \"no-referrer\";\n        case \"origin\":\n            return h;\n        case \"unsafe-url\":\n            return p;\n        case \"strict-origin\":\n            return ct(p) && !ct(g) ? \"no-referrer\" : h.toString();\n        case \"strict-origin-when-cross-origin\":\n            return p.origin === g.origin ? p : ct(p) && !ct(g) ? \"no-referrer\" : h;\n        case \"same-origin\":\n            return p.origin === g.origin ? p : \"no-referrer\";\n        case \"origin-when-cross-origin\":\n            return p.origin === g.origin ? p : h;\n        case \"no-referrer-when-downgrade\":\n            return ct(p) && !ct(g) ? \"no-referrer\" : p;\n        default:\n            throw new TypeError(`Invalid referrerPolicy: ${u}`);\n    }\n}\nn(al, \"determineRequestsReferrer\");\nfunction sl(i1) {\n    const o = (i1.get(\"referrer-policy\") || \"\").split(/[,\\s]+/);\n    let a = \"\";\n    for (const u of o)u && Si.has(u) && (a = u);\n    return a;\n}\nn(sl, \"parseReferrerPolicyFromHeader\");\nconst $ = Symbol(\"Request internals\"), At = n((i1)=>typeof i1 == \"object\" && typeof i1[$] == \"object\", \"isRequest\"), ll = (0,node_util__WEBPACK_IMPORTED_MODULE_5__.deprecate)(()=>{}, \".data is not a valid RequestInit property, use .body instead\", \"https://github.com/node-fetch/node-fetch/issues/1000 (request)\"), vr = class vr extends Ue {\n    constructor(o, a = {}){\n        let u;\n        if (At(o) ? u = new URL(o.url) : (u = new URL(o), o = {}), u.username !== \"\" || u.password !== \"\") throw new TypeError(`${u} is an url with embedded credentials.`);\n        let l = a.method || o.method || \"GET\";\n        if (/^(delete|get|head|options|post|put)$/i.test(l) && (l = l.toUpperCase()), !At(a) && \"data\" in a && ll(), (a.body != null || At(o) && o.body !== null) && (l === \"GET\" || l === \"HEAD\")) throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        const p = a.body ? a.body : At(o) && o.body !== null ? Fn(o) : null;\n        super(p, {\n            size: a.size || o.size || 0\n        });\n        const h = new ye(a.headers || o.headers || {});\n        if (p !== null && !h.has(\"Content-Type\")) {\n            const w = gi(p, this);\n            w && h.set(\"Content-Type\", w);\n        }\n        let g = At(o) ? o.signal : null;\n        if (\"signal\" in a && (g = a.signal), g != null && !Qs(g)) throw new TypeError(\"Expected signal to be an instanceof AbortSignal or EventTarget\");\n        let A = a.referrer == null ? o.referrer : a.referrer;\n        if (A === \"\") A = \"no-referrer\";\n        else if (A) {\n            const w = new URL(A);\n            A = /^about:(\\/\\/)?client$/.test(w) ? \"client\" : w;\n        } else A = void 0;\n        this[$] = {\n            method: l,\n            redirect: a.redirect || o.redirect || \"follow\",\n            headers: h,\n            parsedURL: u,\n            signal: g,\n            referrer: A\n        }, this.follow = a.follow === void 0 ? o.follow === void 0 ? 20 : o.follow : a.follow, this.compress = a.compress === void 0 ? o.compress === void 0 ? !0 : o.compress : a.compress, this.counter = a.counter || o.counter || 0, this.agent = a.agent || o.agent, this.highWaterMark = a.highWaterMark || o.highWaterMark || 16384, this.insecureHTTPParser = a.insecureHTTPParser || o.insecureHTTPParser || !1, this.referrerPolicy = a.referrerPolicy || o.referrerPolicy || \"\";\n    }\n    get method() {\n        return this[$].method;\n    }\n    get url() {\n        return (0,node_url__WEBPACK_IMPORTED_MODULE_7__.format)(this[$].parsedURL);\n    }\n    get headers() {\n        return this[$].headers;\n    }\n    get redirect() {\n        return this[$].redirect;\n    }\n    get signal() {\n        return this[$].signal;\n    }\n    get referrer() {\n        if (this[$].referrer === \"no-referrer\") return \"\";\n        if (this[$].referrer === \"client\") return \"about:client\";\n        if (this[$].referrer) return this[$].referrer.toString();\n    }\n    get referrerPolicy() {\n        return this[$].referrerPolicy;\n    }\n    set referrerPolicy(o) {\n        this[$].referrerPolicy = ol(o);\n    }\n    clone() {\n        return new vr(this);\n    }\n    get [Symbol.toStringTag]() {\n        return \"Request\";\n    }\n};\nn(vr, \"Request\");\nlet dt = vr;\nObject.defineProperties(dt.prototype, {\n    method: {\n        enumerable: !0\n    },\n    url: {\n        enumerable: !0\n    },\n    headers: {\n        enumerable: !0\n    },\n    redirect: {\n        enumerable: !0\n    },\n    clone: {\n        enumerable: !0\n    },\n    signal: {\n        enumerable: !0\n    },\n    referrer: {\n        enumerable: !0\n    },\n    referrerPolicy: {\n        enumerable: !0\n    }\n});\nconst ul = n((i1)=>{\n    const { parsedURL: o } = i1[$], a = new ye(i1[$].headers);\n    a.has(\"Accept\") || a.set(\"Accept\", \"*/*\");\n    let u = null;\n    if (i1.body === null && /^(post|put)$/i.test(i1.method) && (u = \"0\"), i1.body !== null) {\n        const g = Js(i1);\n        typeof g == \"number\" && !Number.isNaN(g) && (u = String(g));\n    }\n    u && a.set(\"Content-Length\", u), i1.referrerPolicy === \"\" && (i1.referrerPolicy = nl), i1.referrer && i1.referrer !== \"no-referrer\" ? i1[$].referrer = al(i1) : i1[$].referrer = \"no-referrer\", i1[$].referrer instanceof URL && a.set(\"Referer\", i1.referrer), a.has(\"User-Agent\") || a.set(\"User-Agent\", \"node-fetch\"), i1.compress && !a.has(\"Accept-Encoding\") && a.set(\"Accept-Encoding\", \"gzip, deflate, br\");\n    let { agent: l } = i1;\n    typeof l == \"function\" && (l = l(o));\n    const p = rl(o), h = {\n        path: o.pathname + p,\n        method: i1.method,\n        headers: a[Symbol.for(\"nodejs.util.inspect.custom\")](),\n        insecureHTTPParser: i1.insecureHTTPParser,\n        agent: l\n    };\n    return {\n        parsedURL: o,\n        options: h\n    };\n}, \"getNodeRequestOptions\"), Hn = class Hn extends ft {\n    constructor(o, a = \"aborted\"){\n        super(o, a);\n    }\n};\nn(Hn, \"AbortError\");\nlet _r = Hn; /*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ \nif (!globalThis.DOMException) try {\n    const { MessageChannel: i1 } = require(\"worker_threads\"), o = new i1().port1, a = new ArrayBuffer;\n    o.postMessage(a, [\n        a,\n        a\n    ]);\n} catch (i1) {\n    i1.constructor.name === \"DOMException\" && (globalThis.DOMException = i1.constructor);\n}\nvar fl = globalThis.DOMException;\nconst cl = (0,_shared_node_fetch_native_1a4a356d_mjs__WEBPACK_IMPORTED_MODULE_6__.g)(fl), { stat: $n } = node_fs__WEBPACK_IMPORTED_MODULE_9__.promises, dl = n((i1, o)=>wi((0,node_fs__WEBPACK_IMPORTED_MODULE_9__.statSync)(i1), i1, o), \"blobFromSync\"), hl = n((i1, o)=>$n(i1).then((a)=>wi(a, i1, o)), \"blobFrom\"), pl = n((i1, o)=>$n(i1).then((a)=>Ri(a, i1, o)), \"fileFrom\"), bl = n((i1, o)=>Ri((0,node_fs__WEBPACK_IMPORTED_MODULE_9__.statSync)(i1), i1, o), \"fileFromSync\"), wi = n((i1, o, a = \"\")=>new ut([\n        new Sr({\n            path: o,\n            size: i1.size,\n            lastModified: i1.mtimeMs,\n            start: 0\n        })\n    ], {\n        type: a\n    }), \"fromBlob\"), Ri = n((i1, o, a = \"\")=>new On([\n        new Sr({\n            path: o,\n            size: i1.size,\n            lastModified: i1.mtimeMs,\n            start: 0\n        })\n    ], (0,node_path__WEBPACK_IMPORTED_MODULE_10__.basename)(o), {\n        type: a,\n        lastModified: i1.mtimeMs\n    }), \"fromFile\"), Er = class Er {\n    constructor(o){\n        be(this, Ne, void 0);\n        be(this, He, void 0);\n        X(this, Ne, o.path), X(this, He, o.start), this.size = o.size, this.lastModified = o.lastModified;\n    }\n    slice(o, a) {\n        return new Er({\n            path: O(this, Ne),\n            lastModified: this.lastModified,\n            size: a - o,\n            start: O(this, He) + o\n        });\n    }\n    async *stream() {\n        const { mtimeMs: o } = await $n(O(this, Ne));\n        if (o > this.lastModified) throw new cl(\"The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.\", \"NotReadableError\");\n        yield* (0,node_fs__WEBPACK_IMPORTED_MODULE_9__.createReadStream)(O(this, Ne), {\n            start: O(this, He),\n            end: O(this, He) + this.size - 1\n        });\n    }\n    get [Symbol.toStringTag]() {\n        return \"Blob\";\n    }\n};\nNe = new WeakMap, He = new WeakMap, n(Er, \"BlobDataItem\");\nlet Sr = Er;\nconst ml = new Set([\n    \"data:\",\n    \"http:\",\n    \"https:\"\n]);\nasync function Ti(i1, o) {\n    return new Promise((a, u)=>{\n        const l = new dt(i1, o), { parsedURL: p, options: h } = ul(l);\n        if (!ml.has(p.protocol)) throw new TypeError(`node-fetch cannot load ${i1}. URL scheme \"${p.protocol.replace(/:$/, \"\")}\" is not supported.`);\n        if (p.protocol === \"data:\") {\n            const _ = js(l.url), V = new le(_, {\n                headers: {\n                    \"Content-Type\": _.typeFull\n                }\n            });\n            a(V);\n            return;\n        }\n        const g = (p.protocol === \"https:\" ? node_https__WEBPACK_IMPORTED_MODULE_1__ : node_http__WEBPACK_IMPORTED_MODULE_0__).request, { signal: A } = l;\n        let w = null;\n        const E = n(()=>{\n            const _ = new _r(\"The operation was aborted.\");\n            u(_), l.body && l.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable && l.body.destroy(_), !(!w || !w.body) && w.body.emit(\"error\", _);\n        }, \"abort\");\n        if (A && A.aborted) {\n            E();\n            return;\n        }\n        const T = n(()=>{\n            E(), q();\n        }, \"abortAndFinalize\"), b = g(p.toString(), h);\n        A && A.addEventListener(\"abort\", T);\n        const q = n(()=>{\n            b.abort(), A && A.removeEventListener(\"abort\", T);\n        }, \"finalize\");\n        b.on(\"error\", (_)=>{\n            u(new G(`request to ${l.url} failed, reason: ${_.message}`, \"system\", _)), q();\n        }), yl(b, (_)=>{\n            w && w.body && w.body.destroy(_);\n        }), process.version < \"v14\" && b.on(\"socket\", (_)=>{\n            let V;\n            _.prependListener(\"end\", ()=>{\n                V = _._eventsCount;\n            }), _.prependListener(\"close\", (I)=>{\n                if (w && V < _._eventsCount && !I) {\n                    const F = new Error(\"Premature close\");\n                    F.code = \"ERR_STREAM_PREMATURE_CLOSE\", w.body.emit(\"error\", F);\n                }\n            });\n        }), b.on(\"response\", (_)=>{\n            b.setTimeout(0);\n            const V = el(_.rawHeaders);\n            if (Ln(_.statusCode)) {\n                const z = V.get(\"Location\");\n                let j = null;\n                try {\n                    j = z === null ? null : new URL(z, l.url);\n                } catch  {\n                    if (l.redirect !== \"manual\") {\n                        u(new G(`uri requested responds with an invalid redirect URL: ${z}`, \"invalid-redirect\")), q();\n                        return;\n                    }\n                }\n                switch(l.redirect){\n                    case \"error\":\n                        u(new G(`uri requested responds with a redirect, redirect mode is set to error: ${l.url}`, \"no-redirect\")), q();\n                        return;\n                    case \"manual\":\n                        break;\n                    case \"follow\":\n                        {\n                            if (j === null) break;\n                            if (l.counter >= l.follow) {\n                                u(new G(`maximum redirect reached at: ${l.url}`, \"max-redirect\")), q();\n                                return;\n                            }\n                            const U = {\n                                headers: new ye(l.headers),\n                                follow: l.follow,\n                                counter: l.counter + 1,\n                                agent: l.agent,\n                                compress: l.compress,\n                                method: l.method,\n                                body: Fn(l),\n                                signal: l.signal,\n                                size: l.size,\n                                referrer: l.referrer,\n                                referrerPolicy: l.referrerPolicy\n                            };\n                            if (!Ys(l.url, j) || !Gs(l.url, j)) for (const Ft of [\n                                \"authorization\",\n                                \"www-authenticate\",\n                                \"cookie\",\n                                \"cookie2\"\n                            ])U.headers.delete(Ft);\n                            if (_.statusCode !== 303 && l.body && o.body instanceof node_stream__WEBPACK_IMPORTED_MODULE_3__.Readable) {\n                                u(new G(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\")), q();\n                                return;\n                            }\n                            (_.statusCode === 303 || (_.statusCode === 301 || _.statusCode === 302) && l.method === \"POST\") && (U.method = \"GET\", U.body = void 0, U.headers.delete(\"content-length\"));\n                            const D = sl(V);\n                            D && (U.referrerPolicy = D), a(Ti(new dt(j, U))), q();\n                            return;\n                        }\n                    default:\n                        return u(new TypeError(`Redirect option '${l.redirect}' is not a valid value of RequestRedirect`));\n                }\n            }\n            A && _.once(\"end\", ()=>{\n                A.removeEventListener(\"abort\", T);\n            });\n            let I = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough, (z)=>{\n                z && u(z);\n            });\n            process.version < \"v12.10\" && _.on(\"aborted\", T);\n            const F = {\n                url: l.url,\n                status: _.statusCode,\n                statusText: _.statusMessage,\n                headers: V,\n                size: l.size,\n                counter: l.counter,\n                highWaterMark: l.highWaterMark\n            }, Q = V.get(\"Content-Encoding\");\n            if (!l.compress || l.method === \"HEAD\" || Q === null || _.statusCode === 204 || _.statusCode === 304) {\n                w = new le(I, F), a(w);\n                return;\n            }\n            const ge = {\n                flush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH,\n                finishFlush: node_zlib__WEBPACK_IMPORTED_MODULE_2__.Z_SYNC_FLUSH\n            };\n            if (Q === \"gzip\" || Q === \"x-gzip\") {\n                I = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(I, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createGunzip(ge), (z)=>{\n                    z && u(z);\n                }), w = new le(I, F), a(w);\n                return;\n            }\n            if (Q === \"deflate\" || Q === \"x-deflate\") {\n                const z = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(_, new node_stream__WEBPACK_IMPORTED_MODULE_3__.PassThrough, (j)=>{\n                    j && u(j);\n                });\n                z.once(\"data\", (j)=>{\n                    (j[0] & 15) === 8 ? I = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(I, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflate(), (U)=>{\n                        U && u(U);\n                    }) : I = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(I, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createInflateRaw(), (U)=>{\n                        U && u(U);\n                    }), w = new le(I, F), a(w);\n                }), z.once(\"end\", ()=>{\n                    w || (w = new le(I, F), a(w));\n                });\n                return;\n            }\n            if (Q === \"br\") {\n                I = (0,node_stream__WEBPACK_IMPORTED_MODULE_3__.pipeline)(I, node_zlib__WEBPACK_IMPORTED_MODULE_2__.createBrotliDecompress(), (z)=>{\n                    z && u(z);\n                }), w = new le(I, F), a(w);\n                return;\n            }\n            w = new le(I, F), a(w);\n        }), Xs(b, l).catch(u);\n    });\n}\nn(Ti, \"fetch$1\");\nfunction yl(i1, o) {\n    const a = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.from(`0\\r\n\\r\n`);\n    let u = !1, l = !1, p;\n    i1.on(\"response\", (h)=>{\n        const { headers: g } = h;\n        u = g[\"transfer-encoding\"] === \"chunked\" && !g[\"content-length\"];\n    }), i1.on(\"socket\", (h)=>{\n        const g = n(()=>{\n            if (u && !l) {\n                const w = new Error(\"Premature close\");\n                w.code = \"ERR_STREAM_PREMATURE_CLOSE\", o(w);\n            }\n        }, \"onSocketClose\"), A = n((w)=>{\n            l = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(w.slice(-5), a) === 0, !l && p && (l = node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(p.slice(-3), a.slice(0, 3)) === 0 && node_buffer__WEBPACK_IMPORTED_MODULE_4__.Buffer.compare(w.slice(-2), a.slice(3)) === 0), p = w;\n        }, \"onData\");\n        h.prependListener(\"close\", g), h.on(\"data\", A), i1.on(\"close\", ()=>{\n            h.removeListener(\"close\", g), h.removeListener(\"data\", A);\n        });\n    });\n}\nn(yl, \"fixResponseChunkedTransferBadEnding\");\nconst Ci = new WeakMap, Dn = new WeakMap;\nfunction W(i1) {\n    const o = Ci.get(i1);\n    return console.assert(o != null, \"'this' is expected an Event object, but got\", i1), o;\n}\nn(W, \"pd\");\nfunction Pi(i1) {\n    if (i1.passiveListener != null) {\n        typeof console < \"u\" && typeof console.error == \"function\" && console.error(\"Unable to preventDefault inside passive event listener invocation.\", i1.passiveListener);\n        return;\n    }\n    i1.event.cancelable && (i1.canceled = !0, typeof i1.event.preventDefault == \"function\" && i1.event.preventDefault());\n}\nn(Pi, \"setCancelFlag\");\nfunction ht(i1, o) {\n    Ci.set(this, {\n        eventTarget: i1,\n        event: o,\n        eventPhase: 2,\n        currentTarget: i1,\n        canceled: !1,\n        stopped: !1,\n        immediateStopped: !1,\n        passiveListener: null,\n        timeStamp: o.timeStamp || Date.now()\n    }), Object.defineProperty(this, \"isTrusted\", {\n        value: !1,\n        enumerable: !0\n    });\n    const a = Object.keys(o);\n    for(let u = 0; u < a.length; ++u){\n        const l = a[u];\n        l in this || Object.defineProperty(this, l, vi(l));\n    }\n}\nn(ht, \"Event\"), ht.prototype = {\n    get type () {\n        return W(this).event.type;\n    },\n    get target () {\n        return W(this).eventTarget;\n    },\n    get currentTarget () {\n        return W(this).currentTarget;\n    },\n    composedPath () {\n        const i1 = W(this).currentTarget;\n        return i1 == null ? [] : [\n            i1\n        ];\n    },\n    get NONE () {\n        return 0;\n    },\n    get CAPTURING_PHASE () {\n        return 1;\n    },\n    get AT_TARGET () {\n        return 2;\n    },\n    get BUBBLING_PHASE () {\n        return 3;\n    },\n    get eventPhase () {\n        return W(this).eventPhase;\n    },\n    stopPropagation () {\n        const i1 = W(this);\n        i1.stopped = !0, typeof i1.event.stopPropagation == \"function\" && i1.event.stopPropagation();\n    },\n    stopImmediatePropagation () {\n        const i1 = W(this);\n        i1.stopped = !0, i1.immediateStopped = !0, typeof i1.event.stopImmediatePropagation == \"function\" && i1.event.stopImmediatePropagation();\n    },\n    get bubbles () {\n        return !!W(this).event.bubbles;\n    },\n    get cancelable () {\n        return !!W(this).event.cancelable;\n    },\n    preventDefault () {\n        Pi(W(this));\n    },\n    get defaultPrevented () {\n        return W(this).canceled;\n    },\n    get composed () {\n        return !!W(this).event.composed;\n    },\n    get timeStamp () {\n        return W(this).timeStamp;\n    },\n    get srcElement () {\n        return W(this).eventTarget;\n    },\n    get cancelBubble () {\n        return W(this).stopped;\n    },\n    set cancelBubble (i){\n        if (!i) return;\n        const o = W(this);\n        o.stopped = !0, typeof o.event.cancelBubble == \"boolean\" && (o.event.cancelBubble = !0);\n    },\n    get returnValue () {\n        return !W(this).canceled;\n    },\n    set returnValue (i){\n        i || Pi(W(this));\n    },\n    initEvent () {}\n}, Object.defineProperty(ht.prototype, \"constructor\", {\n    value: ht,\n    configurable: !0,\n    writable: !0\n}),  false && (0);\nfunction vi(i1) {\n    return {\n        get () {\n            return W(this).event[i1];\n        },\n        set (o) {\n            W(this).event[i1] = o;\n        },\n        configurable: !0,\n        enumerable: !0\n    };\n}\nn(vi, \"defineRedirectDescriptor\");\nfunction gl(i1) {\n    return {\n        value () {\n            const o = W(this).event;\n            return o[i1].apply(o, arguments);\n        },\n        configurable: !0,\n        enumerable: !0\n    };\n}\nn(gl, \"defineCallDescriptor\");\nfunction _l(i1, o) {\n    const a = Object.keys(o);\n    if (a.length === 0) return i1;\n    function u(l, p) {\n        i1.call(this, l, p);\n    }\n    n(u, \"CustomEvent\"), u.prototype = Object.create(i1.prototype, {\n        constructor: {\n            value: u,\n            configurable: !0,\n            writable: !0\n        }\n    });\n    for(let l = 0; l < a.length; ++l){\n        const p = a[l];\n        if (!(p in i1.prototype)) {\n            const g = typeof Object.getOwnPropertyDescriptor(o, p).value == \"function\";\n            Object.defineProperty(u.prototype, p, g ? gl(p) : vi(p));\n        }\n    }\n    return u;\n}\nn(_l, \"defineWrapper\");\nfunction Ei(i1) {\n    if (i1 == null || i1 === Object.prototype) return ht;\n    let o = Dn.get(i1);\n    return o == null && (o = _l(Ei(Object.getPrototypeOf(i1)), i1), Dn.set(i1, o)), o;\n}\nn(Ei, \"getWrapper\");\nfunction Sl(i1, o) {\n    const a = Ei(Object.getPrototypeOf(o));\n    return new a(i1, o);\n}\nn(Sl, \"wrapEvent\");\nfunction wl(i1) {\n    return W(i1).immediateStopped;\n}\nn(wl, \"isStopped\");\nfunction Rl(i1, o) {\n    W(i1).eventPhase = o;\n}\nn(Rl, \"setEventPhase\");\nfunction Tl(i1, o) {\n    W(i1).currentTarget = o;\n}\nn(Tl, \"setCurrentTarget\");\nfunction Ai(i1, o) {\n    W(i1).passiveListener = o;\n}\nn(Ai, \"setPassiveListener\");\nconst Bi = new WeakMap, ki = 1, Wi = 2, wr = 3;\nfunction Rr(i1) {\n    return i1 !== null && typeof i1 == \"object\";\n}\nn(Rr, \"isObject\");\nfunction Bt(i1) {\n    const o = Bi.get(i1);\n    if (o == null) throw new TypeError(\"'this' is expected an EventTarget object, but got another value.\");\n    return o;\n}\nn(Bt, \"getListeners\");\nfunction Cl(i1) {\n    return {\n        get () {\n            let a = Bt(this).get(i1);\n            for(; a != null;){\n                if (a.listenerType === wr) return a.listener;\n                a = a.next;\n            }\n            return null;\n        },\n        set (o) {\n            typeof o != \"function\" && !Rr(o) && (o = null);\n            const a = Bt(this);\n            let u = null, l = a.get(i1);\n            for(; l != null;)l.listenerType === wr ? u !== null ? u.next = l.next : l.next !== null ? a.set(i1, l.next) : a.delete(i1) : u = l, l = l.next;\n            if (o !== null) {\n                const p = {\n                    listener: o,\n                    listenerType: wr,\n                    passive: !1,\n                    once: !1,\n                    next: null\n                };\n                u === null ? a.set(i1, p) : u.next = p;\n            }\n        },\n        configurable: !0,\n        enumerable: !0\n    };\n}\nn(Cl, \"defineEventAttributeDescriptor\");\nfunction qi(i1, o) {\n    Object.defineProperty(i1, `on${o}`, Cl(o));\n}\nn(qi, \"defineEventAttribute\");\nfunction Oi(i1) {\n    function o() {\n        Pe.call(this);\n    }\n    n(o, \"CustomEventTarget\"), o.prototype = Object.create(Pe.prototype, {\n        constructor: {\n            value: o,\n            configurable: !0,\n            writable: !0\n        }\n    });\n    for(let a = 0; a < i1.length; ++a)qi(o.prototype, i1[a]);\n    return o;\n}\nn(Oi, \"defineCustomEventTarget\");\nfunction Pe() {\n    if (this instanceof Pe) {\n        Bi.set(this, new Map);\n        return;\n    }\n    if (arguments.length === 1 && Array.isArray(arguments[0])) return Oi(arguments[0]);\n    if (arguments.length > 0) {\n        const i1 = new Array(arguments.length);\n        for(let o = 0; o < arguments.length; ++o)i1[o] = arguments[o];\n        return Oi(i1);\n    }\n    throw new TypeError(\"Cannot call a class as a function\");\n}\nn(Pe, \"EventTarget\"), Pe.prototype = {\n    addEventListener (i1, o, a) {\n        if (o == null) return;\n        if (typeof o != \"function\" && !Rr(o)) throw new TypeError(\"'listener' should be a function or an object.\");\n        const u = Bt(this), l = Rr(a), h = (l ? !!a.capture : !!a) ? ki : Wi, g = {\n            listener: o,\n            listenerType: h,\n            passive: l && !!a.passive,\n            once: l && !!a.once,\n            next: null\n        };\n        let A = u.get(i1);\n        if (A === void 0) {\n            u.set(i1, g);\n            return;\n        }\n        let w = null;\n        for(; A != null;){\n            if (A.listener === o && A.listenerType === h) return;\n            w = A, A = A.next;\n        }\n        w.next = g;\n    },\n    removeEventListener (i1, o, a) {\n        if (o == null) return;\n        const u = Bt(this), p = (Rr(a) ? !!a.capture : !!a) ? ki : Wi;\n        let h = null, g = u.get(i1);\n        for(; g != null;){\n            if (g.listener === o && g.listenerType === p) {\n                h !== null ? h.next = g.next : g.next !== null ? u.set(i1, g.next) : u.delete(i1);\n                return;\n            }\n            h = g, g = g.next;\n        }\n    },\n    dispatchEvent (i1) {\n        if (i1 == null || typeof i1.type != \"string\") throw new TypeError('\"event.type\" should be a string.');\n        const o = Bt(this), a = i1.type;\n        let u = o.get(a);\n        if (u == null) return !0;\n        const l = Sl(this, i1);\n        let p = null;\n        for(; u != null;){\n            if (u.once ? p !== null ? p.next = u.next : u.next !== null ? o.set(a, u.next) : o.delete(a) : p = u, Ai(l, u.passive ? u.listener : null), typeof u.listener == \"function\") try {\n                u.listener.call(this, l);\n            } catch (h) {\n                typeof console < \"u\" && typeof console.error == \"function\" && console.error(h);\n            }\n            else u.listenerType !== wr && typeof u.listener.handleEvent == \"function\" && u.listener.handleEvent(l);\n            if (wl(l)) break;\n            u = u.next;\n        }\n        return Ai(l, null), Rl(l, 0), Tl(l, null), !l.defaultPrevented;\n    }\n}, Object.defineProperty(Pe.prototype, \"constructor\", {\n    value: Pe,\n    configurable: !0,\n    writable: !0\n}),  false && 0;\nconst Vn = class Vn extends Pe {\n    constructor(){\n        throw super(), new TypeError(\"AbortSignal cannot be constructed directly\");\n    }\n    get aborted() {\n        const o = Tr.get(this);\n        if (typeof o != \"boolean\") throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? \"null\" : typeof this}`);\n        return o;\n    }\n};\nn(Vn, \"AbortSignal\");\nlet pt = Vn;\nqi(pt.prototype, \"abort\");\nfunction Pl() {\n    const i1 = Object.create(pt.prototype);\n    return Pe.call(i1), Tr.set(i1, !1), i1;\n}\nn(Pl, \"createAbortSignal\");\nfunction vl(i1) {\n    Tr.get(i1) === !1 && (Tr.set(i1, !0), i1.dispatchEvent({\n        type: \"abort\"\n    }));\n}\nn(vl, \"abortSignal\");\nconst Tr = new WeakMap;\nObject.defineProperties(pt.prototype, {\n    aborted: {\n        enumerable: !0\n    }\n}), typeof Symbol == \"function\" && typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(pt.prototype, Symbol.toStringTag, {\n    configurable: !0,\n    value: \"AbortSignal\"\n});\nlet Mn = (It = class {\n    constructor(){\n        zi.set(this, Pl());\n    }\n    get signal() {\n        return Ii(this);\n    }\n    abort() {\n        vl(Ii(this));\n    }\n}, n(It, \"AbortController\"), It);\nconst zi = new WeakMap;\nfunction Ii(i1) {\n    const o = zi.get(i1);\n    if (o == null) throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${i1 === null ? \"null\" : typeof i1}`);\n    return o;\n}\nn(Ii, \"getSignal\"), Object.defineProperties(Mn.prototype, {\n    signal: {\n        enumerable: !0\n    },\n    abort: {\n        enumerable: !0\n    }\n}), typeof Symbol == \"function\" && typeof Symbol.toStringTag == \"symbol\" && Object.defineProperty(Mn.prototype, Symbol.toStringTag, {\n    configurable: !0,\n    value: \"AbortController\"\n});\nvar El = Object.defineProperty, Al = n((i1, o)=>El(i1, \"name\", {\n        value: o,\n        configurable: !0\n    }), \"e\");\nconst Fi = Ti;\nji();\nfunction ji() {\n    !globalThis.process?.versions?.node && !globalThis.process?.env.DISABLE_NODE_FETCH_NATIVE_WARN && console.warn(\"[node-fetch-native] Node.js compatible build of `node-fetch-native` is being used in a non-Node.js environment. Please make sure you are using proper export conditions or report this issue to https://github.com/unjs/node-fetch-native. You can set `process.env.DISABLE_NODE_FETCH_NATIVE_WARN` to disable this warning.\");\n}\nn(ji, \"s\"), Al(ji, \"checkNodeEnvironment\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxLQUFHQyxPQUFPQyxjQUFjO0FBQUMsSUFBSUMsSUFBRSxDQUFDQyxJQUFFQyxJQUFJTCxHQUFHSSxJQUFFLFFBQU87UUFBQ0UsT0FBTUQ7UUFBRUUsY0FBYSxDQUFDO0lBQUM7QUFBRyxJQUFJQyxLQUFHLENBQUNKLElBQUVDLEdBQUVJO0lBQUssSUFBRyxDQUFDSixFQUFFSyxHQUFHLENBQUNOLEtBQUcsTUFBTU8sVUFBVSxZQUFVRjtBQUFFO0FBQUUsSUFBSUcsSUFBRSxDQUFDUixJQUFFQyxHQUFFSSxJQUFLRCxDQUFBQSxHQUFHSixJQUFFQyxHQUFFLDRCQUEyQkksSUFBRUEsRUFBRUksSUFBSSxDQUFDVCxNQUFHQyxFQUFFUyxHQUFHLENBQUNWLEdBQUMsR0FBR1csS0FBRyxDQUFDWCxJQUFFQyxHQUFFSTtJQUFLLElBQUdKLEVBQUVLLEdBQUcsQ0FBQ04sS0FBRyxNQUFNTyxVQUFVO0lBQXFETixhQUFhVyxVQUFRWCxFQUFFWSxHQUFHLENBQUNiLE1BQUdDLEVBQUVhLEdBQUcsQ0FBQ2QsSUFBRUs7QUFBRSxHQUFFVSxJQUFFLENBQUNmLElBQUVDLEdBQUVJLEdBQUVXLElBQUtaLENBQUFBLEdBQUdKLElBQUVDLEdBQUUsMkJBQTBCZSxJQUFFQSxFQUFFUCxJQUFJLENBQUNULElBQUVLLEtBQUdKLEVBQUVhLEdBQUcsQ0FBQ2QsSUFBRUssSUFBR0EsQ0FBQUE7QUFBRyxJQUFJWSxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQztBQUE2QjtBQUEyQjtBQUEwQjtBQUE4RDtBQUFxQztBQUFtRTtBQUFxRTtBQUFtQztBQUFpQztBQUEwRTtBQUFzQztBQUFBLFNBQVNpQyxHQUFHOUQsRUFB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QSxHQUFFLENBQUM7SUFBRSxPQUFPQztBQUFDO0FBQUNGLEVBQUV5NUIsSUFBRyxjQUFhMzVCLE9BQU9rTSxnQkFBZ0IsQ0FBQ3V0QixHQUFHL3pCLFNBQVMsRUFBQztJQUFDcVgsUUFBTztRQUFDNVEsWUFBVyxDQUFDO0lBQUM7SUFBRTRLLE9BQU07UUFBQzVLLFlBQVcsQ0FBQztJQUFDO0FBQUMsSUFBRyxPQUFPcEUsVUFBUSxjQUFZLE9BQU9BLE9BQU9xRSxXQUFXLElBQUUsWUFBVXBNLE9BQU9DLGNBQWMsQ0FBQ3c1QixHQUFHL3pCLFNBQVMsRUFBQ3FDLE9BQU9xRSxXQUFXLEVBQUM7SUFBQzlMLGNBQWEsQ0FBQztJQUFFRCxPQUFNO0FBQWlCO0FBQUcsSUFBSXU1QixLQUFHNTVCLE9BQU9DLGNBQWMsRUFBQzQ1QixLQUFHMzVCLEVBQUUsQ0FBQ0MsSUFBRUMsSUFBSXc1QixHQUFHejVCLElBQUUsUUFBTztRQUFDRSxPQUFNRDtRQUFFRSxjQUFhLENBQUM7SUFBQyxJQUFHO0FBQUssTUFBTXc1QixLQUFHakc7QUFBR2tHO0FBQUssU0FBU0E7SUFBSyxDQUFDaGMsV0FBV2tXLE9BQU8sRUFBRStGLFVBQVVDLFFBQU0sQ0FBQ2xjLFdBQVdrVyxPQUFPLEVBQUVpRyxJQUFJQyxrQ0FBZ0M3RSxRQUFROEUsSUFBSSxDQUFDO0FBQStUO0FBQUNsNkIsRUFBRTY1QixJQUFHLE1BQUtGLEdBQUdFLElBQUc7QUFBc1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcHJpdnktaW8vd2FnbWktZGVtby8uL25vZGVfbW9kdWxlcy9ub2RlLWZldGNoLW5hdGl2ZS9kaXN0L25vZGUubWpzPzcwOTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEFzPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgbj0oaSxvKT0+QXMoaSxcIm5hbWVcIix7dmFsdWU6byxjb25maWd1cmFibGU6ITB9KTt2YXIgZmk9KGksbyxhKT0+e2lmKCFvLmhhcyhpKSl0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIrYSl9O3ZhciBPPShpLG8sYSk9PihmaShpLG8sXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSxhP2EuY2FsbChpKTpvLmdldChpKSksYmU9KGksbyxhKT0+e2lmKG8uaGFzKGkpKXRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7byBpbnN0YW5jZW9mIFdlYWtTZXQ/by5hZGQoaSk6by5zZXQoaSxhKX0sWD0oaSxvLGEsdSk9PihmaShpLG8sXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLHU/dS5jYWxsKGksYSk6by5zZXQoaSxhKSxhKTt2YXIgdmUsa3QsYnQsQ3IsVmUsV3QscXQsT3QsZWUsenQsTmUsSGUsSXQ7aW1wb3J0IHZ0IGZyb21cIm5vZGU6aHR0cFwiO2ltcG9ydCBCcyBmcm9tXCJub2RlOmh0dHBzXCI7aW1wb3J0IHN0IGZyb21cIm5vZGU6emxpYlwiO2ltcG9ydCBtZSx7UGFzc1Rocm91Z2ggYXMgY3IscGlwZWxpbmUgYXMgbHR9ZnJvbVwibm9kZTpzdHJlYW1cIjtpbXBvcnR7QnVmZmVyIGFzIE19ZnJvbVwibm9kZTpidWZmZXJcIjtpbXBvcnR7dHlwZXMgYXMgZHIscHJvbWlzaWZ5IGFzIGtzLGRlcHJlY2F0ZSBhcyBocn1mcm9tXCJub2RlOnV0aWxcIjtpbXBvcnR7YyBhcyBXbixnIGFzIFdzfWZyb21cIi4vc2hhcmVkL25vZGUtZmV0Y2gtbmF0aXZlLjFhNGEzNTZkLm1qc1wiO2ltcG9ydHtmb3JtYXQgYXMgcXN9ZnJvbVwibm9kZTp1cmxcIjtpbXBvcnR7aXNJUCBhcyBPc31mcm9tXCJub2RlOm5ldFwiO2ltcG9ydHtzdGF0U3luYyBhcyBjaSxjcmVhdGVSZWFkU3RyZWFtIGFzIHpzLHByb21pc2VzIGFzIElzfWZyb21cIm5vZGU6ZnNcIjtpbXBvcnR7YmFzZW5hbWUgYXMgRnN9ZnJvbVwibm9kZTpwYXRoXCI7ZnVuY3Rpb24ganMoaSl7aWYoIS9eZGF0YTovaS50ZXN0KGkpKXRocm93IG5ldyBUeXBlRXJyb3IoJ2B1cmlgIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIERhdGEgVVJJIChtdXN0IGJlZ2luIHdpdGggXCJkYXRhOlwiKScpO2k9aS5yZXBsYWNlKC9cXHI/XFxuL2csXCJcIik7Y29uc3Qgbz1pLmluZGV4T2YoXCIsXCIpO2lmKG89PT0tMXx8bzw9NCl0aHJvdyBuZXcgVHlwZUVycm9yKFwibWFsZm9ybWVkIGRhdGE6IFVSSVwiKTtjb25zdCBhPWkuc3Vic3RyaW5nKDUsbykuc3BsaXQoXCI7XCIpO2xldCB1PVwiXCIsbD0hMTtjb25zdCBwPWFbMF18fFwidGV4dC9wbGFpblwiO2xldCBoPXA7Zm9yKGxldCBFPTE7RTxhLmxlbmd0aDtFKyspYVtFXT09PVwiYmFzZTY0XCI/bD0hMDphW0VdJiYoaCs9YDske2FbRV19YCxhW0VdLmluZGV4T2YoXCJjaGFyc2V0PVwiKT09PTAmJih1PWFbRV0uc3Vic3RyaW5nKDgpKSk7IWFbMF0mJiF1Lmxlbmd0aCYmKGgrPVwiO2NoYXJzZXQ9VVMtQVNDSUlcIix1PVwiVVMtQVNDSUlcIik7Y29uc3QgZz1sP1wiYmFzZTY0XCI6XCJhc2NpaVwiLEE9dW5lc2NhcGUoaS5zdWJzdHJpbmcobysxKSksdz1CdWZmZXIuZnJvbShBLGcpO3JldHVybiB3LnR5cGU9cCx3LnR5cGVGdWxsPWgsdy5jaGFyc2V0PXUsd31uKGpzLFwiZGF0YVVyaVRvQnVmZmVyXCIpO3ZhciBwcj17ZXhwb3J0czp7fX07LyoqXG4gKiBAbGljZW5zZVxuICogd2ViLXN0cmVhbXMtcG9seWZpbGwgdjMuMy4zXG4gKiBDb3B5cmlnaHQgMjAyNCBNYXR0aWFzIEJ1ZWxlbnMsIERpd2FuayBTaW5naCBUb21lciBhbmQgb3RoZXIgY29udHJpYnV0b3JzLlxuICogVGhpcyBjb2RlIGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVRcbiAqL3ZhciBkaTtmdW5jdGlvbiBMcygpe3JldHVybiBkaXx8KGRpPTEsZnVuY3Rpb24oaSxvKXsoZnVuY3Rpb24oYSx1KXt1KG8pfSkoV24sZnVuY3Rpb24oYSl7ZnVuY3Rpb24gdSgpe31uKHUsXCJub29wXCIpO2Z1bmN0aW9uIGwoZSl7cmV0dXJuIHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbHx8dHlwZW9mIGU9PVwiZnVuY3Rpb25cIn1uKGwsXCJ0eXBlSXNPYmplY3RcIik7Y29uc3QgcD11O2Z1bmN0aW9uIGgoZSx0KXt0cnl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJuYW1lXCIse3ZhbHVlOnQsY29uZmlndXJhYmxlOiEwfSl9Y2F0Y2h7fX1uKGgsXCJzZXRGdW5jdGlvbk5hbWVcIik7Y29uc3QgZz1Qcm9taXNlLEE9UHJvbWlzZS5wcm90b3R5cGUudGhlbix3PVByb21pc2UucmVqZWN0LmJpbmQoZyk7ZnVuY3Rpb24gRShlKXtyZXR1cm4gbmV3IGcoZSl9bihFLFwibmV3UHJvbWlzZVwiKTtmdW5jdGlvbiBUKGUpe3JldHVybiBFKHQ9PnQoZSkpfW4oVCxcInByb21pc2VSZXNvbHZlZFdpdGhcIik7ZnVuY3Rpb24gYihlKXtyZXR1cm4gdyhlKX1uKGIsXCJwcm9taXNlUmVqZWN0ZWRXaXRoXCIpO2Z1bmN0aW9uIHEoZSx0LHIpe3JldHVybiBBLmNhbGwoZSx0LHIpfW4ocSxcIlBlcmZvcm1Qcm9taXNlVGhlblwiKTtmdW5jdGlvbiBfKGUsdCxyKXtxKHEoZSx0LHIpLHZvaWQgMCxwKX1uKF8sXCJ1cG9uUHJvbWlzZVwiKTtmdW5jdGlvbiBWKGUsdCl7XyhlLHQpfW4oVixcInVwb25GdWxmaWxsbWVudFwiKTtmdW5jdGlvbiBJKGUsdCl7XyhlLHZvaWQgMCx0KX1uKEksXCJ1cG9uUmVqZWN0aW9uXCIpO2Z1bmN0aW9uIEYoZSx0LHIpe3JldHVybiBxKGUsdCxyKX1uKEYsXCJ0cmFuc2Zvcm1Qcm9taXNlV2l0aFwiKTtmdW5jdGlvbiBRKGUpe3EoZSx2b2lkIDAscCl9bihRLFwic2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZVwiKTtsZXQgZ2U9bihlPT57aWYodHlwZW9mIHF1ZXVlTWljcm90YXNrPT1cImZ1bmN0aW9uXCIpZ2U9cXVldWVNaWNyb3Rhc2s7ZWxzZXtjb25zdCB0PVQodm9pZCAwKTtnZT1uKHI9PnEodCxyKSxcIl9xdWV1ZU1pY3JvdGFza1wiKX1yZXR1cm4gZ2UoZSl9LFwiX3F1ZXVlTWljcm90YXNrXCIpO2Z1bmN0aW9uIHooZSx0LHIpe2lmKHR5cGVvZiBlIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uXCIpO3JldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChlLHQscil9bih6LFwicmVmbGVjdENhbGxcIik7ZnVuY3Rpb24gaihlLHQscil7dHJ5e3JldHVybiBUKHooZSx0LHIpKX1jYXRjaChzKXtyZXR1cm4gYihzKX19bihqLFwicHJvbWlzZUNhbGxcIik7Y29uc3QgVT0xNjM4NCxibj1jbGFzcyBibntjb25zdHJ1Y3Rvcigpe3RoaXMuX2N1cnNvcj0wLHRoaXMuX3NpemU9MCx0aGlzLl9mcm9udD17X2VsZW1lbnRzOltdLF9uZXh0OnZvaWQgMH0sdGhpcy5fYmFjaz10aGlzLl9mcm9udCx0aGlzLl9jdXJzb3I9MCx0aGlzLl9zaXplPTB9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLl9zaXplfXB1c2godCl7Y29uc3Qgcj10aGlzLl9iYWNrO2xldCBzPXI7ci5fZWxlbWVudHMubGVuZ3RoPT09VS0xJiYocz17X2VsZW1lbnRzOltdLF9uZXh0OnZvaWQgMH0pLHIuX2VsZW1lbnRzLnB1c2godCkscyE9PXImJih0aGlzLl9iYWNrPXMsci5fbmV4dD1zKSwrK3RoaXMuX3NpemV9c2hpZnQoKXtjb25zdCB0PXRoaXMuX2Zyb250O2xldCByPXQ7Y29uc3Qgcz10aGlzLl9jdXJzb3I7bGV0IGY9cysxO2NvbnN0IGM9dC5fZWxlbWVudHMsZD1jW3NdO3JldHVybiBmPT09VSYmKHI9dC5fbmV4dCxmPTApLC0tdGhpcy5fc2l6ZSx0aGlzLl9jdXJzb3I9Zix0IT09ciYmKHRoaXMuX2Zyb250PXIpLGNbc109dm9pZCAwLGR9Zm9yRWFjaCh0KXtsZXQgcj10aGlzLl9jdXJzb3Iscz10aGlzLl9mcm9udCxmPXMuX2VsZW1lbnRzO2Zvcig7KHIhPT1mLmxlbmd0aHx8cy5fbmV4dCE9PXZvaWQgMCkmJiEocj09PWYubGVuZ3RoJiYocz1zLl9uZXh0LGY9cy5fZWxlbWVudHMscj0wLGYubGVuZ3RoPT09MCkpOyl0KGZbcl0pLCsrcn1wZWVrKCl7Y29uc3QgdD10aGlzLl9mcm9udCxyPXRoaXMuX2N1cnNvcjtyZXR1cm4gdC5fZWxlbWVudHNbcl19fTtuKGJuLFwiU2ltcGxlUXVldWVcIik7bGV0IEQ9Ym47Y29uc3QgRnQ9U3ltYm9sKFwiW1tBYm9ydFN0ZXBzXV1cIiksUW49U3ltYm9sKFwiW1tFcnJvclN0ZXBzXV1cIiksQXI9U3ltYm9sKFwiW1tDYW5jZWxTdGVwc11dXCIpLEJyPVN5bWJvbChcIltbUHVsbFN0ZXBzXV1cIiksa3I9U3ltYm9sKFwiW1tSZWxlYXNlU3RlcHNdXVwiKTtmdW5jdGlvbiBZbihlLHQpe2UuX293bmVyUmVhZGFibGVTdHJlYW09dCx0Ll9yZWFkZXI9ZSx0Ll9zdGF0ZT09PVwicmVhZGFibGVcIj9xcihlKTp0Ll9zdGF0ZT09PVwiY2xvc2VkXCI/TGkoZSk6R24oZSx0Ll9zdG9yZWRFcnJvcil9bihZbixcIlJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemVcIik7ZnVuY3Rpb24gV3IoZSx0KXtjb25zdCByPWUuX293bmVyUmVhZGFibGVTdHJlYW07cmV0dXJuIGllKHIsdCl9bihXcixcIlJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbFwiKTtmdW5jdGlvbiBfZShlKXtjb25zdCB0PWUuX293bmVyUmVhZGFibGVTdHJlYW07dC5fc3RhdGU9PT1cInJlYWRhYmxlXCI/T3IoZSxuZXcgVHlwZUVycm9yKFwiUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NcIikpOiRpKGUsbmV3IFR5cGVFcnJvcihcIlJlYWRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzXCIpKSx0Ll9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJba3JdKCksdC5fcmVhZGVyPXZvaWQgMCxlLl9vd25lclJlYWRhYmxlU3RyZWFtPXZvaWQgMH1uKF9lLFwiUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZVwiKTtmdW5jdGlvbiBqdChlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBcIitlK1wiIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgcmVhZGVyXCIpfW4oanQsXCJyZWFkZXJMb2NrRXhjZXB0aW9uXCIpO2Z1bmN0aW9uIHFyKGUpe2UuX2Nsb3NlZFByb21pc2U9RSgodCxyKT0+e2UuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZT10LGUuX2Nsb3NlZFByb21pc2VfcmVqZWN0PXJ9KX1uKHFyLFwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplXCIpO2Z1bmN0aW9uIEduKGUsdCl7cXIoZSksT3IoZSx0KX1uKEduLFwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZFwiKTtmdW5jdGlvbiBMaShlKXtxcihlKSxabihlKX1uKExpLFwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZFwiKTtmdW5jdGlvbiBPcihlLHQpe2UuX2Nsb3NlZFByb21pc2VfcmVqZWN0IT09dm9pZCAwJiYoUShlLl9jbG9zZWRQcm9taXNlKSxlLl9jbG9zZWRQcm9taXNlX3JlamVjdCh0KSxlLl9jbG9zZWRQcm9taXNlX3Jlc29sdmU9dm9pZCAwLGUuX2Nsb3NlZFByb21pc2VfcmVqZWN0PXZvaWQgMCl9bihPcixcImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0XCIpO2Z1bmN0aW9uICRpKGUsdCl7R24oZSx0KX1uKCRpLFwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWRcIik7ZnVuY3Rpb24gWm4oZSl7ZS5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlIT09dm9pZCAwJiYoZS5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHZvaWQgMCksZS5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlPXZvaWQgMCxlLl9jbG9zZWRQcm9taXNlX3JlamVjdD12b2lkIDApfW4oWm4sXCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmVcIik7Y29uc3QgS249TnVtYmVyLmlzRmluaXRlfHxmdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGU9PVwibnVtYmVyXCImJmlzRmluaXRlKGUpfSxEaT1NYXRoLnRydW5jfHxmdW5jdGlvbihlKXtyZXR1cm4gZTwwP01hdGguY2VpbChlKTpNYXRoLmZsb29yKGUpfTtmdW5jdGlvbiBNaShlKXtyZXR1cm4gdHlwZW9mIGU9PVwib2JqZWN0XCJ8fHR5cGVvZiBlPT1cImZ1bmN0aW9uXCJ9bihNaSxcImlzRGljdGlvbmFyeVwiKTtmdW5jdGlvbiB1ZShlLHQpe2lmKGUhPT12b2lkIDAmJiFNaShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIG5vdCBhbiBvYmplY3QuYCl9bih1ZSxcImFzc2VydERpY3Rpb25hcnlcIik7ZnVuY3Rpb24gWihlLHQpe2lmKHR5cGVvZiBlIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0fSBpcyBub3QgYSBmdW5jdGlvbi5gKX1uKFosXCJhc3NlcnRGdW5jdGlvblwiKTtmdW5jdGlvbiBVaShlKXtyZXR1cm4gdHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsfHx0eXBlb2YgZT09XCJmdW5jdGlvblwifW4oVWksXCJpc09iamVjdFwiKTtmdW5jdGlvbiBKbihlLHQpe2lmKCFVaShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIG5vdCBhbiBvYmplY3QuYCl9bihKbixcImFzc2VydE9iamVjdFwiKTtmdW5jdGlvbiBTZShlLHQscil7aWYoZT09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXJhbWV0ZXIgJHt0fSBpcyByZXF1aXJlZCBpbiAnJHtyfScuYCl9bihTZSxcImFzc2VydFJlcXVpcmVkQXJndW1lbnRcIik7ZnVuY3Rpb24genIoZSx0LHIpe2lmKGU9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0fSBpcyByZXF1aXJlZCBpbiAnJHtyfScuYCl9bih6cixcImFzc2VydFJlcXVpcmVkRmllbGRcIik7ZnVuY3Rpb24gSXIoZSl7cmV0dXJuIE51bWJlcihlKX1uKElyLFwiY29udmVydFVucmVzdHJpY3RlZERvdWJsZVwiKTtmdW5jdGlvbiBYbihlKXtyZXR1cm4gZT09PTA/MDplfW4oWG4sXCJjZW5zb3JOZWdhdGl2ZVplcm9cIik7ZnVuY3Rpb24geGkoZSl7cmV0dXJuIFhuKERpKGUpKX1uKHhpLFwiaW50ZWdlclBhcnRcIik7ZnVuY3Rpb24gRnIoZSx0KXtjb25zdCBzPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2xldCBmPU51bWJlcihlKTtpZihmPVhuKGYpLCFLbihmKSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIG5vdCBhIGZpbml0ZSBudW1iZXJgKTtpZihmPXhpKGYpLGY8MHx8Zj5zKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dH0gaXMgb3V0c2lkZSB0aGUgYWNjZXB0ZWQgcmFuZ2Ugb2YgMCB0byAke3N9LCBpbmNsdXNpdmVgKTtyZXR1cm4hS24oZil8fGY9PT0wPzA6Zn1uKEZyLFwiY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlXCIpO2Z1bmN0aW9uIGpyKGUsdCl7aWYoIVdlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dH0gaXMgbm90IGEgUmVhZGFibGVTdHJlYW0uYCl9bihqcixcImFzc2VydFJlYWRhYmxlU3RyZWFtXCIpO2Z1bmN0aW9uIFFlKGUpe3JldHVybiBuZXcgZmUoZSl9bihRZSxcIkFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJcIik7ZnVuY3Rpb24gZW8oZSx0KXtlLl9yZWFkZXIuX3JlYWRSZXF1ZXN0cy5wdXNoKHQpfW4oZW8sXCJSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0XCIpO2Z1bmN0aW9uIExyKGUsdCxyKXtjb25zdCBmPWUuX3JlYWRlci5fcmVhZFJlcXVlc3RzLnNoaWZ0KCk7cj9mLl9jbG9zZVN0ZXBzKCk6Zi5fY2h1bmtTdGVwcyh0KX1uKExyLFwiUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3RcIik7ZnVuY3Rpb24gTHQoZSl7cmV0dXJuIGUuX3JlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aH1uKEx0LFwiUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHNcIik7ZnVuY3Rpb24gdG8oZSl7Y29uc3QgdD1lLl9yZWFkZXI7cmV0dXJuISh0PT09dm9pZCAwfHwhRWUodCkpfW4odG8sXCJSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXJcIik7Y29uc3QgbW49Y2xhc3MgbW57Y29uc3RydWN0b3IodCl7aWYoU2UodCwxLFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyXCIpLGpyKHQsXCJGaXJzdCBwYXJhbWV0ZXJcIikscWUodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlclwiKTtZbih0aGlzLHQpLHRoaXMuX3JlYWRSZXF1ZXN0cz1uZXcgRH1nZXQgY2xvc2VkKCl7cmV0dXJuIEVlKHRoaXMpP3RoaXMuX2Nsb3NlZFByb21pc2U6YigkdChcImNsb3NlZFwiKSl9Y2FuY2VsKHQ9dm9pZCAwKXtyZXR1cm4gRWUodGhpcyk/dGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbT09PXZvaWQgMD9iKGp0KFwiY2FuY2VsXCIpKTpXcih0aGlzLHQpOmIoJHQoXCJjYW5jZWxcIikpfXJlYWQoKXtpZighRWUodGhpcykpcmV0dXJuIGIoJHQoXCJyZWFkXCIpKTtpZih0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtPT09dm9pZCAwKXJldHVybiBiKGp0KFwicmVhZCBmcm9tXCIpKTtsZXQgdCxyO2NvbnN0IHM9RSgoYyxkKT0+e3Q9YyxyPWR9KTtyZXR1cm4gbXQodGhpcyx7X2NodW5rU3RlcHM6Yz0+dCh7dmFsdWU6Yyxkb25lOiExfSksX2Nsb3NlU3RlcHM6KCk9PnQoe3ZhbHVlOnZvaWQgMCxkb25lOiEwfSksX2Vycm9yU3RlcHM6Yz0+cihjKX0pLHN9cmVsZWFzZUxvY2soKXtpZighRWUodGhpcykpdGhyb3cgJHQoXCJyZWxlYXNlTG9ja1wiKTt0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtIT09dm9pZCAwJiZOaSh0aGlzKX19O24obW4sXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJcIik7bGV0IGZlPW1uO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGZlLnByb3RvdHlwZSx7Y2FuY2VsOntlbnVtZXJhYmxlOiEwfSxyZWFkOntlbnVtZXJhYmxlOiEwfSxyZWxlYXNlTG9jazp7ZW51bWVyYWJsZTohMH0sY2xvc2VkOntlbnVtZXJhYmxlOiEwfX0pLGgoZmUucHJvdG90eXBlLmNhbmNlbCxcImNhbmNlbFwiKSxoKGZlLnByb3RvdHlwZS5yZWFkLFwicmVhZFwiKSxoKGZlLnByb3RvdHlwZS5yZWxlYXNlTG9jayxcInJlbGVhc2VMb2NrXCIpLHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PVwic3ltYm9sXCImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmZS5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclwiLGNvbmZpZ3VyYWJsZTohMH0pO2Z1bmN0aW9uIEVlKGUpe3JldHVybiFsKGUpfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJfcmVhZFJlcXVlc3RzXCIpPyExOmUgaW5zdGFuY2VvZiBmZX1uKEVlLFwiSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJcIik7ZnVuY3Rpb24gbXQoZSx0KXtjb25zdCByPWUuX293bmVyUmVhZGFibGVTdHJlYW07ci5fZGlzdHVyYmVkPSEwLHIuX3N0YXRlPT09XCJjbG9zZWRcIj90Ll9jbG9zZVN0ZXBzKCk6ci5fc3RhdGU9PT1cImVycm9yZWRcIj90Ll9lcnJvclN0ZXBzKHIuX3N0b3JlZEVycm9yKTpyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbQnJdKHQpfW4obXQsXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkXCIpO2Z1bmN0aW9uIE5pKGUpe19lKGUpO2NvbnN0IHQ9bmV3IFR5cGVFcnJvcihcIlJlYWRlciB3YXMgcmVsZWFzZWRcIik7cm8oZSx0KX1uKE5pLFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVsZWFzZVwiKTtmdW5jdGlvbiBybyhlLHQpe2NvbnN0IHI9ZS5fcmVhZFJlcXVlc3RzO2UuX3JlYWRSZXF1ZXN0cz1uZXcgRCxyLmZvckVhY2gocz0+e3MuX2Vycm9yU3RlcHModCl9KX1uKHJvLFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyRXJyb3JSZWFkUmVxdWVzdHNcIik7ZnVuY3Rpb24gJHQoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyYCl9bigkdCxcImRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uXCIpO2NvbnN0IEhpPU9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24qKCl7fSkucHJvdG90eXBlKSx5bj1jbGFzcyB5bntjb25zdHJ1Y3Rvcih0LHIpe3RoaXMuX29uZ29pbmdQcm9taXNlPXZvaWQgMCx0aGlzLl9pc0ZpbmlzaGVkPSExLHRoaXMuX3JlYWRlcj10LHRoaXMuX3ByZXZlbnRDYW5jZWw9cn1uZXh0KCl7Y29uc3QgdD1uKCgpPT50aGlzLl9uZXh0U3RlcHMoKSxcIm5leHRTdGVwc1wiKTtyZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2U9dGhpcy5fb25nb2luZ1Byb21pc2U/Rih0aGlzLl9vbmdvaW5nUHJvbWlzZSx0LHQpOnQoKSx0aGlzLl9vbmdvaW5nUHJvbWlzZX1yZXR1cm4odCl7Y29uc3Qgcj1uKCgpPT50aGlzLl9yZXR1cm5TdGVwcyh0KSxcInJldHVyblN0ZXBzXCIpO3JldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZT9GKHRoaXMuX29uZ29pbmdQcm9taXNlLHIscik6cigpfV9uZXh0U3RlcHMoKXtpZih0aGlzLl9pc0ZpbmlzaGVkKXJldHVybiBQcm9taXNlLnJlc29sdmUoe3ZhbHVlOnZvaWQgMCxkb25lOiEwfSk7Y29uc3QgdD10aGlzLl9yZWFkZXI7bGV0IHIscztjb25zdCBmPUUoKGQsbSk9PntyPWQscz1tfSk7cmV0dXJuIG10KHQse19jaHVua1N0ZXBzOmQ9Pnt0aGlzLl9vbmdvaW5nUHJvbWlzZT12b2lkIDAsZ2UoKCk9PnIoe3ZhbHVlOmQsZG9uZTohMX0pKX0sX2Nsb3NlU3RlcHM6KCk9Pnt0aGlzLl9vbmdvaW5nUHJvbWlzZT12b2lkIDAsdGhpcy5faXNGaW5pc2hlZD0hMCxfZSh0KSxyKHt2YWx1ZTp2b2lkIDAsZG9uZTohMH0pfSxfZXJyb3JTdGVwczpkPT57dGhpcy5fb25nb2luZ1Byb21pc2U9dm9pZCAwLHRoaXMuX2lzRmluaXNoZWQ9ITAsX2UodCkscyhkKX19KSxmfV9yZXR1cm5TdGVwcyh0KXtpZih0aGlzLl9pc0ZpbmlzaGVkKXJldHVybiBQcm9taXNlLnJlc29sdmUoe3ZhbHVlOnQsZG9uZTohMH0pO3RoaXMuX2lzRmluaXNoZWQ9ITA7Y29uc3Qgcj10aGlzLl9yZWFkZXI7aWYoIXRoaXMuX3ByZXZlbnRDYW5jZWwpe2NvbnN0IHM9V3Iocix0KTtyZXR1cm4gX2UociksRihzLCgpPT4oe3ZhbHVlOnQsZG9uZTohMH0pKX1yZXR1cm4gX2UociksVCh7dmFsdWU6dCxkb25lOiEwfSl9fTtuKHluLFwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbFwiKTtsZXQgRHQ9eW47Y29uc3Qgbm89e25leHQoKXtyZXR1cm4gb28odGhpcyk/dGhpcy5fYXN5bmNJdGVyYXRvckltcGwubmV4dCgpOmIoaW8oXCJuZXh0XCIpKX0scmV0dXJuKGUpe3JldHVybiBvbyh0aGlzKT90aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5yZXR1cm4oZSk6YihpbyhcInJldHVyblwiKSl9fTtPYmplY3Quc2V0UHJvdG90eXBlT2Yobm8sSGkpO2Z1bmN0aW9uIFZpKGUsdCl7Y29uc3Qgcj1RZShlKSxzPW5ldyBEdChyLHQpLGY9T2JqZWN0LmNyZWF0ZShubyk7cmV0dXJuIGYuX2FzeW5jSXRlcmF0b3JJbXBsPXMsZn1uKFZpLFwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclwiKTtmdW5jdGlvbiBvbyhlKXtpZighbChlKXx8IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX2FzeW5jSXRlcmF0b3JJbXBsXCIpKXJldHVybiExO3RyeXtyZXR1cm4gZS5fYXN5bmNJdGVyYXRvckltcGwgaW5zdGFuY2VvZiBEdH1jYXRjaHtyZXR1cm4hMX19bihvbyxcIklzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yXCIpO2Z1bmN0aW9uIGlvKGUpe3JldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdGVhbUFzeW5jSXRlcmF0b3JgKX1uKGlvLFwic3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb25cIik7Y29uc3QgYW89TnVtYmVyLmlzTmFOfHxmdW5jdGlvbihlKXtyZXR1cm4gZSE9PWV9O3ZhciAkcixEcixNcjtmdW5jdGlvbiB5dChlKXtyZXR1cm4gZS5zbGljZSgpfW4oeXQsXCJDcmVhdGVBcnJheUZyb21MaXN0XCIpO2Z1bmN0aW9uIHNvKGUsdCxyLHMsZil7bmV3IFVpbnQ4QXJyYXkoZSkuc2V0KG5ldyBVaW50OEFycmF5KHIscyxmKSx0KX1uKHNvLFwiQ29weURhdGFCbG9ja0J5dGVzXCIpO2xldCB3ZT1uKGU9Pih0eXBlb2YgZS50cmFuc2Zlcj09XCJmdW5jdGlvblwiP3dlPW4odD0+dC50cmFuc2ZlcigpLFwiVHJhbnNmZXJBcnJheUJ1ZmZlclwiKTp0eXBlb2Ygc3RydWN0dXJlZENsb25lPT1cImZ1bmN0aW9uXCI/d2U9bih0PT5zdHJ1Y3R1cmVkQ2xvbmUodCx7dHJhbnNmZXI6W3RdfSksXCJUcmFuc2ZlckFycmF5QnVmZmVyXCIpOndlPW4odD0+dCxcIlRyYW5zZmVyQXJyYXlCdWZmZXJcIiksd2UoZSkpLFwiVHJhbnNmZXJBcnJheUJ1ZmZlclwiKSxBZT1uKGU9Pih0eXBlb2YgZS5kZXRhY2hlZD09XCJib29sZWFuXCI/QWU9bih0PT50LmRldGFjaGVkLFwiSXNEZXRhY2hlZEJ1ZmZlclwiKTpBZT1uKHQ9PnQuYnl0ZUxlbmd0aD09PTAsXCJJc0RldGFjaGVkQnVmZmVyXCIpLEFlKGUpKSxcIklzRGV0YWNoZWRCdWZmZXJcIik7ZnVuY3Rpb24gbG8oZSx0LHIpe2lmKGUuc2xpY2UpcmV0dXJuIGUuc2xpY2UodCxyKTtjb25zdCBzPXItdCxmPW5ldyBBcnJheUJ1ZmZlcihzKTtyZXR1cm4gc28oZiwwLGUsdCxzKSxmfW4obG8sXCJBcnJheUJ1ZmZlclNsaWNlXCIpO2Z1bmN0aW9uIE10KGUsdCl7Y29uc3Qgcj1lW3RdO2lmKHIhPW51bGwpe2lmKHR5cGVvZiByIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtTdHJpbmcodCl9IGlzIG5vdCBhIGZ1bmN0aW9uYCk7cmV0dXJuIHJ9fW4oTXQsXCJHZXRNZXRob2RcIik7ZnVuY3Rpb24gUWkoZSl7Y29uc3QgdD17W1N5bWJvbC5pdGVyYXRvcl06KCk9PmUuaXRlcmF0b3J9LHI9YXN5bmMgZnVuY3Rpb24qKCl7cmV0dXJuIHlpZWxkKnR9KCkscz1yLm5leHQ7cmV0dXJue2l0ZXJhdG9yOnIsbmV4dE1ldGhvZDpzLGRvbmU6ITF9fW4oUWksXCJDcmVhdGVBc3luY0Zyb21TeW5jSXRlcmF0b3JcIik7Y29uc3QgVXI9KE1yPSgkcj1TeW1ib2wuYXN5bmNJdGVyYXRvcikhPT1udWxsJiYkciE9PXZvaWQgMD8kcjooRHI9U3ltYm9sLmZvcik9PT1udWxsfHxEcj09PXZvaWQgMD92b2lkIDA6RHIuY2FsbChTeW1ib2wsXCJTeW1ib2wuYXN5bmNJdGVyYXRvclwiKSkhPT1udWxsJiZNciE9PXZvaWQgMD9NcjpcIkBAYXN5bmNJdGVyYXRvclwiO2Z1bmN0aW9uIHVvKGUsdD1cInN5bmNcIixyKXtpZihyPT09dm9pZCAwKWlmKHQ9PT1cImFzeW5jXCIpe2lmKHI9TXQoZSxVcikscj09PXZvaWQgMCl7Y29uc3QgYz1NdChlLFN5bWJvbC5pdGVyYXRvciksZD11byhlLFwic3luY1wiLGMpO3JldHVybiBRaShkKX19ZWxzZSByPU10KGUsU3ltYm9sLml0ZXJhdG9yKTtpZihyPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgb2JqZWN0IGlzIG5vdCBpdGVyYWJsZVwiKTtjb25zdCBzPXoocixlLFtdKTtpZighbChzKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIG1ldGhvZCBtdXN0IHJldHVybiBhbiBvYmplY3RcIik7Y29uc3QgZj1zLm5leHQ7cmV0dXJue2l0ZXJhdG9yOnMsbmV4dE1ldGhvZDpmLGRvbmU6ITF9fW4odW8sXCJHZXRJdGVyYXRvclwiKTtmdW5jdGlvbiBZaShlKXtjb25zdCB0PXooZS5uZXh0TWV0aG9kLGUuaXRlcmF0b3IsW10pO2lmKCFsKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IubmV4dCgpIG1ldGhvZCBtdXN0IHJldHVybiBhbiBvYmplY3RcIik7cmV0dXJuIHR9bihZaSxcIkl0ZXJhdG9yTmV4dFwiKTtmdW5jdGlvbiBHaShlKXtyZXR1cm4hIWUuZG9uZX1uKEdpLFwiSXRlcmF0b3JDb21wbGV0ZVwiKTtmdW5jdGlvbiBaaShlKXtyZXR1cm4gZS52YWx1ZX1uKFppLFwiSXRlcmF0b3JWYWx1ZVwiKTtmdW5jdGlvbiBLaShlKXtyZXR1cm4hKHR5cGVvZiBlIT1cIm51bWJlclwifHxhbyhlKXx8ZTwwKX1uKEtpLFwiSXNOb25OZWdhdGl2ZU51bWJlclwiKTtmdW5jdGlvbiBmbyhlKXtjb25zdCB0PWxvKGUuYnVmZmVyLGUuYnl0ZU9mZnNldCxlLmJ5dGVPZmZzZXQrZS5ieXRlTGVuZ3RoKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCl9bihmbyxcIkNsb25lQXNVaW50OEFycmF5XCIpO2Z1bmN0aW9uIHhyKGUpe2NvbnN0IHQ9ZS5fcXVldWUuc2hpZnQoKTtyZXR1cm4gZS5fcXVldWVUb3RhbFNpemUtPXQuc2l6ZSxlLl9xdWV1ZVRvdGFsU2l6ZTwwJiYoZS5fcXVldWVUb3RhbFNpemU9MCksdC52YWx1ZX1uKHhyLFwiRGVxdWV1ZVZhbHVlXCIpO2Z1bmN0aW9uIE5yKGUsdCxyKXtpZighS2kocil8fHI9PT0xLzApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTaXplIG11c3QgYmUgYSBmaW5pdGUsIG5vbi1OYU4sIG5vbi1uZWdhdGl2ZSBudW1iZXIuXCIpO2UuX3F1ZXVlLnB1c2goe3ZhbHVlOnQsc2l6ZTpyfSksZS5fcXVldWVUb3RhbFNpemUrPXJ9bihOcixcIkVucXVldWVWYWx1ZVdpdGhTaXplXCIpO2Z1bmN0aW9uIEppKGUpe3JldHVybiBlLl9xdWV1ZS5wZWVrKCkudmFsdWV9bihKaSxcIlBlZWtRdWV1ZVZhbHVlXCIpO2Z1bmN0aW9uIEJlKGUpe2UuX3F1ZXVlPW5ldyBELGUuX3F1ZXVlVG90YWxTaXplPTB9bihCZSxcIlJlc2V0UXVldWVcIik7ZnVuY3Rpb24gY28oZSl7cmV0dXJuIGU9PT1EYXRhVmlld31uKGNvLFwiaXNEYXRhVmlld0NvbnN0cnVjdG9yXCIpO2Z1bmN0aW9uIFhpKGUpe3JldHVybiBjbyhlLmNvbnN0cnVjdG9yKX1uKFhpLFwiaXNEYXRhVmlld1wiKTtmdW5jdGlvbiBlYShlKXtyZXR1cm4gY28oZSk/MTplLkJZVEVTX1BFUl9FTEVNRU5UfW4oZWEsXCJhcnJheUJ1ZmZlclZpZXdFbGVtZW50U2l6ZVwiKTtjb25zdCBnbj1jbGFzcyBnbntjb25zdHJ1Y3Rvcigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cnVjdG9yXCIpfWdldCB2aWV3KCl7aWYoIUhyKHRoaXMpKXRocm93IFpyKFwidmlld1wiKTtyZXR1cm4gdGhpcy5fdmlld31yZXNwb25kKHQpe2lmKCFIcih0aGlzKSl0aHJvdyBacihcInJlc3BvbmRcIik7aWYoU2UodCwxLFwicmVzcG9uZFwiKSx0PUZyKHQsXCJGaXJzdCBwYXJhbWV0ZXJcIiksdGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkXCIpO2lmKEFlKHRoaXMuX3ZpZXcuYnVmZmVyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIEJZT0IgcmVxdWVzdCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIHVzZWQgYXMgYSByZXNwb25zZVwiKTtIdCh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcix0KX1yZXNwb25kV2l0aE5ld1ZpZXcodCl7aWYoIUhyKHRoaXMpKXRocm93IFpyKFwicmVzcG9uZFdpdGhOZXdWaWV3XCIpO2lmKFNlKHQsMSxcInJlc3BvbmRXaXRoTmV3Vmlld1wiKSwhQXJyYXlCdWZmZXIuaXNWaWV3KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgY2FuIG9ubHkgcmVzcG9uZCB3aXRoIGFycmF5IGJ1ZmZlciB2aWV3c1wiKTtpZih0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcj09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWRcIik7aWYoQWUodC5idWZmZXIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZ2l2ZW4gdmlldydzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIHVzZWQgYXMgYSByZXNwb25zZVwiKTtWdCh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcix0KX19O24oZ24sXCJSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0XCIpO2xldCBSZT1nbjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZS5wcm90b3R5cGUse3Jlc3BvbmQ6e2VudW1lcmFibGU6ITB9LHJlc3BvbmRXaXRoTmV3Vmlldzp7ZW51bWVyYWJsZTohMH0sdmlldzp7ZW51bWVyYWJsZTohMH19KSxoKFJlLnByb3RvdHlwZS5yZXNwb25kLFwicmVzcG9uZFwiKSxoKFJlLnByb3RvdHlwZS5yZXNwb25kV2l0aE5ld1ZpZXcsXCJyZXNwb25kV2l0aE5ld1ZpZXdcIiksdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdFwiLGNvbmZpZ3VyYWJsZTohMH0pO2NvbnN0IF9uPWNsYXNzIF9ue2NvbnN0cnVjdG9yKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY29uc3RydWN0b3JcIil9Z2V0IGJ5b2JSZXF1ZXN0KCl7aWYoIXplKHRoaXMpKXRocm93IF90KFwiYnlvYlJlcXVlc3RcIik7cmV0dXJuIEdyKHRoaXMpfWdldCBkZXNpcmVkU2l6ZSgpe2lmKCF6ZSh0aGlzKSl0aHJvdyBfdChcImRlc2lyZWRTaXplXCIpO3JldHVybiBSbyh0aGlzKX1jbG9zZSgpe2lmKCF6ZSh0aGlzKSl0aHJvdyBfdChcImNsb3NlXCIpO2lmKHRoaXMuX2Nsb3NlUmVxdWVzdGVkKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkOyBkbyBub3QgY2xvc2UgaXQgYWdhaW4hXCIpO2NvbnN0IHQ9dGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7aWYodCE9PVwicmVhZGFibGVcIil0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3R9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCk7Z3QodGhpcyl9ZW5xdWV1ZSh0KXtpZighemUodGhpcykpdGhyb3cgX3QoXCJlbnF1ZXVlXCIpO2lmKFNlKHQsMSxcImVucXVldWVcIiksIUFycmF5QnVmZmVyLmlzVmlldyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2h1bmsgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlld1wiKTtpZih0LmJ5dGVMZW5ndGg9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjaHVuayBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aFwiKTtpZih0LmJ1ZmZlci5ieXRlTGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhcIik7aWYodGhpcy5fY2xvc2VSZXF1ZXN0ZWQpdGhyb3cgbmV3IFR5cGVFcnJvcihcInN0cmVhbSBpcyBjbG9zZWQgb3IgZHJhaW5pbmdcIik7Y29uc3Qgcj10aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9zdGF0ZTtpZihyIT09XCJyZWFkYWJsZVwiKXRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBzdHJlYW0gKGluICR7cn0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgcmVhZGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBlbnF1ZXVlZCB0b2ApO050KHRoaXMsdCl9ZXJyb3IodD12b2lkIDApe2lmKCF6ZSh0aGlzKSl0aHJvdyBfdChcImVycm9yXCIpO0sodGhpcyx0KX1bQXJdKHQpe2hvKHRoaXMpLEJlKHRoaXMpO2NvbnN0IHI9dGhpcy5fY2FuY2VsQWxnb3JpdGhtKHQpO3JldHVybiB4dCh0aGlzKSxyfVtCcl0odCl7Y29uc3Qgcj10aGlzLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO2lmKHRoaXMuX3F1ZXVlVG90YWxTaXplPjApe3dvKHRoaXMsdCk7cmV0dXJufWNvbnN0IHM9dGhpcy5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplO2lmKHMhPT12b2lkIDApe2xldCBmO3RyeXtmPW5ldyBBcnJheUJ1ZmZlcihzKX1jYXRjaChkKXt0Ll9lcnJvclN0ZXBzKGQpO3JldHVybn1jb25zdCBjPXtidWZmZXI6ZixidWZmZXJCeXRlTGVuZ3RoOnMsYnl0ZU9mZnNldDowLGJ5dGVMZW5ndGg6cyxieXRlc0ZpbGxlZDowLG1pbmltdW1GaWxsOjEsZWxlbWVudFNpemU6MSx2aWV3Q29uc3RydWN0b3I6VWludDhBcnJheSxyZWFkZXJUeXBlOlwiZGVmYXVsdFwifTt0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2goYyl9ZW8ocix0KSxJZSh0aGlzKX1ba3JdKCl7aWYodGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MCl7Y29uc3QgdD10aGlzLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTt0LnJlYWRlclR5cGU9XCJub25lXCIsdGhpcy5fcGVuZGluZ1B1bGxJbnRvcz1uZXcgRCx0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2godCl9fX07bihfbixcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcIik7bGV0IHRlPV9uO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRlLnByb3RvdHlwZSx7Y2xvc2U6e2VudW1lcmFibGU6ITB9LGVucXVldWU6e2VudW1lcmFibGU6ITB9LGVycm9yOntlbnVtZXJhYmxlOiEwfSxieW9iUmVxdWVzdDp7ZW51bWVyYWJsZTohMH0sZGVzaXJlZFNpemU6e2VudW1lcmFibGU6ITB9fSksaCh0ZS5wcm90b3R5cGUuY2xvc2UsXCJjbG9zZVwiKSxoKHRlLnByb3RvdHlwZS5lbnF1ZXVlLFwiZW5xdWV1ZVwiKSxoKHRlLnByb3RvdHlwZS5lcnJvcixcImVycm9yXCIpLHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PVwic3ltYm9sXCImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0ZS5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcIixjb25maWd1cmFibGU6ITB9KTtmdW5jdGlvbiB6ZShlKXtyZXR1cm4hbChlKXx8IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW1cIik/ITE6ZSBpbnN0YW5jZW9mIHRlfW4oemUsXCJJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJcIik7ZnVuY3Rpb24gSHIoZSl7cmV0dXJuIWwoZSl8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclwiKT8hMTplIGluc3RhbmNlb2YgUmV9bihIcixcIklzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdFwiKTtmdW5jdGlvbiBJZShlKXtpZighaWEoZSkpcmV0dXJuO2lmKGUuX3B1bGxpbmcpe2UuX3B1bGxBZ2Fpbj0hMDtyZXR1cm59ZS5fcHVsbGluZz0hMDtjb25zdCByPWUuX3B1bGxBbGdvcml0aG0oKTtfKHIsKCk9PihlLl9wdWxsaW5nPSExLGUuX3B1bGxBZ2FpbiYmKGUuX3B1bGxBZ2Fpbj0hMSxJZShlKSksbnVsbCkscz0+KEsoZSxzKSxudWxsKSl9bihJZSxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkXCIpO2Z1bmN0aW9uIGhvKGUpe1FyKGUpLGUuX3BlbmRpbmdQdWxsSW50b3M9bmV3IER9bihobyxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3NcIik7ZnVuY3Rpb24gVnIoZSx0KXtsZXQgcj0hMTtlLl9zdGF0ZT09PVwiY2xvc2VkXCImJihyPSEwKTtjb25zdCBzPXBvKHQpO3QucmVhZGVyVHlwZT09PVwiZGVmYXVsdFwiP0xyKGUscyxyKTpjYShlLHMscil9bihWcixcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3JcIik7ZnVuY3Rpb24gcG8oZSl7Y29uc3QgdD1lLmJ5dGVzRmlsbGVkLHI9ZS5lbGVtZW50U2l6ZTtyZXR1cm4gbmV3IGUudmlld0NvbnN0cnVjdG9yKGUuYnVmZmVyLGUuYnl0ZU9mZnNldCx0L3IpfW4ocG8sXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvclwiKTtmdW5jdGlvbiBVdChlLHQscixzKXtlLl9xdWV1ZS5wdXNoKHtidWZmZXI6dCxieXRlT2Zmc2V0OnIsYnl0ZUxlbmd0aDpzfSksZS5fcXVldWVUb3RhbFNpemUrPXN9bihVdCxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlXCIpO2Z1bmN0aW9uIGJvKGUsdCxyLHMpe2xldCBmO3RyeXtmPWxvKHQscixyK3MpfWNhdGNoKGMpe3Rocm93IEsoZSxjKSxjfVV0KGUsZiwwLHMpfW4oYm8sXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNsb25lZENodW5rVG9RdWV1ZVwiKTtmdW5jdGlvbiBtbyhlLHQpe3QuYnl0ZXNGaWxsZWQ+MCYmYm8oZSx0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlc0ZpbGxlZCksWWUoZSl9bihtbyxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlRGV0YWNoZWRQdWxsSW50b1RvUXVldWVcIik7ZnVuY3Rpb24geW8oZSx0KXtjb25zdCByPU1hdGgubWluKGUuX3F1ZXVlVG90YWxTaXplLHQuYnl0ZUxlbmd0aC10LmJ5dGVzRmlsbGVkKSxzPXQuYnl0ZXNGaWxsZWQrcjtsZXQgZj1yLGM9ITE7Y29uc3QgZD1zJXQuZWxlbWVudFNpemUsbT1zLWQ7bT49dC5taW5pbXVtRmlsbCYmKGY9bS10LmJ5dGVzRmlsbGVkLGM9ITApO2NvbnN0IFI9ZS5fcXVldWU7Zm9yKDtmPjA7KXtjb25zdCB5PVIucGVlaygpLEM9TWF0aC5taW4oZix5LmJ5dGVMZW5ndGgpLFA9dC5ieXRlT2Zmc2V0K3QuYnl0ZXNGaWxsZWQ7c28odC5idWZmZXIsUCx5LmJ1ZmZlcix5LmJ5dGVPZmZzZXQsQykseS5ieXRlTGVuZ3RoPT09Qz9SLnNoaWZ0KCk6KHkuYnl0ZU9mZnNldCs9Qyx5LmJ5dGVMZW5ndGgtPUMpLGUuX3F1ZXVlVG90YWxTaXplLT1DLGdvKGUsQyx0KSxmLT1DfXJldHVybiBjfW4oeW8sXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZVwiKTtmdW5jdGlvbiBnbyhlLHQscil7ci5ieXRlc0ZpbGxlZCs9dH1uKGdvLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yXCIpO2Z1bmN0aW9uIF9vKGUpe2UuX3F1ZXVlVG90YWxTaXplPT09MCYmZS5fY2xvc2VSZXF1ZXN0ZWQ/KHh0KGUpLFB0KGUuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0pKTpJZShlKX1uKF9vLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW5cIik7ZnVuY3Rpb24gUXIoZSl7ZS5fYnlvYlJlcXVlc3QhPT1udWxsJiYoZS5fYnlvYlJlcXVlc3QuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyPXZvaWQgMCxlLl9ieW9iUmVxdWVzdC5fdmlldz1udWxsLGUuX2J5b2JSZXF1ZXN0PW51bGwpfW4oUXIsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0XCIpO2Z1bmN0aW9uIFlyKGUpe2Zvcig7ZS5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MDspe2lmKGUuX3F1ZXVlVG90YWxTaXplPT09MClyZXR1cm47Y29uc3QgdD1lLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTt5byhlLHQpJiYoWWUoZSksVnIoZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSx0KSl9fW4oWXIsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlXCIpO2Z1bmN0aW9uIHRhKGUpe2NvbnN0IHQ9ZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fcmVhZGVyO2Zvcig7dC5fcmVhZFJlcXVlc3RzLmxlbmd0aD4wOyl7aWYoZS5fcXVldWVUb3RhbFNpemU9PT0wKXJldHVybjtjb25zdCByPXQuX3JlYWRSZXF1ZXN0cy5zaGlmdCgpO3dvKGUscil9fW4odGEsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1JlYWRSZXF1ZXN0c1VzaW5nUXVldWVcIik7ZnVuY3Rpb24gcmEoZSx0LHIscyl7Y29uc3QgZj1lLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLGM9dC5jb25zdHJ1Y3RvcixkPWVhKGMpLHtieXRlT2Zmc2V0Om0sYnl0ZUxlbmd0aDpSfT10LHk9cipkO2xldCBDO3RyeXtDPXdlKHQuYnVmZmVyKX1jYXRjaChCKXtzLl9lcnJvclN0ZXBzKEIpO3JldHVybn1jb25zdCBQPXtidWZmZXI6QyxidWZmZXJCeXRlTGVuZ3RoOkMuYnl0ZUxlbmd0aCxieXRlT2Zmc2V0Om0sYnl0ZUxlbmd0aDpSLGJ5dGVzRmlsbGVkOjAsbWluaW11bUZpbGw6eSxlbGVtZW50U2l6ZTpkLHZpZXdDb25zdHJ1Y3RvcjpjLHJlYWRlclR5cGU6XCJieW9iXCJ9O2lmKGUuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjApe2UuX3BlbmRpbmdQdWxsSW50b3MucHVzaChQKSxQbyhmLHMpO3JldHVybn1pZihmLl9zdGF0ZT09PVwiY2xvc2VkXCIpe2NvbnN0IEI9bmV3IGMoUC5idWZmZXIsUC5ieXRlT2Zmc2V0LDApO3MuX2Nsb3NlU3RlcHMoQik7cmV0dXJufWlmKGUuX3F1ZXVlVG90YWxTaXplPjApe2lmKHlvKGUsUCkpe2NvbnN0IEI9cG8oUCk7X28oZSkscy5fY2h1bmtTdGVwcyhCKTtyZXR1cm59aWYoZS5fY2xvc2VSZXF1ZXN0ZWQpe2NvbnN0IEI9bmV3IFR5cGVFcnJvcihcIkluc3VmZmljaWVudCBieXRlcyB0byBmaWxsIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBidWZmZXJcIik7SyhlLEIpLHMuX2Vycm9yU3RlcHMoQik7cmV0dXJufX1lLl9wZW5kaW5nUHVsbEludG9zLnB1c2goUCksUG8oZixzKSxJZShlKX1uKHJhLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvXCIpO2Z1bmN0aW9uIG5hKGUsdCl7dC5yZWFkZXJUeXBlPT09XCJub25lXCImJlllKGUpO2NvbnN0IHI9ZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtpZihLcihyKSlmb3IoO3ZvKHIpPjA7KXtjb25zdCBzPVllKGUpO1ZyKHIscyl9fW4obmEsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGVcIik7ZnVuY3Rpb24gb2EoZSx0LHIpe2lmKGdvKGUsdCxyKSxyLnJlYWRlclR5cGU9PT1cIm5vbmVcIil7bW8oZSxyKSxZcihlKTtyZXR1cm59aWYoci5ieXRlc0ZpbGxlZDxyLm1pbmltdW1GaWxsKXJldHVybjtZZShlKTtjb25zdCBzPXIuYnl0ZXNGaWxsZWQlci5lbGVtZW50U2l6ZTtpZihzPjApe2NvbnN0IGY9ci5ieXRlT2Zmc2V0K3IuYnl0ZXNGaWxsZWQ7Ym8oZSxyLmJ1ZmZlcixmLXMscyl9ci5ieXRlc0ZpbGxlZC09cyxWcihlLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLHIpLFlyKGUpfW4ob2EsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZVwiKTtmdW5jdGlvbiBTbyhlLHQpe2NvbnN0IHI9ZS5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7UXIoZSksZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU9PT1cImNsb3NlZFwiP25hKGUscik6b2EoZSx0LHIpLEllKGUpfW4oU28sXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsXCIpO2Z1bmN0aW9uIFllKGUpe3JldHVybiBlLl9wZW5kaW5nUHVsbEludG9zLnNoaWZ0KCl9bihZZSxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50b1wiKTtmdW5jdGlvbiBpYShlKXtjb25zdCB0PWUuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07cmV0dXJuIHQuX3N0YXRlIT09XCJyZWFkYWJsZVwifHxlLl9jbG9zZVJlcXVlc3RlZHx8IWUuX3N0YXJ0ZWQ/ITE6ISEodG8odCkmJkx0KHQpPjB8fEtyKHQpJiZ2byh0KT4wfHxSbyhlKT4wKX1uKGlhLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsXCIpO2Z1bmN0aW9uIHh0KGUpe2UuX3B1bGxBbGdvcml0aG09dm9pZCAwLGUuX2NhbmNlbEFsZ29yaXRobT12b2lkIDB9bih4dCxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXNcIik7ZnVuY3Rpb24gZ3QoZSl7Y29uc3QgdD1lLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO2lmKCEoZS5fY2xvc2VSZXF1ZXN0ZWR8fHQuX3N0YXRlIT09XCJyZWFkYWJsZVwiKSl7aWYoZS5fcXVldWVUb3RhbFNpemU+MCl7ZS5fY2xvc2VSZXF1ZXN0ZWQ9ITA7cmV0dXJufWlmKGUuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjApe2NvbnN0IHI9ZS5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7aWYoci5ieXRlc0ZpbGxlZCVyLmVsZW1lbnRTaXplIT09MCl7Y29uc3Qgcz1uZXcgVHlwZUVycm9yKFwiSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlclwiKTt0aHJvdyBLKGUscyksc319eHQoZSksUHQodCl9fW4oZ3QsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2VcIik7ZnVuY3Rpb24gTnQoZSx0KXtjb25zdCByPWUuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07aWYoZS5fY2xvc2VSZXF1ZXN0ZWR8fHIuX3N0YXRlIT09XCJyZWFkYWJsZVwiKXJldHVybjtjb25zdHtidWZmZXI6cyxieXRlT2Zmc2V0OmYsYnl0ZUxlbmd0aDpjfT10O2lmKEFlKHMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJjaHVuaydzIGJ1ZmZlciBpcyBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIGVucXVldWVkXCIpO2NvbnN0IGQ9d2Uocyk7aWYoZS5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MCl7Y29uc3QgbT1lLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtpZihBZShtLmJ1ZmZlcikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBCWU9CIHJlcXVlc3QncyBidWZmZXIgaGFzIGJlZW4gZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSBmaWxsZWQgd2l0aCBhbiBlbnF1ZXVlZCBjaHVua1wiKTtRcihlKSxtLmJ1ZmZlcj13ZShtLmJ1ZmZlciksbS5yZWFkZXJUeXBlPT09XCJub25lXCImJm1vKGUsbSl9aWYodG8ocikpaWYodGEoZSksTHQocik9PT0wKVV0KGUsZCxmLGMpO2Vsc2V7ZS5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MCYmWWUoZSk7Y29uc3QgbT1uZXcgVWludDhBcnJheShkLGYsYyk7THIocixtLCExKX1lbHNlIEtyKHIpPyhVdChlLGQsZixjKSxZcihlKSk6VXQoZSxkLGYsYyk7SWUoZSl9bihOdCxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlXCIpO2Z1bmN0aW9uIEsoZSx0KXtjb25zdCByPWUuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07ci5fc3RhdGU9PT1cInJlYWRhYmxlXCImJihobyhlKSxCZShlKSx4dChlKSxabyhyLHQpKX1uKEssXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3JcIik7ZnVuY3Rpb24gd28oZSx0KXtjb25zdCByPWUuX3F1ZXVlLnNoaWZ0KCk7ZS5fcXVldWVUb3RhbFNpemUtPXIuYnl0ZUxlbmd0aCxfbyhlKTtjb25zdCBzPW5ldyBVaW50OEFycmF5KHIuYnVmZmVyLHIuYnl0ZU9mZnNldCxyLmJ5dGVMZW5ndGgpO3QuX2NodW5rU3RlcHMocyl9bih3byxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUmVhZFJlcXVlc3RGcm9tUXVldWVcIik7ZnVuY3Rpb24gR3IoZSl7aWYoZS5fYnlvYlJlcXVlc3Q9PT1udWxsJiZlLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aD4wKXtjb25zdCB0PWUuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpLHI9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0K3QuYnl0ZXNGaWxsZWQsdC5ieXRlTGVuZ3RoLXQuYnl0ZXNGaWxsZWQpLHM9T2JqZWN0LmNyZWF0ZShSZS5wcm90b3R5cGUpO3NhKHMsZSxyKSxlLl9ieW9iUmVxdWVzdD1zfXJldHVybiBlLl9ieW9iUmVxdWVzdH1uKEdyLFwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0XCIpO2Z1bmN0aW9uIFJvKGUpe2NvbnN0IHQ9ZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7cmV0dXJuIHQ9PT1cImVycm9yZWRcIj9udWxsOnQ9PT1cImNsb3NlZFwiPzA6ZS5fc3RyYXRlZ3lIV00tZS5fcXVldWVUb3RhbFNpemV9bihSbyxcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZVwiKTtmdW5jdGlvbiBIdChlLHQpe2NvbnN0IHI9ZS5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7aWYoZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU9PT1cImNsb3NlZFwiKXtpZih0IT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYnl0ZXNXcml0dGVuIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgY2xvc2VkIHN0cmVhbVwiKX1lbHNle2lmKHQ9PT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJieXRlc1dyaXR0ZW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgcmVhZGFibGUgc3RyZWFtXCIpO2lmKHIuYnl0ZXNGaWxsZWQrdD5yLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJieXRlc1dyaXR0ZW4gb3V0IG9mIHJhbmdlXCIpfXIuYnVmZmVyPXdlKHIuYnVmZmVyKSxTbyhlLHQpfW4oSHQsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFwiKTtmdW5jdGlvbiBWdChlLHQpe2NvbnN0IHI9ZS5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7aWYoZS5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU9PT1cImNsb3NlZFwiKXtpZih0LmJ5dGVMZW5ndGghPT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgdmlldydzIGxlbmd0aCBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgY2xvc2VkIHN0cmVhbVwiKX1lbHNlIGlmKHQuYnl0ZUxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSB2aWV3J3MgbGVuZ3RoIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgcmVhZGFibGUgc3RyZWFtXCIpO2lmKHIuYnl0ZU9mZnNldCtyLmJ5dGVzRmlsbGVkIT09dC5ieXRlT2Zmc2V0KXRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBkb2VzIG5vdCBtYXRjaCBieW9iUmVxdWVzdFwiKTtpZihyLmJ1ZmZlckJ5dGVMZW5ndGghPT10LmJ1ZmZlci5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIGJ1ZmZlciBvZiB2aWV3IGhhcyBkaWZmZXJlbnQgY2FwYWNpdHkgdGhhbiBieW9iUmVxdWVzdFwiKTtpZihyLmJ5dGVzRmlsbGVkK3QuYnl0ZUxlbmd0aD5yLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgcmVnaW9uIHNwZWNpZmllZCBieSB2aWV3IGlzIGxhcmdlciB0aGFuIGJ5b2JSZXF1ZXN0XCIpO2NvbnN0IGY9dC5ieXRlTGVuZ3RoO3IuYnVmZmVyPXdlKHQuYnVmZmVyKSxTbyhlLGYpfW4oVnQsXCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3XCIpO2Z1bmN0aW9uIFRvKGUsdCxyLHMsZixjLGQpe3QuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW09ZSx0Ll9wdWxsQWdhaW49ITEsdC5fcHVsbGluZz0hMSx0Ll9ieW9iUmVxdWVzdD1udWxsLHQuX3F1ZXVlPXQuX3F1ZXVlVG90YWxTaXplPXZvaWQgMCxCZSh0KSx0Ll9jbG9zZVJlcXVlc3RlZD0hMSx0Ll9zdGFydGVkPSExLHQuX3N0cmF0ZWd5SFdNPWMsdC5fcHVsbEFsZ29yaXRobT1zLHQuX2NhbmNlbEFsZ29yaXRobT1mLHQuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZT1kLHQuX3BlbmRpbmdQdWxsSW50b3M9bmV3IEQsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyPXQ7Y29uc3QgbT1yKCk7XyhUKG0pLCgpPT4odC5fc3RhcnRlZD0hMCxJZSh0KSxudWxsKSxSPT4oSyh0LFIpLG51bGwpKX1uKFRvLFwiU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXCIpO2Z1bmN0aW9uIGFhKGUsdCxyKXtjb25zdCBzPU9iamVjdC5jcmVhdGUodGUucHJvdG90eXBlKTtsZXQgZixjLGQ7dC5zdGFydCE9PXZvaWQgMD9mPW4oKCk9PnQuc3RhcnQocyksXCJzdGFydEFsZ29yaXRobVwiKTpmPW4oKCk9Pnt9LFwic3RhcnRBbGdvcml0aG1cIiksdC5wdWxsIT09dm9pZCAwP2M9bigoKT0+dC5wdWxsKHMpLFwicHVsbEFsZ29yaXRobVwiKTpjPW4oKCk9PlQodm9pZCAwKSxcInB1bGxBbGdvcml0aG1cIiksdC5jYW5jZWwhPT12b2lkIDA/ZD1uKFI9PnQuY2FuY2VsKFIpLFwiY2FuY2VsQWxnb3JpdGhtXCIpOmQ9bigoKT0+VCh2b2lkIDApLFwiY2FuY2VsQWxnb3JpdGhtXCIpO2NvbnN0IG09dC5hdXRvQWxsb2NhdGVDaHVua1NpemU7aWYobT09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcImF1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1RvKGUscyxmLGMsZCxyLG0pfW4oYWEsXCJTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZVwiKTtmdW5jdGlvbiBzYShlLHQscil7ZS5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI9dCxlLl92aWV3PXJ9bihzYSxcIlNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdFwiKTtmdW5jdGlvbiBacihlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdGApfW4oWnIsXCJieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb25cIik7ZnVuY3Rpb24gX3QoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLiR7ZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJgKX1uKF90LFwiYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uXCIpO2Z1bmN0aW9uIGxhKGUsdCl7dWUoZSx0KTtjb25zdCByPWU/Lm1vZGU7cmV0dXJue21vZGU6cj09PXZvaWQgMD92b2lkIDA6dWEocixgJHt0fSBoYXMgbWVtYmVyICdtb2RlJyB0aGF0YCl9fW4obGEsXCJjb252ZXJ0UmVhZGVyT3B0aW9uc1wiKTtmdW5jdGlvbiB1YShlLHQpe2lmKGU9YCR7ZX1gLGUhPT1cImJ5b2JcIil0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9ICcke2V9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlYCk7cmV0dXJuIGV9bih1YSxcImNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGVcIik7ZnVuY3Rpb24gZmEoZSx0KXt2YXIgcjt1ZShlLHQpO2NvbnN0IHM9KHI9ZT8ubWluKSE9PW51bGwmJnIhPT12b2lkIDA/cjoxO3JldHVybnttaW46RnIocyxgJHt0fSBoYXMgbWVtYmVyICdtaW4nIHRoYXRgKX19bihmYSxcImNvbnZlcnRCeW9iUmVhZE9wdGlvbnNcIik7ZnVuY3Rpb24gQ28oZSl7cmV0dXJuIG5ldyBjZShlKX1uKENvLFwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclwiKTtmdW5jdGlvbiBQbyhlLHQpe2UuX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5wdXNoKHQpfW4oUG8sXCJSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdFwiKTtmdW5jdGlvbiBjYShlLHQscil7Y29uc3QgZj1lLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKTtyP2YuX2Nsb3NlU3RlcHModCk6Zi5fY2h1bmtTdGVwcyh0KX1uKGNhLFwiUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0XCIpO2Z1bmN0aW9uIHZvKGUpe3JldHVybiBlLl9yZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMubGVuZ3RofW4odm8sXCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHNcIik7ZnVuY3Rpb24gS3IoZSl7Y29uc3QgdD1lLl9yZWFkZXI7cmV0dXJuISh0PT09dm9pZCAwfHwhRmUodCkpfW4oS3IsXCJSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXJcIik7Y29uc3QgU249Y2xhc3MgU257Y29uc3RydWN0b3IodCl7aWYoU2UodCwxLFwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXCIpLGpyKHQsXCJGaXJzdCBwYXJhbWV0ZXJcIikscWUodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlclwiKTtpZighemUodC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnN0cnVjdCBhIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBmb3IgYSBzdHJlYW0gbm90IGNvbnN0cnVjdGVkIHdpdGggYSBieXRlIHNvdXJjZVwiKTtZbih0aGlzLHQpLHRoaXMuX3JlYWRJbnRvUmVxdWVzdHM9bmV3IER9Z2V0IGNsb3NlZCgpe3JldHVybiBGZSh0aGlzKT90aGlzLl9jbG9zZWRQcm9taXNlOmIoUXQoXCJjbG9zZWRcIikpfWNhbmNlbCh0PXZvaWQgMCl7cmV0dXJuIEZlKHRoaXMpP3RoaXMuX293bmVyUmVhZGFibGVTdHJlYW09PT12b2lkIDA/YihqdChcImNhbmNlbFwiKSk6V3IodGhpcyx0KTpiKFF0KFwiY2FuY2VsXCIpKX1yZWFkKHQscj17fSl7aWYoIUZlKHRoaXMpKXJldHVybiBiKFF0KFwicmVhZFwiKSk7aWYoIUFycmF5QnVmZmVyLmlzVmlldyh0KSlyZXR1cm4gYihuZXcgVHlwZUVycm9yKFwidmlldyBtdXN0IGJlIGFuIGFycmF5IGJ1ZmZlciB2aWV3XCIpKTtpZih0LmJ5dGVMZW5ndGg9PT0wKXJldHVybiBiKG5ldyBUeXBlRXJyb3IoXCJ2aWV3IG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoXCIpKTtpZih0LmJ1ZmZlci5ieXRlTGVuZ3RoPT09MClyZXR1cm4gYihuZXcgVHlwZUVycm9yKFwidmlldydzIGJ1ZmZlciBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aFwiKSk7aWYoQWUodC5idWZmZXIpKXJldHVybiBiKG5ldyBUeXBlRXJyb3IoXCJ2aWV3J3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkXCIpKTtsZXQgczt0cnl7cz1mYShyLFwib3B0aW9uc1wiKX1jYXRjaCh5KXtyZXR1cm4gYih5KX1jb25zdCBmPXMubWluO2lmKGY9PT0wKXJldHVybiBiKG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zLm1pbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpKTtpZihYaSh0KSl7aWYoZj50LmJ5dGVMZW5ndGgpcmV0dXJuIGIobmV3IFJhbmdlRXJyb3IoXCJvcHRpb25zLm1pbiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB2aWV3J3MgYnl0ZUxlbmd0aFwiKSl9ZWxzZSBpZihmPnQubGVuZ3RoKXJldHVybiBiKG5ldyBSYW5nZUVycm9yKFwib3B0aW9ucy5taW4gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdmlldydzIGxlbmd0aFwiKSk7aWYodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbT09PXZvaWQgMClyZXR1cm4gYihqdChcInJlYWQgZnJvbVwiKSk7bGV0IGMsZDtjb25zdCBtPUUoKHksQyk9PntjPXksZD1DfSk7cmV0dXJuIEVvKHRoaXMsdCxmLHtfY2h1bmtTdGVwczp5PT5jKHt2YWx1ZTp5LGRvbmU6ITF9KSxfY2xvc2VTdGVwczp5PT5jKHt2YWx1ZTp5LGRvbmU6ITB9KSxfZXJyb3JTdGVwczp5PT5kKHkpfSksbX1yZWxlYXNlTG9jaygpe2lmKCFGZSh0aGlzKSl0aHJvdyBRdChcInJlbGVhc2VMb2NrXCIpO3RoaXMuX293bmVyUmVhZGFibGVTdHJlYW0hPT12b2lkIDAmJmRhKHRoaXMpfX07bihTbixcIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclwiKTtsZXQgY2U9U247T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY2UucHJvdG90eXBlLHtjYW5jZWw6e2VudW1lcmFibGU6ITB9LHJlYWQ6e2VudW1lcmFibGU6ITB9LHJlbGVhc2VMb2NrOntlbnVtZXJhYmxlOiEwfSxjbG9zZWQ6e2VudW1lcmFibGU6ITB9fSksaChjZS5wcm90b3R5cGUuY2FuY2VsLFwiY2FuY2VsXCIpLGgoY2UucHJvdG90eXBlLnJlYWQsXCJyZWFkXCIpLGgoY2UucHJvdG90eXBlLnJlbGVhc2VMb2NrLFwicmVsZWFzZUxvY2tcIiksdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGNlLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyXCIsY29uZmlndXJhYmxlOiEwfSk7ZnVuY3Rpb24gRmUoZSl7cmV0dXJuIWwoZSl8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl9yZWFkSW50b1JlcXVlc3RzXCIpPyExOmUgaW5zdGFuY2VvZiBjZX1uKEZlLFwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJcIik7ZnVuY3Rpb24gRW8oZSx0LHIscyl7Y29uc3QgZj1lLl9vd25lclJlYWRhYmxlU3RyZWFtO2YuX2Rpc3R1cmJlZD0hMCxmLl9zdGF0ZT09PVwiZXJyb3JlZFwiP3MuX2Vycm9yU3RlcHMoZi5fc3RvcmVkRXJyb3IpOnJhKGYuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcix0LHIscyl9bihFbyxcIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWRcIik7ZnVuY3Rpb24gZGEoZSl7X2UoZSk7Y29uc3QgdD1uZXcgVHlwZUVycm9yKFwiUmVhZGVyIHdhcyByZWxlYXNlZFwiKTtBbyhlLHQpfW4oZGEsXCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWxlYXNlXCIpO2Z1bmN0aW9uIEFvKGUsdCl7Y29uc3Qgcj1lLl9yZWFkSW50b1JlcXVlc3RzO2UuX3JlYWRJbnRvUmVxdWVzdHM9bmV3IEQsci5mb3JFYWNoKHM9PntzLl9lcnJvclN0ZXBzKHQpfSl9bihBbyxcIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlckVycm9yUmVhZEludG9SZXF1ZXN0c1wiKTtmdW5jdGlvbiBRdChlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJgKX1uKFF0LFwiYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb25cIik7ZnVuY3Rpb24gU3QoZSx0KXtjb25zdHtoaWdoV2F0ZXJNYXJrOnJ9PWU7aWYocj09PXZvaWQgMClyZXR1cm4gdDtpZihhbyhyKXx8cjwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBoaWdoV2F0ZXJNYXJrXCIpO3JldHVybiByfW4oU3QsXCJFeHRyYWN0SGlnaFdhdGVyTWFya1wiKTtmdW5jdGlvbiBZdChlKXtjb25zdHtzaXplOnR9PWU7cmV0dXJuIHR8fCgoKT0+MSl9bihZdCxcIkV4dHJhY3RTaXplQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIEd0KGUsdCl7dWUoZSx0KTtjb25zdCByPWU/LmhpZ2hXYXRlck1hcmsscz1lPy5zaXplO3JldHVybntoaWdoV2F0ZXJNYXJrOnI9PT12b2lkIDA/dm9pZCAwOklyKHIpLHNpemU6cz09PXZvaWQgMD92b2lkIDA6aGEocyxgJHt0fSBoYXMgbWVtYmVyICdzaXplJyB0aGF0YCl9fW4oR3QsXCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5XCIpO2Z1bmN0aW9uIGhhKGUsdCl7cmV0dXJuIFooZSx0KSxyPT5JcihlKHIpKX1uKGhhLFwiY29udmVydFF1ZXVpbmdTdHJhdGVneVNpemVcIik7ZnVuY3Rpb24gcGEoZSx0KXt1ZShlLHQpO2NvbnN0IHI9ZT8uYWJvcnQscz1lPy5jbG9zZSxmPWU/LnN0YXJ0LGM9ZT8udHlwZSxkPWU/LndyaXRlO3JldHVybnthYm9ydDpyPT09dm9pZCAwP3ZvaWQgMDpiYShyLGUsYCR7dH0gaGFzIG1lbWJlciAnYWJvcnQnIHRoYXRgKSxjbG9zZTpzPT09dm9pZCAwP3ZvaWQgMDptYShzLGUsYCR7dH0gaGFzIG1lbWJlciAnY2xvc2UnIHRoYXRgKSxzdGFydDpmPT09dm9pZCAwP3ZvaWQgMDp5YShmLGUsYCR7dH0gaGFzIG1lbWJlciAnc3RhcnQnIHRoYXRgKSx3cml0ZTpkPT09dm9pZCAwP3ZvaWQgMDpnYShkLGUsYCR7dH0gaGFzIG1lbWJlciAnd3JpdGUnIHRoYXRgKSx0eXBlOmN9fW4ocGEsXCJjb252ZXJ0VW5kZXJseWluZ1NpbmtcIik7ZnVuY3Rpb24gYmEoZSx0LHIpe3JldHVybiBaKGUscikscz0+aihlLHQsW3NdKX1uKGJhLFwiY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFja1wiKTtmdW5jdGlvbiBtYShlLHQscil7cmV0dXJuIFooZSxyKSwoKT0+aihlLHQsW10pfW4obWEsXCJjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrXCIpO2Z1bmN0aW9uIHlhKGUsdCxyKXtyZXR1cm4gWihlLHIpLHM9PnooZSx0LFtzXSl9bih5YSxcImNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2tcIik7ZnVuY3Rpb24gZ2EoZSx0LHIpe3JldHVybiBaKGUsciksKHMsZik9PmooZSx0LFtzLGZdKX1uKGdhLFwiY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFja1wiKTtmdW5jdGlvbiBCbyhlLHQpe2lmKCFHZShlKSl0aHJvdyBuZXcgVHlwZUVycm9yKGAke3R9IGlzIG5vdCBhIFdyaXRhYmxlU3RyZWFtLmApfW4oQm8sXCJhc3NlcnRXcml0YWJsZVN0cmVhbVwiKTtmdW5jdGlvbiBfYShlKXtpZih0eXBlb2YgZSE9XCJvYmplY3RcInx8ZT09PW51bGwpcmV0dXJuITE7dHJ5e3JldHVybiB0eXBlb2YgZS5hYm9ydGVkPT1cImJvb2xlYW5cIn1jYXRjaHtyZXR1cm4hMX19bihfYSxcImlzQWJvcnRTaWduYWxcIik7Y29uc3QgU2E9dHlwZW9mIEFib3J0Q29udHJvbGxlcj09XCJmdW5jdGlvblwiO2Z1bmN0aW9uIHdhKCl7aWYoU2EpcmV0dXJuIG5ldyBBYm9ydENvbnRyb2xsZXJ9bih3YSxcImNyZWF0ZUFib3J0Q29udHJvbGxlclwiKTtjb25zdCB3bj1jbGFzcyB3bntjb25zdHJ1Y3Rvcih0PXt9LHI9e30pe3Q9PT12b2lkIDA/dD1udWxsOkpuKHQsXCJGaXJzdCBwYXJhbWV0ZXJcIik7Y29uc3Qgcz1HdChyLFwiU2Vjb25kIHBhcmFtZXRlclwiKSxmPXBhKHQsXCJGaXJzdCBwYXJhbWV0ZXJcIik7aWYoV28odGhpcyksZi50eXBlIT09dm9pZCAwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZFwiKTtjb25zdCBkPVl0KHMpLG09U3QocywxKTtJYSh0aGlzLGYsbSxkKX1nZXQgbG9ja2VkKCl7aWYoIUdlKHRoaXMpKXRocm93IGVyKFwibG9ja2VkXCIpO3JldHVybiBaZSh0aGlzKX1hYm9ydCh0PXZvaWQgMCl7cmV0dXJuIEdlKHRoaXMpP1plKHRoaXMpP2IobmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhYm9ydCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyXCIpKTpadCh0aGlzLHQpOmIoZXIoXCJhYm9ydFwiKSl9Y2xvc2UoKXtyZXR1cm4gR2UodGhpcyk/WmUodGhpcyk/YihuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNsb3NlIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSB3cml0ZXJcIikpOmhlKHRoaXMpP2IobmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtXCIpKTpxbyh0aGlzKTpiKGVyKFwiY2xvc2VcIikpfWdldFdyaXRlcigpe2lmKCFHZSh0aGlzKSl0aHJvdyBlcihcImdldFdyaXRlclwiKTtyZXR1cm4ga28odGhpcyl9fTtuKHduLFwiV3JpdGFibGVTdHJlYW1cIik7bGV0IGRlPXduO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRlLnByb3RvdHlwZSx7YWJvcnQ6e2VudW1lcmFibGU6ITB9LGNsb3NlOntlbnVtZXJhYmxlOiEwfSxnZXRXcml0ZXI6e2VudW1lcmFibGU6ITB9LGxvY2tlZDp7ZW51bWVyYWJsZTohMH19KSxoKGRlLnByb3RvdHlwZS5hYm9ydCxcImFib3J0XCIpLGgoZGUucHJvdG90eXBlLmNsb3NlLFwiY2xvc2VcIiksaChkZS5wcm90b3R5cGUuZ2V0V3JpdGVyLFwiZ2V0V3JpdGVyXCIpLHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PVwic3ltYm9sXCImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZS5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIldyaXRhYmxlU3RyZWFtXCIsY29uZmlndXJhYmxlOiEwfSk7ZnVuY3Rpb24ga28oZSl7cmV0dXJuIG5ldyByZShlKX1uKGtvLFwiQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclwiKTtmdW5jdGlvbiBSYShlLHQscixzLGY9MSxjPSgpPT4xKXtjb25zdCBkPU9iamVjdC5jcmVhdGUoZGUucHJvdG90eXBlKTtXbyhkKTtjb25zdCBtPU9iamVjdC5jcmVhdGUoa2UucHJvdG90eXBlKTtyZXR1cm4gTG8oZCxtLGUsdCxyLHMsZixjKSxkfW4oUmEsXCJDcmVhdGVXcml0YWJsZVN0cmVhbVwiKTtmdW5jdGlvbiBXbyhlKXtlLl9zdGF0ZT1cIndyaXRhYmxlXCIsZS5fc3RvcmVkRXJyb3I9dm9pZCAwLGUuX3dyaXRlcj12b2lkIDAsZS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyPXZvaWQgMCxlLl93cml0ZVJlcXVlc3RzPW5ldyBELGUuX2luRmxpZ2h0V3JpdGVSZXF1ZXN0PXZvaWQgMCxlLl9jbG9zZVJlcXVlc3Q9dm9pZCAwLGUuX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0PXZvaWQgMCxlLl9wZW5kaW5nQWJvcnRSZXF1ZXN0PXZvaWQgMCxlLl9iYWNrcHJlc3N1cmU9ITF9bihXbyxcIkluaXRpYWxpemVXcml0YWJsZVN0cmVhbVwiKTtmdW5jdGlvbiBHZShlKXtyZXR1cm4hbChlKXx8IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlclwiKT8hMTplIGluc3RhbmNlb2YgZGV9bihHZSxcIklzV3JpdGFibGVTdHJlYW1cIik7ZnVuY3Rpb24gWmUoZSl7cmV0dXJuIGUuX3dyaXRlciE9PXZvaWQgMH1uKFplLFwiSXNXcml0YWJsZVN0cmVhbUxvY2tlZFwiKTtmdW5jdGlvbiBadChlLHQpe3ZhciByO2lmKGUuX3N0YXRlPT09XCJjbG9zZWRcInx8ZS5fc3RhdGU9PT1cImVycm9yZWRcIilyZXR1cm4gVCh2b2lkIDApO2UuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlci5fYWJvcnRSZWFzb249dCwocj1lLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlcik9PT1udWxsfHxyPT09dm9pZCAwfHxyLmFib3J0KHQpO2NvbnN0IHM9ZS5fc3RhdGU7aWYocz09PVwiY2xvc2VkXCJ8fHM9PT1cImVycm9yZWRcIilyZXR1cm4gVCh2b2lkIDApO2lmKGUuX3BlbmRpbmdBYm9ydFJlcXVlc3QhPT12b2lkIDApcmV0dXJuIGUuX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Byb21pc2U7bGV0IGY9ITE7cz09PVwiZXJyb3JpbmdcIiYmKGY9ITAsdD12b2lkIDApO2NvbnN0IGM9RSgoZCxtKT0+e2UuX3BlbmRpbmdBYm9ydFJlcXVlc3Q9e19wcm9taXNlOnZvaWQgMCxfcmVzb2x2ZTpkLF9yZWplY3Q6bSxfcmVhc29uOnQsX3dhc0FscmVhZHlFcnJvcmluZzpmfX0pO3JldHVybiBlLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlPWMsZnx8WHIoZSx0KSxjfW4oWnQsXCJXcml0YWJsZVN0cmVhbUFib3J0XCIpO2Z1bmN0aW9uIHFvKGUpe2NvbnN0IHQ9ZS5fc3RhdGU7aWYodD09PVwiY2xvc2VkXCJ8fHQ9PT1cImVycm9yZWRcIilyZXR1cm4gYihuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3R9IHN0YXRlKSBpcyBub3QgaW4gdGhlIHdyaXRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkYCkpO2NvbnN0IHI9RSgoZixjKT0+e2NvbnN0IGQ9e19yZXNvbHZlOmYsX3JlamVjdDpjfTtlLl9jbG9zZVJlcXVlc3Q9ZH0pLHM9ZS5fd3JpdGVyO3JldHVybiBzIT09dm9pZCAwJiZlLl9iYWNrcHJlc3N1cmUmJnQ9PT1cIndyaXRhYmxlXCImJmxuKHMpLEZhKGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcikscn1uKHFvLFwiV3JpdGFibGVTdHJlYW1DbG9zZVwiKTtmdW5jdGlvbiBUYShlKXtyZXR1cm4gRSgocixzKT0+e2NvbnN0IGY9e19yZXNvbHZlOnIsX3JlamVjdDpzfTtlLl93cml0ZVJlcXVlc3RzLnB1c2goZil9KX1uKFRhLFwiV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3RcIik7ZnVuY3Rpb24gSnIoZSx0KXtpZihlLl9zdGF0ZT09PVwid3JpdGFibGVcIil7WHIoZSx0KTtyZXR1cm59ZW4oZSl9bihKcixcIldyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb25cIik7ZnVuY3Rpb24gWHIoZSx0KXtjb25zdCByPWUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtlLl9zdGF0ZT1cImVycm9yaW5nXCIsZS5fc3RvcmVkRXJyb3I9dDtjb25zdCBzPWUuX3dyaXRlcjtzIT09dm9pZCAwJiZ6byhzLHQpLCFBYShlKSYmci5fc3RhcnRlZCYmZW4oZSl9bihYcixcIldyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZ1wiKTtmdW5jdGlvbiBlbihlKXtlLl9zdGF0ZT1cImVycm9yZWRcIixlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbUW5dKCk7Y29uc3QgdD1lLl9zdG9yZWRFcnJvcjtpZihlLl93cml0ZVJlcXVlc3RzLmZvckVhY2goZj0+e2YuX3JlamVjdCh0KX0pLGUuX3dyaXRlUmVxdWVzdHM9bmV3IEQsZS5fcGVuZGluZ0Fib3J0UmVxdWVzdD09PXZvaWQgMCl7S3QoZSk7cmV0dXJufWNvbnN0IHI9ZS5fcGVuZGluZ0Fib3J0UmVxdWVzdDtpZihlLl9wZW5kaW5nQWJvcnRSZXF1ZXN0PXZvaWQgMCxyLl93YXNBbHJlYWR5RXJyb3Jpbmcpe3IuX3JlamVjdCh0KSxLdChlKTtyZXR1cm59Y29uc3Qgcz1lLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbRnRdKHIuX3JlYXNvbik7XyhzLCgpPT4oci5fcmVzb2x2ZSgpLEt0KGUpLG51bGwpLGY9PihyLl9yZWplY3QoZiksS3QoZSksbnVsbCkpfW4oZW4sXCJXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nXCIpO2Z1bmN0aW9uIENhKGUpe2UuX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZXNvbHZlKHZvaWQgMCksZS5faW5GbGlnaHRXcml0ZVJlcXVlc3Q9dm9pZCAwfW4oQ2EsXCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVcIik7ZnVuY3Rpb24gUGEoZSx0KXtlLl9pbkZsaWdodFdyaXRlUmVxdWVzdC5fcmVqZWN0KHQpLGUuX2luRmxpZ2h0V3JpdGVSZXF1ZXN0PXZvaWQgMCxKcihlLHQpfW4oUGEsXCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3JcIik7ZnVuY3Rpb24gdmEoZSl7ZS5faW5GbGlnaHRDbG9zZVJlcXVlc3QuX3Jlc29sdmUodm9pZCAwKSxlLl9pbkZsaWdodENsb3NlUmVxdWVzdD12b2lkIDAsZS5fc3RhdGU9PT1cImVycm9yaW5nXCImJihlLl9zdG9yZWRFcnJvcj12b2lkIDAsZS5fcGVuZGluZ0Fib3J0UmVxdWVzdCE9PXZvaWQgMCYmKGUuX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Jlc29sdmUoKSxlLl9wZW5kaW5nQWJvcnRSZXF1ZXN0PXZvaWQgMCkpLGUuX3N0YXRlPVwiY2xvc2VkXCI7Y29uc3Qgcj1lLl93cml0ZXI7ciE9PXZvaWQgMCYmVW8ocil9bih2YSxcIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVwiKTtmdW5jdGlvbiBFYShlLHQpe2UuX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZWplY3QodCksZS5faW5GbGlnaHRDbG9zZVJlcXVlc3Q9dm9pZCAwLGUuX3BlbmRpbmdBYm9ydFJlcXVlc3QhPT12b2lkIDAmJihlLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZWplY3QodCksZS5fcGVuZGluZ0Fib3J0UmVxdWVzdD12b2lkIDApLEpyKGUsdCl9bihFYSxcIldyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvclwiKTtmdW5jdGlvbiBoZShlKXtyZXR1cm4hKGUuX2Nsb3NlUmVxdWVzdD09PXZvaWQgMCYmZS5faW5GbGlnaHRDbG9zZVJlcXVlc3Q9PT12b2lkIDApfW4oaGUsXCJXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodFwiKTtmdW5jdGlvbiBBYShlKXtyZXR1cm4hKGUuX2luRmxpZ2h0V3JpdGVSZXF1ZXN0PT09dm9pZCAwJiZlLl9pbkZsaWdodENsb3NlUmVxdWVzdD09PXZvaWQgMCl9bihBYSxcIldyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHRcIik7ZnVuY3Rpb24gQmEoZSl7ZS5faW5GbGlnaHRDbG9zZVJlcXVlc3Q9ZS5fY2xvc2VSZXF1ZXN0LGUuX2Nsb3NlUmVxdWVzdD12b2lkIDB9bihCYSxcIldyaXRhYmxlU3RyZWFtTWFya0Nsb3NlUmVxdWVzdEluRmxpZ2h0XCIpO2Z1bmN0aW9uIGthKGUpe2UuX2luRmxpZ2h0V3JpdGVSZXF1ZXN0PWUuX3dyaXRlUmVxdWVzdHMuc2hpZnQoKX1uKGthLFwiV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodFwiKTtmdW5jdGlvbiBLdChlKXtlLl9jbG9zZVJlcXVlc3QhPT12b2lkIDAmJihlLl9jbG9zZVJlcXVlc3QuX3JlamVjdChlLl9zdG9yZWRFcnJvciksZS5fY2xvc2VSZXF1ZXN0PXZvaWQgMCk7Y29uc3QgdD1lLl93cml0ZXI7dCE9PXZvaWQgMCYmYW4odCxlLl9zdG9yZWRFcnJvcil9bihLdCxcIldyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWRcIik7ZnVuY3Rpb24gdG4oZSx0KXtjb25zdCByPWUuX3dyaXRlcjtyIT09dm9pZCAwJiZ0IT09ZS5fYmFja3ByZXNzdXJlJiYodD94YShyKTpsbihyKSksZS5fYmFja3ByZXNzdXJlPXR9bih0bixcIldyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlXCIpO2NvbnN0IFJuPWNsYXNzIFJue2NvbnN0cnVjdG9yKHQpe2lmKFNlKHQsMSxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclwiKSxCbyh0LFwiRmlyc3QgcGFyYW1ldGVyXCIpLFplKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHdyaXRpbmcgYnkgYW5vdGhlciB3cml0ZXJcIik7dGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbT10LHQuX3dyaXRlcj10aGlzO2NvbnN0IHI9dC5fc3RhdGU7aWYocj09PVwid3JpdGFibGVcIikhaGUodCkmJnQuX2JhY2twcmVzc3VyZT9ycih0aGlzKTp4byh0aGlzKSx0cih0aGlzKTtlbHNlIGlmKHI9PT1cImVycm9yaW5nXCIpc24odGhpcyx0Ll9zdG9yZWRFcnJvciksdHIodGhpcyk7ZWxzZSBpZihyPT09XCJjbG9zZWRcIil4byh0aGlzKSxNYSh0aGlzKTtlbHNle2NvbnN0IHM9dC5fc3RvcmVkRXJyb3I7c24odGhpcyxzKSxNbyh0aGlzLHMpfX1nZXQgY2xvc2VkKCl7cmV0dXJuIGplKHRoaXMpP3RoaXMuX2Nsb3NlZFByb21pc2U6YihMZShcImNsb3NlZFwiKSl9Z2V0IGRlc2lyZWRTaXplKCl7aWYoIWplKHRoaXMpKXRocm93IExlKFwiZGVzaXJlZFNpemVcIik7aWYodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbT09PXZvaWQgMCl0aHJvdyBSdChcImRlc2lyZWRTaXplXCIpO3JldHVybiB6YSh0aGlzKX1nZXQgcmVhZHkoKXtyZXR1cm4gamUodGhpcyk/dGhpcy5fcmVhZHlQcm9taXNlOmIoTGUoXCJyZWFkeVwiKSl9YWJvcnQodD12b2lkIDApe3JldHVybiBqZSh0aGlzKT90aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtPT09dm9pZCAwP2IoUnQoXCJhYm9ydFwiKSk6V2EodGhpcyx0KTpiKExlKFwiYWJvcnRcIikpfWNsb3NlKCl7aWYoIWplKHRoaXMpKXJldHVybiBiKExlKFwiY2xvc2VcIikpO2NvbnN0IHQ9dGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtyZXR1cm4gdD09PXZvaWQgMD9iKFJ0KFwiY2xvc2VcIikpOmhlKHQpP2IobmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtXCIpKTpPbyh0aGlzKX1yZWxlYXNlTG9jaygpe2lmKCFqZSh0aGlzKSl0aHJvdyBMZShcInJlbGVhc2VMb2NrXCIpO3RoaXMuX293bmVyV3JpdGFibGVTdHJlYW0hPT12b2lkIDAmJklvKHRoaXMpfXdyaXRlKHQ9dm9pZCAwKXtyZXR1cm4gamUodGhpcyk/dGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbT09PXZvaWQgMD9iKFJ0KFwid3JpdGUgdG9cIikpOkZvKHRoaXMsdCk6YihMZShcIndyaXRlXCIpKX19O24oUm4sXCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJcIik7bGV0IHJlPVJuO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHJlLnByb3RvdHlwZSx7YWJvcnQ6e2VudW1lcmFibGU6ITB9LGNsb3NlOntlbnVtZXJhYmxlOiEwfSxyZWxlYXNlTG9jazp7ZW51bWVyYWJsZTohMH0sd3JpdGU6e2VudW1lcmFibGU6ITB9LGNsb3NlZDp7ZW51bWVyYWJsZTohMH0sZGVzaXJlZFNpemU6e2VudW1lcmFibGU6ITB9LHJlYWR5OntlbnVtZXJhYmxlOiEwfX0pLGgocmUucHJvdG90eXBlLmFib3J0LFwiYWJvcnRcIiksaChyZS5wcm90b3R5cGUuY2xvc2UsXCJjbG9zZVwiKSxoKHJlLnByb3RvdHlwZS5yZWxlYXNlTG9jayxcInJlbGVhc2VMb2NrXCIpLGgocmUucHJvdG90eXBlLndyaXRlLFwid3JpdGVcIiksdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyXCIsY29uZmlndXJhYmxlOiEwfSk7ZnVuY3Rpb24gamUoZSl7cmV0dXJuIWwoZSl8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl9vd25lcldyaXRhYmxlU3RyZWFtXCIpPyExOmUgaW5zdGFuY2VvZiByZX1uKGplLFwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJcIik7ZnVuY3Rpb24gV2EoZSx0KXtjb25zdCByPWUuX293bmVyV3JpdGFibGVTdHJlYW07cmV0dXJuIFp0KHIsdCl9bihXYSxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0XCIpO2Z1bmN0aW9uIE9vKGUpe2NvbnN0IHQ9ZS5fb3duZXJXcml0YWJsZVN0cmVhbTtyZXR1cm4gcW8odCl9bihPbyxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlXCIpO2Z1bmN0aW9uIHFhKGUpe2NvbnN0IHQ9ZS5fb3duZXJXcml0YWJsZVN0cmVhbSxyPXQuX3N0YXRlO3JldHVybiBoZSh0KXx8cj09PVwiY2xvc2VkXCI/VCh2b2lkIDApOnI9PT1cImVycm9yZWRcIj9iKHQuX3N0b3JlZEVycm9yKTpPbyhlKX1uKHFhLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvblwiKTtmdW5jdGlvbiBPYShlLHQpe2UuX2Nsb3NlZFByb21pc2VTdGF0ZT09PVwicGVuZGluZ1wiP2FuKGUsdCk6VWEoZSx0KX1uKE9hLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyRW5zdXJlQ2xvc2VkUHJvbWlzZVJlamVjdGVkXCIpO2Z1bmN0aW9uIHpvKGUsdCl7ZS5fcmVhZHlQcm9taXNlU3RhdGU9PT1cInBlbmRpbmdcIj9ObyhlLHQpOk5hKGUsdCl9bih6byxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkXCIpO2Z1bmN0aW9uIHphKGUpe2NvbnN0IHQ9ZS5fb3duZXJXcml0YWJsZVN0cmVhbSxyPXQuX3N0YXRlO3JldHVybiByPT09XCJlcnJvcmVkXCJ8fHI9PT1cImVycm9yaW5nXCI/bnVsbDpyPT09XCJjbG9zZWRcIj8wOiRvKHQuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcil9bih6YSxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckdldERlc2lyZWRTaXplXCIpO2Z1bmN0aW9uIElvKGUpe2NvbnN0IHQ9ZS5fb3duZXJXcml0YWJsZVN0cmVhbSxyPW5ldyBUeXBlRXJyb3IoXCJXcml0ZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc1wiKTt6byhlLHIpLE9hKGUsciksdC5fd3JpdGVyPXZvaWQgMCxlLl9vd25lcldyaXRhYmxlU3RyZWFtPXZvaWQgMH1uKElvLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZVwiKTtmdW5jdGlvbiBGbyhlLHQpe2NvbnN0IHI9ZS5fb3duZXJXcml0YWJsZVN0cmVhbSxzPXIuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcixmPWphKHMsdCk7aWYociE9PWUuX293bmVyV3JpdGFibGVTdHJlYW0pcmV0dXJuIGIoUnQoXCJ3cml0ZSB0b1wiKSk7Y29uc3QgYz1yLl9zdGF0ZTtpZihjPT09XCJlcnJvcmVkXCIpcmV0dXJuIGIoci5fc3RvcmVkRXJyb3IpO2lmKGhlKHIpfHxjPT09XCJjbG9zZWRcIilyZXR1cm4gYihuZXcgVHlwZUVycm9yKFwiVGhlIHN0cmVhbSBpcyBjbG9zaW5nIG9yIGNsb3NlZCBhbmQgY2Fubm90IGJlIHdyaXR0ZW4gdG9cIikpO2lmKGM9PT1cImVycm9yaW5nXCIpcmV0dXJuIGIoci5fc3RvcmVkRXJyb3IpO2NvbnN0IGQ9VGEocik7cmV0dXJuIExhKHMsdCxmKSxkfW4oRm8sXCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZVwiKTtjb25zdCBqbz17fSxUbj1jbGFzcyBUbntjb25zdHJ1Y3Rvcigpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cnVjdG9yXCIpfWdldCBhYm9ydFJlYXNvbigpe2lmKCFybih0aGlzKSl0aHJvdyBvbihcImFib3J0UmVhc29uXCIpO3JldHVybiB0aGlzLl9hYm9ydFJlYXNvbn1nZXQgc2lnbmFsKCl7aWYoIXJuKHRoaXMpKXRocm93IG9uKFwic2lnbmFsXCIpO2lmKHRoaXMuX2Fib3J0Q29udHJvbGxlcj09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuc2lnbmFsIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWx9ZXJyb3IodD12b2lkIDApe2lmKCFybih0aGlzKSl0aHJvdyBvbihcImVycm9yXCIpO3RoaXMuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGU9PT1cIndyaXRhYmxlXCImJkRvKHRoaXMsdCl9W0Z0XSh0KXtjb25zdCByPXRoaXMuX2Fib3J0QWxnb3JpdGhtKHQpO3JldHVybiBKdCh0aGlzKSxyfVtRbl0oKXtCZSh0aGlzKX19O24oVG4sXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIpO2xldCBrZT1UbjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhrZS5wcm90b3R5cGUse2Fib3J0UmVhc29uOntlbnVtZXJhYmxlOiEwfSxzaWduYWw6e2VudW1lcmFibGU6ITB9LGVycm9yOntlbnVtZXJhYmxlOiEwfX0pLHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PVwic3ltYm9sXCImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShrZS5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIixjb25maWd1cmFibGU6ITB9KTtmdW5jdGlvbiBybihlKXtyZXR1cm4hbChlKXx8IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbVwiKT8hMTplIGluc3RhbmNlb2Yga2V9bihybixcIklzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtmdW5jdGlvbiBMbyhlLHQscixzLGYsYyxkLG0pe3QuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbT1lLGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcj10LHQuX3F1ZXVlPXZvaWQgMCx0Ll9xdWV1ZVRvdGFsU2l6ZT12b2lkIDAsQmUodCksdC5fYWJvcnRSZWFzb249dm9pZCAwLHQuX2Fib3J0Q29udHJvbGxlcj13YSgpLHQuX3N0YXJ0ZWQ9ITEsdC5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtPW0sdC5fc3RyYXRlZ3lIV009ZCx0Ll93cml0ZUFsZ29yaXRobT1zLHQuX2Nsb3NlQWxnb3JpdGhtPWYsdC5fYWJvcnRBbGdvcml0aG09Yztjb25zdCBSPW5uKHQpO3RuKGUsUik7Y29uc3QgeT1yKCksQz1UKHkpO18oQywoKT0+KHQuX3N0YXJ0ZWQ9ITAsWHQodCksbnVsbCksUD0+KHQuX3N0YXJ0ZWQ9ITAsSnIoZSxQKSxudWxsKSl9bihMbyxcIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtmdW5jdGlvbiBJYShlLHQscixzKXtjb25zdCBmPU9iamVjdC5jcmVhdGUoa2UucHJvdG90eXBlKTtsZXQgYyxkLG0sUjt0LnN0YXJ0IT09dm9pZCAwP2M9bigoKT0+dC5zdGFydChmKSxcInN0YXJ0QWxnb3JpdGhtXCIpOmM9bigoKT0+e30sXCJzdGFydEFsZ29yaXRobVwiKSx0LndyaXRlIT09dm9pZCAwP2Q9bih5PT50LndyaXRlKHksZiksXCJ3cml0ZUFsZ29yaXRobVwiKTpkPW4oKCk9PlQodm9pZCAwKSxcIndyaXRlQWxnb3JpdGhtXCIpLHQuY2xvc2UhPT12b2lkIDA/bT1uKCgpPT50LmNsb3NlKCksXCJjbG9zZUFsZ29yaXRobVwiKTptPW4oKCk9PlQodm9pZCAwKSxcImNsb3NlQWxnb3JpdGhtXCIpLHQuYWJvcnQhPT12b2lkIDA/Uj1uKHk9PnQuYWJvcnQoeSksXCJhYm9ydEFsZ29yaXRobVwiKTpSPW4oKCk9PlQodm9pZCAwKSxcImFib3J0QWxnb3JpdGhtXCIpLExvKGUsZixjLGQsbSxSLHIscyl9bihJYSxcIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2lua1wiKTtmdW5jdGlvbiBKdChlKXtlLl93cml0ZUFsZ29yaXRobT12b2lkIDAsZS5fY2xvc2VBbGdvcml0aG09dm9pZCAwLGUuX2Fib3J0QWxnb3JpdGhtPXZvaWQgMCxlLl9zdHJhdGVneVNpemVBbGdvcml0aG09dm9pZCAwfW4oSnQsXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zXCIpO2Z1bmN0aW9uIEZhKGUpe05yKGUsam8sMCksWHQoZSl9bihGYSxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZVwiKTtmdW5jdGlvbiBqYShlLHQpe3RyeXtyZXR1cm4gZS5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKHQpfWNhdGNoKHIpe3JldHVybiB3dChlLHIpLDF9fW4oamEsXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplXCIpO2Z1bmN0aW9uICRvKGUpe3JldHVybiBlLl9zdHJhdGVneUhXTS1lLl9xdWV1ZVRvdGFsU2l6ZX1uKCRvLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplXCIpO2Z1bmN0aW9uIExhKGUsdCxyKXt0cnl7TnIoZSx0LHIpfWNhdGNoKGYpe3d0KGUsZik7cmV0dXJufWNvbnN0IHM9ZS5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO2lmKCFoZShzKSYmcy5fc3RhdGU9PT1cIndyaXRhYmxlXCIpe2NvbnN0IGY9bm4oZSk7dG4ocyxmKX1YdChlKX1uKExhLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlXCIpO2Z1bmN0aW9uIFh0KGUpe2NvbnN0IHQ9ZS5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO2lmKCFlLl9zdGFydGVkfHx0Ll9pbkZsaWdodFdyaXRlUmVxdWVzdCE9PXZvaWQgMClyZXR1cm47aWYodC5fc3RhdGU9PT1cImVycm9yaW5nXCIpe2VuKHQpO3JldHVybn1pZihlLl9xdWV1ZS5sZW5ndGg9PT0wKXJldHVybjtjb25zdCBzPUppKGUpO3M9PT1qbz8kYShlKTpEYShlLHMpfW4oWHQsXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWRcIik7ZnVuY3Rpb24gd3QoZSx0KXtlLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlPT09XCJ3cml0YWJsZVwiJiZEbyhlLHQpfW4od3QsXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZFwiKTtmdW5jdGlvbiAkYShlKXtjb25zdCB0PWUuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtCYSh0KSx4cihlKTtjb25zdCByPWUuX2Nsb3NlQWxnb3JpdGhtKCk7SnQoZSksXyhyLCgpPT4odmEodCksbnVsbCkscz0+KEVhKHQscyksbnVsbCkpfW4oJGEsXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlXCIpO2Z1bmN0aW9uIERhKGUsdCl7Y29uc3Qgcj1lLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07a2Eocik7Y29uc3Qgcz1lLl93cml0ZUFsZ29yaXRobSh0KTtfKHMsKCk9PntDYShyKTtjb25zdCBmPXIuX3N0YXRlO2lmKHhyKGUpLCFoZShyKSYmZj09PVwid3JpdGFibGVcIil7Y29uc3QgYz1ubihlKTt0bihyLGMpfXJldHVybiBYdChlKSxudWxsfSxmPT4oci5fc3RhdGU9PT1cIndyaXRhYmxlXCImJkp0KGUpLFBhKHIsZiksbnVsbCkpfW4oRGEsXCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlXCIpO2Z1bmN0aW9uIG5uKGUpe3JldHVybiAkbyhlKTw9MH1uKG5uLFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZVwiKTtmdW5jdGlvbiBEbyhlLHQpe2NvbnN0IHI9ZS5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO0p0KGUpLFhyKHIsdCl9bihEbyxcIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvclwiKTtmdW5jdGlvbiBlcihlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLiR7ZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtYCl9bihlcixcInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMlwiKTtmdW5jdGlvbiBvbihlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApfW4ob24sXCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMlwiKTtmdW5jdGlvbiBMZShlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJgKX1uKExlLFwiZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb25cIik7ZnVuY3Rpb24gUnQoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIrZStcIiBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHdyaXRlclwiKX1uKFJ0LFwiZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb25cIik7ZnVuY3Rpb24gdHIoZSl7ZS5fY2xvc2VkUHJvbWlzZT1FKCh0LHIpPT57ZS5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlPXQsZS5fY2xvc2VkUHJvbWlzZV9yZWplY3Q9cixlLl9jbG9zZWRQcm9taXNlU3RhdGU9XCJwZW5kaW5nXCJ9KX1uKHRyLFwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplXCIpO2Z1bmN0aW9uIE1vKGUsdCl7dHIoZSksYW4oZSx0KX1uKE1vLFwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZFwiKTtmdW5jdGlvbiBNYShlKXt0cihlKSxVbyhlKX1uKE1hLFwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZFwiKTtmdW5jdGlvbiBhbihlLHQpe2UuX2Nsb3NlZFByb21pc2VfcmVqZWN0IT09dm9pZCAwJiYoUShlLl9jbG9zZWRQcm9taXNlKSxlLl9jbG9zZWRQcm9taXNlX3JlamVjdCh0KSxlLl9jbG9zZWRQcm9taXNlX3Jlc29sdmU9dm9pZCAwLGUuX2Nsb3NlZFByb21pc2VfcmVqZWN0PXZvaWQgMCxlLl9jbG9zZWRQcm9taXNlU3RhdGU9XCJyZWplY3RlZFwiKX1uKGFuLFwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3RcIik7ZnVuY3Rpb24gVWEoZSx0KXtNbyhlLHQpfW4oVWEsXCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZFwiKTtmdW5jdGlvbiBVbyhlKXtlLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUhPT12b2lkIDAmJihlLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUodm9pZCAwKSxlLl9jbG9zZWRQcm9taXNlX3Jlc29sdmU9dm9pZCAwLGUuX2Nsb3NlZFByb21pc2VfcmVqZWN0PXZvaWQgMCxlLl9jbG9zZWRQcm9taXNlU3RhdGU9XCJyZXNvbHZlZFwiKX1uKFVvLFwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlXCIpO2Z1bmN0aW9uIHJyKGUpe2UuX3JlYWR5UHJvbWlzZT1FKCh0LHIpPT57ZS5fcmVhZHlQcm9taXNlX3Jlc29sdmU9dCxlLl9yZWFkeVByb21pc2VfcmVqZWN0PXJ9KSxlLl9yZWFkeVByb21pc2VTdGF0ZT1cInBlbmRpbmdcIn1uKHJyLFwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVcIik7ZnVuY3Rpb24gc24oZSx0KXtycihlKSxObyhlLHQpfW4oc24sXCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWRcIik7ZnVuY3Rpb24geG8oZSl7cnIoZSksbG4oZSl9bih4byxcImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZFwiKTtmdW5jdGlvbiBObyhlLHQpe2UuX3JlYWR5UHJvbWlzZV9yZWplY3QhPT12b2lkIDAmJihRKGUuX3JlYWR5UHJvbWlzZSksZS5fcmVhZHlQcm9taXNlX3JlamVjdCh0KSxlLl9yZWFkeVByb21pc2VfcmVzb2x2ZT12b2lkIDAsZS5fcmVhZHlQcm9taXNlX3JlamVjdD12b2lkIDAsZS5fcmVhZHlQcm9taXNlU3RhdGU9XCJyZWplY3RlZFwiKX1uKE5vLFwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdFwiKTtmdW5jdGlvbiB4YShlKXtycihlKX1uKHhhLFwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0XCIpO2Z1bmN0aW9uIE5hKGUsdCl7c24oZSx0KX1uKE5hLFwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZFwiKTtmdW5jdGlvbiBsbihlKXtlLl9yZWFkeVByb21pc2VfcmVzb2x2ZSE9PXZvaWQgMCYmKGUuX3JlYWR5UHJvbWlzZV9yZXNvbHZlKHZvaWQgMCksZS5fcmVhZHlQcm9taXNlX3Jlc29sdmU9dm9pZCAwLGUuX3JlYWR5UHJvbWlzZV9yZWplY3Q9dm9pZCAwLGUuX3JlYWR5UHJvbWlzZVN0YXRlPVwiZnVsZmlsbGVkXCIpfW4obG4sXCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZVwiKTtmdW5jdGlvbiBIYSgpe2lmKHR5cGVvZiBnbG9iYWxUaGlzPFwidVwiKXJldHVybiBnbG9iYWxUaGlzO2lmKHR5cGVvZiBzZWxmPFwidVwiKXJldHVybiBzZWxmO2lmKHR5cGVvZiBXbjxcInVcIilyZXR1cm4gV259bihIYSxcImdldEdsb2JhbHNcIik7Y29uc3QgdW49SGEoKTtmdW5jdGlvbiBWYShlKXtpZighKHR5cGVvZiBlPT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiBlPT1cIm9iamVjdFwiKXx8ZS5uYW1lIT09XCJET01FeGNlcHRpb25cIilyZXR1cm4hMTt0cnl7cmV0dXJuIG5ldyBlLCEwfWNhdGNoe3JldHVybiExfX1uKFZhLFwiaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvclwiKTtmdW5jdGlvbiBRYSgpe2NvbnN0IGU9dW4/LkRPTUV4Y2VwdGlvbjtyZXR1cm4gVmEoZSk/ZTp2b2lkIDB9bihRYSxcImdldEZyb21HbG9iYWxcIik7ZnVuY3Rpb24gWWEoKXtjb25zdCBlPW4oZnVuY3Rpb24ocixzKXt0aGlzLm1lc3NhZ2U9cnx8XCJcIix0aGlzLm5hbWU9c3x8XCJFcnJvclwiLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHRoaXMuY29uc3RydWN0b3IpfSxcIkRPTUV4Y2VwdGlvblwiKTtyZXR1cm4gaChlLFwiRE9NRXhjZXB0aW9uXCIpLGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsXCJjb25zdHJ1Y3RvclwiLHt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pLGV9bihZYSxcImNyZWF0ZVBvbHlmaWxsXCIpO2NvbnN0IEdhPVFhKCl8fFlhKCk7ZnVuY3Rpb24gSG8oZSx0LHIscyxmLGMpe2NvbnN0IGQ9UWUoZSksbT1rbyh0KTtlLl9kaXN0dXJiZWQ9ITA7bGV0IFI9ITEseT1UKHZvaWQgMCk7cmV0dXJuIEUoKEMsUCk9PntsZXQgQjtpZihjIT09dm9pZCAwKXtpZihCPW4oKCk9Pntjb25zdCBTPWMucmVhc29uIT09dm9pZCAwP2MucmVhc29uOm5ldyBHYShcIkFib3J0ZWRcIixcIkFib3J0RXJyb3JcIiksdj1bXTtzfHx2LnB1c2goKCk9PnQuX3N0YXRlPT09XCJ3cml0YWJsZVwiP1p0KHQsUyk6VCh2b2lkIDApKSxmfHx2LnB1c2goKCk9PmUuX3N0YXRlPT09XCJyZWFkYWJsZVwiP2llKGUsUyk6VCh2b2lkIDApKSxOKCgpPT5Qcm9taXNlLmFsbCh2Lm1hcChrPT5rKCkpKSwhMCxTKX0sXCJhYm9ydEFsZ29yaXRobVwiKSxjLmFib3J0ZWQpe0IoKTtyZXR1cm59Yy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIixCKX1mdW5jdGlvbiBhZSgpe3JldHVybiBFKChTLHYpPT57ZnVuY3Rpb24gayhZKXtZP1MoKTpxKG50KCksayx2KX1uKGssXCJuZXh0XCIpLGsoITEpfSl9bihhZSxcInBpcGVMb29wXCIpO2Z1bmN0aW9uIG50KCl7cmV0dXJuIFI/VCghMCk6cShtLl9yZWFkeVByb21pc2UsKCk9PkUoKFMsdik9PnttdChkLHtfY2h1bmtTdGVwczprPT57eT1xKEZvKG0sayksdm9pZCAwLHUpLFMoITEpfSxfY2xvc2VTdGVwczooKT0+UyghMCksX2Vycm9yU3RlcHM6dn0pfSkpfWlmKG4obnQsXCJwaXBlU3RlcFwiKSxUZShlLGQuX2Nsb3NlZFByb21pc2UsUz0+KHM/SighMCxTKTpOKCgpPT5adCh0LFMpLCEwLFMpLG51bGwpKSxUZSh0LG0uX2Nsb3NlZFByb21pc2UsUz0+KGY/SighMCxTKTpOKCgpPT5pZShlLFMpLCEwLFMpLG51bGwpKSx4KGUsZC5fY2xvc2VkUHJvbWlzZSwoKT0+KHI/SigpOk4oKCk9PnFhKG0pKSxudWxsKSksaGUodCl8fHQuX3N0YXRlPT09XCJjbG9zZWRcIil7Y29uc3QgUz1uZXcgVHlwZUVycm9yKFwidGhlIGRlc3RpbmF0aW9uIHdyaXRhYmxlIHN0cmVhbSBjbG9zZWQgYmVmb3JlIGFsbCBkYXRhIGNvdWxkIGJlIHBpcGVkIHRvIGl0XCIpO2Y/SighMCxTKTpOKCgpPT5pZShlLFMpLCEwLFMpfVEoYWUoKSk7ZnVuY3Rpb24gT2UoKXtjb25zdCBTPXk7cmV0dXJuIHEoeSwoKT0+UyE9PXk/T2UoKTp2b2lkIDApfW4oT2UsXCJ3YWl0Rm9yV3JpdGVzVG9GaW5pc2hcIik7ZnVuY3Rpb24gVGUoUyx2LGspe1MuX3N0YXRlPT09XCJlcnJvcmVkXCI/ayhTLl9zdG9yZWRFcnJvcik6SSh2LGspfW4oVGUsXCJpc09yQmVjb21lc0Vycm9yZWRcIik7ZnVuY3Rpb24geChTLHYsayl7Uy5fc3RhdGU9PT1cImNsb3NlZFwiP2soKTpWKHYsayl9bih4LFwiaXNPckJlY29tZXNDbG9zZWRcIik7ZnVuY3Rpb24gTihTLHYsayl7aWYoUilyZXR1cm47Uj0hMCx0Ll9zdGF0ZT09PVwid3JpdGFibGVcIiYmIWhlKHQpP1YoT2UoKSxZKTpZKCk7ZnVuY3Rpb24gWSgpe3JldHVybiBfKFMoKSwoKT0+Q2UodixrKSxvdD0+Q2UoITAsb3QpKSxudWxsfW4oWSxcImRvVGhlUmVzdFwiKX1uKE4sXCJzaHV0ZG93bldpdGhBY3Rpb25cIik7ZnVuY3Rpb24gSihTLHYpe1J8fChSPSEwLHQuX3N0YXRlPT09XCJ3cml0YWJsZVwiJiYhaGUodCk/VihPZSgpLCgpPT5DZShTLHYpKTpDZShTLHYpKX1uKEosXCJzaHV0ZG93blwiKTtmdW5jdGlvbiBDZShTLHYpe3JldHVybiBJbyhtKSxfZShkKSxjIT09dm9pZCAwJiZjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLEIpLFM/UCh2KTpDKHZvaWQgMCksbnVsbH1uKENlLFwiZmluYWxpemVcIil9KX1uKEhvLFwiUmVhZGFibGVTdHJlYW1QaXBlVG9cIik7Y29uc3QgQ249Y2xhc3MgQ257Y29uc3RydWN0b3IoKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjb25zdHJ1Y3RvclwiKX1nZXQgZGVzaXJlZFNpemUoKXtpZighbnIodGhpcykpdGhyb3cgaXIoXCJkZXNpcmVkU2l6ZVwiKTtyZXR1cm4gZm4odGhpcyl9Y2xvc2UoKXtpZighbnIodGhpcykpdGhyb3cgaXIoXCJjbG9zZVwiKTtpZighSmUodGhpcykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGNsb3NlXCIpOyRlKHRoaXMpfWVucXVldWUodD12b2lkIDApe2lmKCFucih0aGlzKSl0aHJvdyBpcihcImVucXVldWVcIik7aWYoIUplKHRoaXMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlXCIpO3JldHVybiBLZSh0aGlzLHQpfWVycm9yKHQ9dm9pZCAwKXtpZighbnIodGhpcykpdGhyb3cgaXIoXCJlcnJvclwiKTtvZSh0aGlzLHQpfVtBcl0odCl7QmUodGhpcyk7Y29uc3Qgcj10aGlzLl9jYW5jZWxBbGdvcml0aG0odCk7cmV0dXJuIG9yKHRoaXMpLHJ9W0JyXSh0KXtjb25zdCByPXRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtpZih0aGlzLl9xdWV1ZS5sZW5ndGg+MCl7Y29uc3Qgcz14cih0aGlzKTt0aGlzLl9jbG9zZVJlcXVlc3RlZCYmdGhpcy5fcXVldWUubGVuZ3RoPT09MD8ob3IodGhpcyksUHQocikpOlR0KHRoaXMpLHQuX2NodW5rU3RlcHMocyl9ZWxzZSBlbyhyLHQpLFR0KHRoaXMpfVtrcl0oKXt9fTtuKENuLFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtsZXQgbmU9Q247T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobmUucHJvdG90eXBlLHtjbG9zZTp7ZW51bWVyYWJsZTohMH0sZW5xdWV1ZTp7ZW51bWVyYWJsZTohMH0sZXJyb3I6e2VudW1lcmFibGU6ITB9LGRlc2lyZWRTaXplOntlbnVtZXJhYmxlOiEwfX0pLGgobmUucHJvdG90eXBlLmNsb3NlLFwiY2xvc2VcIiksaChuZS5wcm90b3R5cGUuZW5xdWV1ZSxcImVucXVldWVcIiksaChuZS5wcm90b3R5cGUuZXJyb3IsXCJlcnJvclwiKSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkobmUucHJvdG90eXBlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIsY29uZmlndXJhYmxlOiEwfSk7ZnVuY3Rpb24gbnIoZSl7cmV0dXJuIWwoZSl8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW1cIik/ITE6ZSBpbnN0YW5jZW9mIG5lfW4obnIsXCJJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIik7ZnVuY3Rpb24gVHQoZSl7aWYoIVZvKGUpKXJldHVybjtpZihlLl9wdWxsaW5nKXtlLl9wdWxsQWdhaW49ITA7cmV0dXJufWUuX3B1bGxpbmc9ITA7Y29uc3Qgcj1lLl9wdWxsQWxnb3JpdGhtKCk7XyhyLCgpPT4oZS5fcHVsbGluZz0hMSxlLl9wdWxsQWdhaW4mJihlLl9wdWxsQWdhaW49ITEsVHQoZSkpLG51bGwpLHM9PihvZShlLHMpLG51bGwpKX1uKFR0LFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWRcIik7ZnVuY3Rpb24gVm8oZSl7Y29uc3QgdD1lLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07cmV0dXJuIUplKGUpfHwhZS5fc3RhcnRlZD8hMTohIShxZSh0KSYmTHQodCk+MHx8Zm4oZSk+MCl9bihWbyxcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbFwiKTtmdW5jdGlvbiBvcihlKXtlLl9wdWxsQWxnb3JpdGhtPXZvaWQgMCxlLl9jYW5jZWxBbGdvcml0aG09dm9pZCAwLGUuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobT12b2lkIDB9bihvcixcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXNcIik7ZnVuY3Rpb24gJGUoZSl7aWYoIUplKGUpKXJldHVybjtjb25zdCB0PWUuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtlLl9jbG9zZVJlcXVlc3RlZD0hMCxlLl9xdWV1ZS5sZW5ndGg9PT0wJiYob3IoZSksUHQodCkpfW4oJGUsXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2VcIik7ZnVuY3Rpb24gS2UoZSx0KXtpZighSmUoZSkpcmV0dXJuO2NvbnN0IHI9ZS5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO2lmKHFlKHIpJiZMdChyKT4wKUxyKHIsdCwhMSk7ZWxzZXtsZXQgczt0cnl7cz1lLl9zdHJhdGVneVNpemVBbGdvcml0aG0odCl9Y2F0Y2goZil7dGhyb3cgb2UoZSxmKSxmfXRyeXtOcihlLHQscyl9Y2F0Y2goZil7dGhyb3cgb2UoZSxmKSxmfX1UdChlKX1uKEtlLFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWVcIik7ZnVuY3Rpb24gb2UoZSx0KXtjb25zdCByPWUuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtyLl9zdGF0ZT09PVwicmVhZGFibGVcIiYmKEJlKGUpLG9yKGUpLFpvKHIsdCkpfW4ob2UsXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JcIik7ZnVuY3Rpb24gZm4oZSl7Y29uc3QgdD1lLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO3JldHVybiB0PT09XCJlcnJvcmVkXCI/bnVsbDp0PT09XCJjbG9zZWRcIj8wOmUuX3N0cmF0ZWd5SFdNLWUuX3F1ZXVlVG90YWxTaXplfW4oZm4sXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemVcIik7ZnVuY3Rpb24gWmEoZSl7cmV0dXJuIVZvKGUpfW4oWmEsXCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlXCIpO2Z1bmN0aW9uIEplKGUpe2NvbnN0IHQ9ZS5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtLl9zdGF0ZTtyZXR1cm4hZS5fY2xvc2VSZXF1ZXN0ZWQmJnQ9PT1cInJlYWRhYmxlXCJ9bihKZSxcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZVwiKTtmdW5jdGlvbiBRbyhlLHQscixzLGYsYyxkKXt0Ll9jb250cm9sbGVkUmVhZGFibGVTdHJlYW09ZSx0Ll9xdWV1ZT12b2lkIDAsdC5fcXVldWVUb3RhbFNpemU9dm9pZCAwLEJlKHQpLHQuX3N0YXJ0ZWQ9ITEsdC5fY2xvc2VSZXF1ZXN0ZWQ9ITEsdC5fcHVsbEFnYWluPSExLHQuX3B1bGxpbmc9ITEsdC5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtPWQsdC5fc3RyYXRlZ3lIV009Yyx0Ll9wdWxsQWxnb3JpdGhtPXMsdC5fY2FuY2VsQWxnb3JpdGhtPWYsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyPXQ7Y29uc3QgbT1yKCk7XyhUKG0pLCgpPT4odC5fc3RhcnRlZD0hMCxUdCh0KSxudWxsKSxSPT4ob2UodCxSKSxudWxsKSl9bihRbyxcIlNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtmdW5jdGlvbiBLYShlLHQscixzKXtjb25zdCBmPU9iamVjdC5jcmVhdGUobmUucHJvdG90eXBlKTtsZXQgYyxkLG07dC5zdGFydCE9PXZvaWQgMD9jPW4oKCk9PnQuc3RhcnQoZiksXCJzdGFydEFsZ29yaXRobVwiKTpjPW4oKCk9Pnt9LFwic3RhcnRBbGdvcml0aG1cIiksdC5wdWxsIT09dm9pZCAwP2Q9bigoKT0+dC5wdWxsKGYpLFwicHVsbEFsZ29yaXRobVwiKTpkPW4oKCk9PlQodm9pZCAwKSxcInB1bGxBbGdvcml0aG1cIiksdC5jYW5jZWwhPT12b2lkIDA/bT1uKFI9PnQuY2FuY2VsKFIpLFwiY2FuY2VsQWxnb3JpdGhtXCIpOm09bigoKT0+VCh2b2lkIDApLFwiY2FuY2VsQWxnb3JpdGhtXCIpLFFvKGUsZixjLGQsbSxyLHMpfW4oS2EsXCJTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZVwiKTtmdW5jdGlvbiBpcihlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApfW4oaXIsXCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMVwiKTtmdW5jdGlvbiBKYShlLHQpe3JldHVybiB6ZShlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpP2VzKGUpOlhhKGUpfW4oSmEsXCJSZWFkYWJsZVN0cmVhbVRlZVwiKTtmdW5jdGlvbiBYYShlLHQpe2NvbnN0IHI9UWUoZSk7bGV0IHM9ITEsZj0hMSxjPSExLGQ9ITEsbSxSLHksQyxQO2NvbnN0IEI9RSh4PT57UD14fSk7ZnVuY3Rpb24gYWUoKXtyZXR1cm4gcz8oZj0hMCxUKHZvaWQgMCkpOihzPSEwLG10KHIse19jaHVua1N0ZXBzOk49PntnZSgoKT0+e2Y9ITE7Y29uc3QgSj1OLENlPU47Y3x8S2UoeS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLEopLGR8fEtlKEMuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixDZSkscz0hMSxmJiZhZSgpfSl9LF9jbG9zZVN0ZXBzOigpPT57cz0hMSxjfHwkZSh5Ll9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpLGR8fCRlKEMuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciksKCFjfHwhZCkmJlAodm9pZCAwKX0sX2Vycm9yU3RlcHM6KCk9PntzPSExfX0pLFQodm9pZCAwKSl9bihhZSxcInB1bGxBbGdvcml0aG1cIik7ZnVuY3Rpb24gbnQoeCl7aWYoYz0hMCxtPXgsZCl7Y29uc3QgTj15dChbbSxSXSksSj1pZShlLE4pO1AoSil9cmV0dXJuIEJ9bihudCxcImNhbmNlbDFBbGdvcml0aG1cIik7ZnVuY3Rpb24gT2UoeCl7aWYoZD0hMCxSPXgsYyl7Y29uc3QgTj15dChbbSxSXSksSj1pZShlLE4pO1AoSil9cmV0dXJuIEJ9bihPZSxcImNhbmNlbDJBbGdvcml0aG1cIik7ZnVuY3Rpb24gVGUoKXt9cmV0dXJuIG4oVGUsXCJzdGFydEFsZ29yaXRobVwiKSx5PUN0KFRlLGFlLG50KSxDPUN0KFRlLGFlLE9lKSxJKHIuX2Nsb3NlZFByb21pc2UseD0+KG9lKHkuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcix4KSxvZShDLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIseCksKCFjfHwhZCkmJlAodm9pZCAwKSxudWxsKSksW3ksQ119bihYYSxcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFRlZVwiKTtmdW5jdGlvbiBlcyhlKXtsZXQgdD1RZShlKSxyPSExLHM9ITEsZj0hMSxjPSExLGQ9ITEsbSxSLHksQyxQO2NvbnN0IEI9RShTPT57UD1TfSk7ZnVuY3Rpb24gYWUoUyl7SShTLl9jbG9zZWRQcm9taXNlLHY9PihTIT09dHx8KEsoeS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLHYpLEsoQy5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLHYpLCghY3x8IWQpJiZQKHZvaWQgMCkpLG51bGwpKX1uKGFlLFwiZm9yd2FyZFJlYWRlckVycm9yXCIpO2Z1bmN0aW9uIG50KCl7RmUodCkmJihfZSh0KSx0PVFlKGUpLGFlKHQpKSxtdCh0LHtfY2h1bmtTdGVwczp2PT57Z2UoKCk9PntzPSExLGY9ITE7Y29uc3Qgaz12O2xldCBZPXY7aWYoIWMmJiFkKXRyeXtZPWZvKHYpfWNhdGNoKG90KXtLKHkuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixvdCksSyhDLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsb3QpLFAoaWUoZSxvdCkpO3JldHVybn1jfHxOdCh5Ll9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsayksZHx8TnQoQy5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLFkpLHI9ITEscz9UZSgpOmYmJngoKX0pfSxfY2xvc2VTdGVwczooKT0+e3I9ITEsY3x8Z3QoeS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSxkfHxndChDLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpLHkuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MCYmSHQoeS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLDApLEMuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGg+MCYmSHQoQy5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLDApLCghY3x8IWQpJiZQKHZvaWQgMCl9LF9lcnJvclN0ZXBzOigpPT57cj0hMX19KX1uKG50LFwicHVsbFdpdGhEZWZhdWx0UmVhZGVyXCIpO2Z1bmN0aW9uIE9lKFMsdil7RWUodCkmJihfZSh0KSx0PUNvKGUpLGFlKHQpKTtjb25zdCBrPXY/Qzp5LFk9dj95OkM7RW8odCxTLDEse19jaHVua1N0ZXBzOml0PT57Z2UoKCk9PntzPSExLGY9ITE7Y29uc3QgYXQ9dj9kOmM7aWYodj9jOmQpYXR8fFZ0KGsuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixpdCk7ZWxzZXtsZXQgdWk7dHJ5e3VpPWZvKGl0KX1jYXRjaChrbil7SyhrLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsa24pLEsoWS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLGtuKSxQKGllKGUsa24pKTtyZXR1cm59YXR8fFZ0KGsuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixpdCksTnQoWS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLHVpKX1yPSExLHM/VGUoKTpmJiZ4KCl9KX0sX2Nsb3NlU3RlcHM6aXQ9PntyPSExO2NvbnN0IGF0PXY/ZDpjLGZyPXY/YzpkO2F0fHxndChrLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpLGZyfHxndChZLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpLGl0IT09dm9pZCAwJiYoYXR8fFZ0KGsuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixpdCksIWZyJiZZLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoPjAmJkh0KFkuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwwKSksKCFhdHx8IWZyKSYmUCh2b2lkIDApfSxfZXJyb3JTdGVwczooKT0+e3I9ITF9fSl9bihPZSxcInB1bGxXaXRoQllPQlJlYWRlclwiKTtmdW5jdGlvbiBUZSgpe2lmKHIpcmV0dXJuIHM9ITAsVCh2b2lkIDApO3I9ITA7Y29uc3QgUz1Hcih5Ll9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO3JldHVybiBTPT09bnVsbD9udCgpOk9lKFMuX3ZpZXcsITEpLFQodm9pZCAwKX1uKFRlLFwicHVsbDFBbGdvcml0aG1cIik7ZnVuY3Rpb24geCgpe2lmKHIpcmV0dXJuIGY9ITAsVCh2b2lkIDApO3I9ITA7Y29uc3QgUz1HcihDLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO3JldHVybiBTPT09bnVsbD9udCgpOk9lKFMuX3ZpZXcsITApLFQodm9pZCAwKX1uKHgsXCJwdWxsMkFsZ29yaXRobVwiKTtmdW5jdGlvbiBOKFMpe2lmKGM9ITAsbT1TLGQpe2NvbnN0IHY9eXQoW20sUl0pLGs9aWUoZSx2KTtQKGspfXJldHVybiBCfW4oTixcImNhbmNlbDFBbGdvcml0aG1cIik7ZnVuY3Rpb24gSihTKXtpZihkPSEwLFI9UyxjKXtjb25zdCB2PXl0KFttLFJdKSxrPWllKGUsdik7UChrKX1yZXR1cm4gQn1uKEosXCJjYW5jZWwyQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIENlKCl7fXJldHVybiBuKENlLFwic3RhcnRBbGdvcml0aG1cIikseT1HbyhDZSxUZSxOKSxDPUdvKENlLHgsSiksYWUodCksW3ksQ119bihlcyxcIlJlYWRhYmxlQnl0ZVN0cmVhbVRlZVwiKTtmdW5jdGlvbiB0cyhlKXtyZXR1cm4gbChlKSYmdHlwZW9mIGUuZ2V0UmVhZGVyPFwidVwifW4odHMsXCJpc1JlYWRhYmxlU3RyZWFtTGlrZVwiKTtmdW5jdGlvbiBycyhlKXtyZXR1cm4gdHMoZSk/b3MoZS5nZXRSZWFkZXIoKSk6bnMoZSl9bihycyxcIlJlYWRhYmxlU3RyZWFtRnJvbVwiKTtmdW5jdGlvbiBucyhlKXtsZXQgdDtjb25zdCByPXVvKGUsXCJhc3luY1wiKSxzPXU7ZnVuY3Rpb24gZigpe2xldCBkO3RyeXtkPVlpKHIpfWNhdGNoKFIpe3JldHVybiBiKFIpfWNvbnN0IG09VChkKTtyZXR1cm4gRihtLFI9PntpZighbChSKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGl0ZXJhdG9yLm5leHQoKSBtZXRob2QgbXVzdCBmdWxmaWxsIHdpdGggYW4gb2JqZWN0XCIpO2lmKEdpKFIpKSRlKHQuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7ZWxzZXtjb25zdCBDPVppKFIpO0tlKHQuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixDKX19KX1uKGYsXCJwdWxsQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIGMoZCl7Y29uc3QgbT1yLml0ZXJhdG9yO2xldCBSO3RyeXtSPU10KG0sXCJyZXR1cm5cIil9Y2F0Y2goUCl7cmV0dXJuIGIoUCl9aWYoUj09PXZvaWQgMClyZXR1cm4gVCh2b2lkIDApO2xldCB5O3RyeXt5PXooUixtLFtkXSl9Y2F0Y2goUCl7cmV0dXJuIGIoUCl9Y29uc3QgQz1UKHkpO3JldHVybiBGKEMsUD0+e2lmKCFsKFApKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgaXRlcmF0b3IucmV0dXJuKCkgbWV0aG9kIG11c3QgZnVsZmlsbCB3aXRoIGFuIG9iamVjdFwiKX0pfXJldHVybiBuKGMsXCJjYW5jZWxBbGdvcml0aG1cIiksdD1DdChzLGYsYywwKSx0fW4obnMsXCJSZWFkYWJsZVN0cmVhbUZyb21JdGVyYWJsZVwiKTtmdW5jdGlvbiBvcyhlKXtsZXQgdDtjb25zdCByPXU7ZnVuY3Rpb24gcygpe2xldCBjO3RyeXtjPWUucmVhZCgpfWNhdGNoKGQpe3JldHVybiBiKGQpfXJldHVybiBGKGMsZD0+e2lmKCFsKGQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgcmVhZGVyLnJlYWQoKSBtZXRob2QgbXVzdCBmdWxmaWxsIHdpdGggYW4gb2JqZWN0XCIpO2lmKGQuZG9uZSkkZSh0Ll9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO2Vsc2V7Y29uc3QgbT1kLnZhbHVlO0tlKHQuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcixtKX19KX1uKHMsXCJwdWxsQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIGYoYyl7dHJ5e3JldHVybiBUKGUuY2FuY2VsKGMpKX1jYXRjaChkKXtyZXR1cm4gYihkKX19cmV0dXJuIG4oZixcImNhbmNlbEFsZ29yaXRobVwiKSx0PUN0KHIscyxmLDApLHR9bihvcyxcIlJlYWRhYmxlU3RyZWFtRnJvbURlZmF1bHRSZWFkZXJcIik7ZnVuY3Rpb24gaXMoZSx0KXt1ZShlLHQpO2NvbnN0IHI9ZSxzPXI/LmF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxmPXI/LmNhbmNlbCxjPXI/LnB1bGwsZD1yPy5zdGFydCxtPXI/LnR5cGU7cmV0dXJue2F1dG9BbGxvY2F0ZUNodW5rU2l6ZTpzPT09dm9pZCAwP3ZvaWQgMDpGcihzLGAke3R9IGhhcyBtZW1iZXIgJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZScgdGhhdGApLGNhbmNlbDpmPT09dm9pZCAwP3ZvaWQgMDphcyhmLHIsYCR7dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCkscHVsbDpjPT09dm9pZCAwP3ZvaWQgMDpzcyhjLHIsYCR7dH0gaGFzIG1lbWJlciAncHVsbCcgdGhhdGApLHN0YXJ0OmQ9PT12b2lkIDA/dm9pZCAwOmxzKGQscixgJHt0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLHR5cGU6bT09PXZvaWQgMD92b2lkIDA6dXMobSxgJHt0fSBoYXMgbWVtYmVyICd0eXBlJyB0aGF0YCl9fW4oaXMsXCJjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2VcIik7ZnVuY3Rpb24gYXMoZSx0LHIpe3JldHVybiBaKGUscikscz0+aihlLHQsW3NdKX1uKGFzLFwiY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFja1wiKTtmdW5jdGlvbiBzcyhlLHQscil7cmV0dXJuIFooZSxyKSxzPT5qKGUsdCxbc10pfW4oc3MsXCJjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVB1bGxDYWxsYmFja1wiKTtmdW5jdGlvbiBscyhlLHQscil7cmV0dXJuIFooZSxyKSxzPT56KGUsdCxbc10pfW4obHMsXCJjb252ZXJ0VW5kZXJseWluZ1NvdXJjZVN0YXJ0Q2FsbGJhY2tcIik7ZnVuY3Rpb24gdXMoZSx0KXtpZihlPWAke2V9YCxlIT09XCJieXRlc1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dH0gJyR7ZX0nIGlzIG5vdCBhIHZhbGlkIGVudW1lcmF0aW9uIHZhbHVlIGZvciBSZWFkYWJsZVN0cmVhbVR5cGVgKTtyZXR1cm4gZX1uKHVzLFwiY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZVwiKTtmdW5jdGlvbiBmcyhlLHQpe3JldHVybiB1ZShlLHQpLHtwcmV2ZW50Q2FuY2VsOiEhZT8ucHJldmVudENhbmNlbH19bihmcyxcImNvbnZlcnRJdGVyYXRvck9wdGlvbnNcIik7ZnVuY3Rpb24gWW8oZSx0KXt1ZShlLHQpO2NvbnN0IHI9ZT8ucHJldmVudEFib3J0LHM9ZT8ucHJldmVudENhbmNlbCxmPWU/LnByZXZlbnRDbG9zZSxjPWU/LnNpZ25hbDtyZXR1cm4gYyE9PXZvaWQgMCYmY3MoYyxgJHt0fSBoYXMgbWVtYmVyICdzaWduYWwnIHRoYXRgKSx7cHJldmVudEFib3J0OiEhcixwcmV2ZW50Q2FuY2VsOiEhcyxwcmV2ZW50Q2xvc2U6ISFmLHNpZ25hbDpjfX1uKFlvLFwiY29udmVydFBpcGVPcHRpb25zXCIpO2Z1bmN0aW9uIGNzKGUsdCl7aWYoIV9hKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dH0gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApfW4oY3MsXCJhc3NlcnRBYm9ydFNpZ25hbFwiKTtmdW5jdGlvbiBkcyhlLHQpe3VlKGUsdCk7Y29uc3Qgcj1lPy5yZWFkYWJsZTt6cihyLFwicmVhZGFibGVcIixcIlJlYWRhYmxlV3JpdGFibGVQYWlyXCIpLGpyKHIsYCR7dH0gaGFzIG1lbWJlciAncmVhZGFibGUnIHRoYXRgKTtjb25zdCBzPWU/LndyaXRhYmxlO3JldHVybiB6cihzLFwid3JpdGFibGVcIixcIlJlYWRhYmxlV3JpdGFibGVQYWlyXCIpLEJvKHMsYCR7dH0gaGFzIG1lbWJlciAnd3JpdGFibGUnIHRoYXRgKSx7cmVhZGFibGU6cix3cml0YWJsZTpzfX1uKGRzLFwiY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyXCIpO2NvbnN0IFBuPWNsYXNzIFBue2NvbnN0cnVjdG9yKHQ9e30scj17fSl7dD09PXZvaWQgMD90PW51bGw6Sm4odCxcIkZpcnN0IHBhcmFtZXRlclwiKTtjb25zdCBzPUd0KHIsXCJTZWNvbmQgcGFyYW1ldGVyXCIpLGY9aXModCxcIkZpcnN0IHBhcmFtZXRlclwiKTtpZihjbih0aGlzKSxmLnR5cGU9PT1cImJ5dGVzXCIpe2lmKHMuc2l6ZSE9PXZvaWQgMCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSBzdHJhdGVneSBmb3IgYSBieXRlIHN0cmVhbSBjYW5ub3QgaGF2ZSBhIHNpemUgZnVuY3Rpb25cIik7Y29uc3QgYz1TdChzLDApO2FhKHRoaXMsZixjKX1lbHNle2NvbnN0IGM9WXQocyksZD1TdChzLDEpO0thKHRoaXMsZixkLGMpfX1nZXQgbG9ja2VkKCl7aWYoIVdlKHRoaXMpKXRocm93IERlKFwibG9ja2VkXCIpO3JldHVybiBxZSh0aGlzKX1jYW5jZWwodD12b2lkIDApe3JldHVybiBXZSh0aGlzKT9xZSh0aGlzKT9iKG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FuY2VsIGEgc3RyZWFtIHRoYXQgYWxyZWFkeSBoYXMgYSByZWFkZXJcIikpOmllKHRoaXMsdCk6YihEZShcImNhbmNlbFwiKSl9Z2V0UmVhZGVyKHQ9dm9pZCAwKXtpZighV2UodGhpcykpdGhyb3cgRGUoXCJnZXRSZWFkZXJcIik7cmV0dXJuIGxhKHQsXCJGaXJzdCBwYXJhbWV0ZXJcIikubW9kZT09PXZvaWQgMD9RZSh0aGlzKTpDbyh0aGlzKX1waXBlVGhyb3VnaCh0LHI9e30pe2lmKCFXZSh0aGlzKSl0aHJvdyBEZShcInBpcGVUaHJvdWdoXCIpO1NlKHQsMSxcInBpcGVUaHJvdWdoXCIpO2NvbnN0IHM9ZHModCxcIkZpcnN0IHBhcmFtZXRlclwiKSxmPVlvKHIsXCJTZWNvbmQgcGFyYW1ldGVyXCIpO2lmKHFlKHRoaXMpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW1cIik7aWYoWmUocy53cml0YWJsZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbVwiKTtjb25zdCBjPUhvKHRoaXMscy53cml0YWJsZSxmLnByZXZlbnRDbG9zZSxmLnByZXZlbnRBYm9ydCxmLnByZXZlbnRDYW5jZWwsZi5zaWduYWwpO3JldHVybiBRKGMpLHMucmVhZGFibGV9cGlwZVRvKHQscj17fSl7aWYoIVdlKHRoaXMpKXJldHVybiBiKERlKFwicGlwZVRvXCIpKTtpZih0PT09dm9pZCAwKXJldHVybiBiKFwiUGFyYW1ldGVyIDEgaXMgcmVxdWlyZWQgaW4gJ3BpcGVUbycuXCIpO2lmKCFHZSh0KSlyZXR1cm4gYihuZXcgVHlwZUVycm9yKFwiUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnBpcGVUbydzIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBXcml0YWJsZVN0cmVhbVwiKSk7bGV0IHM7dHJ5e3M9WW8ocixcIlNlY29uZCBwYXJhbWV0ZXJcIil9Y2F0Y2goZil7cmV0dXJuIGIoZil9cmV0dXJuIHFlKHRoaXMpP2IobmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW1cIikpOlplKHQpP2IobmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW1cIikpOkhvKHRoaXMsdCxzLnByZXZlbnRDbG9zZSxzLnByZXZlbnRBYm9ydCxzLnByZXZlbnRDYW5jZWwscy5zaWduYWwpfXRlZSgpe2lmKCFXZSh0aGlzKSl0aHJvdyBEZShcInRlZVwiKTtjb25zdCB0PUphKHRoaXMpO3JldHVybiB5dCh0KX12YWx1ZXModD12b2lkIDApe2lmKCFXZSh0aGlzKSl0aHJvdyBEZShcInZhbHVlc1wiKTtjb25zdCByPWZzKHQsXCJGaXJzdCBwYXJhbWV0ZXJcIik7cmV0dXJuIFZpKHRoaXMsci5wcmV2ZW50Q2FuY2VsKX1bVXJdKHQpe3JldHVybiB0aGlzLnZhbHVlcyh0KX1zdGF0aWMgZnJvbSh0KXtyZXR1cm4gcnModCl9fTtuKFBuLFwiUmVhZGFibGVTdHJlYW1cIik7bGV0IEw9UG47T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTCx7ZnJvbTp7ZW51bWVyYWJsZTohMH19KSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhMLnByb3RvdHlwZSx7Y2FuY2VsOntlbnVtZXJhYmxlOiEwfSxnZXRSZWFkZXI6e2VudW1lcmFibGU6ITB9LHBpcGVUaHJvdWdoOntlbnVtZXJhYmxlOiEwfSxwaXBlVG86e2VudW1lcmFibGU6ITB9LHRlZTp7ZW51bWVyYWJsZTohMH0sdmFsdWVzOntlbnVtZXJhYmxlOiEwfSxsb2NrZWQ6e2VudW1lcmFibGU6ITB9fSksaChMLmZyb20sXCJmcm9tXCIpLGgoTC5wcm90b3R5cGUuY2FuY2VsLFwiY2FuY2VsXCIpLGgoTC5wcm90b3R5cGUuZ2V0UmVhZGVyLFwiZ2V0UmVhZGVyXCIpLGgoTC5wcm90b3R5cGUucGlwZVRocm91Z2gsXCJwaXBlVGhyb3VnaFwiKSxoKEwucHJvdG90eXBlLnBpcGVUbyxcInBpcGVUb1wiKSxoKEwucHJvdG90eXBlLnRlZSxcInRlZVwiKSxoKEwucHJvdG90eXBlLnZhbHVlcyxcInZhbHVlc1wiKSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoTC5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlJlYWRhYmxlU3RyZWFtXCIsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEwucHJvdG90eXBlLFVyLHt2YWx1ZTpMLnByb3RvdHlwZS52YWx1ZXMsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSk7ZnVuY3Rpb24gQ3QoZSx0LHIscz0xLGY9KCk9PjEpe2NvbnN0IGM9T2JqZWN0LmNyZWF0ZShMLnByb3RvdHlwZSk7Y24oYyk7Y29uc3QgZD1PYmplY3QuY3JlYXRlKG5lLnByb3RvdHlwZSk7cmV0dXJuIFFvKGMsZCxlLHQscixzLGYpLGN9bihDdCxcIkNyZWF0ZVJlYWRhYmxlU3RyZWFtXCIpO2Z1bmN0aW9uIEdvKGUsdCxyKXtjb25zdCBzPU9iamVjdC5jcmVhdGUoTC5wcm90b3R5cGUpO2NuKHMpO2NvbnN0IGY9T2JqZWN0LmNyZWF0ZSh0ZS5wcm90b3R5cGUpO3JldHVybiBUbyhzLGYsZSx0LHIsMCx2b2lkIDApLHN9bihHbyxcIkNyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbVwiKTtmdW5jdGlvbiBjbihlKXtlLl9zdGF0ZT1cInJlYWRhYmxlXCIsZS5fcmVhZGVyPXZvaWQgMCxlLl9zdG9yZWRFcnJvcj12b2lkIDAsZS5fZGlzdHVyYmVkPSExfW4oY24sXCJJbml0aWFsaXplUmVhZGFibGVTdHJlYW1cIik7ZnVuY3Rpb24gV2UoZSl7cmV0dXJuIWwoZSl8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJcIik/ITE6ZSBpbnN0YW5jZW9mIEx9bihXZSxcIklzUmVhZGFibGVTdHJlYW1cIik7ZnVuY3Rpb24gcWUoZSl7cmV0dXJuIGUuX3JlYWRlciE9PXZvaWQgMH1uKHFlLFwiSXNSZWFkYWJsZVN0cmVhbUxvY2tlZFwiKTtmdW5jdGlvbiBpZShlLHQpe2lmKGUuX2Rpc3R1cmJlZD0hMCxlLl9zdGF0ZT09PVwiY2xvc2VkXCIpcmV0dXJuIFQodm9pZCAwKTtpZihlLl9zdGF0ZT09PVwiZXJyb3JlZFwiKXJldHVybiBiKGUuX3N0b3JlZEVycm9yKTtQdChlKTtjb25zdCByPWUuX3JlYWRlcjtpZihyIT09dm9pZCAwJiZGZShyKSl7Y29uc3QgZj1yLl9yZWFkSW50b1JlcXVlc3RzO3IuX3JlYWRJbnRvUmVxdWVzdHM9bmV3IEQsZi5mb3JFYWNoKGM9PntjLl9jbG9zZVN0ZXBzKHZvaWQgMCl9KX1jb25zdCBzPWUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcltBcl0odCk7cmV0dXJuIEYocyx1KX1uKGllLFwiUmVhZGFibGVTdHJlYW1DYW5jZWxcIik7ZnVuY3Rpb24gUHQoZSl7ZS5fc3RhdGU9XCJjbG9zZWRcIjtjb25zdCB0PWUuX3JlYWRlcjtpZih0IT09dm9pZCAwJiYoWm4odCksRWUodCkpKXtjb25zdCByPXQuX3JlYWRSZXF1ZXN0czt0Ll9yZWFkUmVxdWVzdHM9bmV3IEQsci5mb3JFYWNoKHM9PntzLl9jbG9zZVN0ZXBzKCl9KX19bihQdCxcIlJlYWRhYmxlU3RyZWFtQ2xvc2VcIik7ZnVuY3Rpb24gWm8oZSx0KXtlLl9zdGF0ZT1cImVycm9yZWRcIixlLl9zdG9yZWRFcnJvcj10O2NvbnN0IHI9ZS5fcmVhZGVyO3IhPT12b2lkIDAmJihPcihyLHQpLEVlKHIpP3JvKHIsdCk6QW8ocix0KSl9bihabyxcIlJlYWRhYmxlU3RyZWFtRXJyb3JcIik7ZnVuY3Rpb24gRGUoZSl7cmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbWApfW4oRGUsXCJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDFcIik7ZnVuY3Rpb24gS28oZSx0KXt1ZShlLHQpO2NvbnN0IHI9ZT8uaGlnaFdhdGVyTWFyaztyZXR1cm4genIocixcImhpZ2hXYXRlck1hcmtcIixcIlF1ZXVpbmdTdHJhdGVneUluaXRcIikse2hpZ2hXYXRlck1hcms6SXIocil9fW4oS28sXCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdFwiKTtjb25zdCBKbz1uKGU9PmUuYnl0ZUxlbmd0aCxcImJ5dGVMZW5ndGhTaXplRnVuY3Rpb25cIik7aChKbyxcInNpemVcIik7Y29uc3Qgdm49Y2xhc3Mgdm57Y29uc3RydWN0b3IodCl7U2UodCwxLFwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneVwiKSx0PUtvKHQsXCJGaXJzdCBwYXJhbWV0ZXJcIiksdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms9dC5oaWdoV2F0ZXJNYXJrfWdldCBoaWdoV2F0ZXJNYXJrKCl7aWYoIWVpKHRoaXMpKXRocm93IFhvKFwiaGlnaFdhdGVyTWFya1wiKTtyZXR1cm4gdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmt9Z2V0IHNpemUoKXtpZighZWkodGhpcykpdGhyb3cgWG8oXCJzaXplXCIpO3JldHVybiBKb319O24odm4sXCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5XCIpO2xldCBYZT12bjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhYZS5wcm90b3R5cGUse2hpZ2hXYXRlck1hcms6e2VudW1lcmFibGU6ITB9LHNpemU6e2VudW1lcmFibGU6ITB9fSksdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KFhlLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneVwiLGNvbmZpZ3VyYWJsZTohMH0pO2Z1bmN0aW9uIFhvKGUpe3JldHVybiBuZXcgVHlwZUVycm9yKGBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5YCl9bihYbyxcImJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uXCIpO2Z1bmN0aW9uIGVpKGUpe3JldHVybiFsKGUpfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmtcIik/ITE6ZSBpbnN0YW5jZW9mIFhlfW4oZWksXCJJc0J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lcIik7Y29uc3QgdGk9bigoKT0+MSxcImNvdW50U2l6ZUZ1bmN0aW9uXCIpO2godGksXCJzaXplXCIpO2NvbnN0IEVuPWNsYXNzIEVue2NvbnN0cnVjdG9yKHQpe1NlKHQsMSxcIkNvdW50UXVldWluZ1N0cmF0ZWd5XCIpLHQ9S28odCxcIkZpcnN0IHBhcmFtZXRlclwiKSx0aGlzLl9jb3VudFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcms9dC5oaWdoV2F0ZXJNYXJrfWdldCBoaWdoV2F0ZXJNYXJrKCl7aWYoIW5pKHRoaXMpKXRocm93IHJpKFwiaGlnaFdhdGVyTWFya1wiKTtyZXR1cm4gdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrfWdldCBzaXplKCl7aWYoIW5pKHRoaXMpKXRocm93IHJpKFwic2l6ZVwiKTtyZXR1cm4gdGl9fTtuKEVuLFwiQ291bnRRdWV1aW5nU3RyYXRlZ3lcIik7bGV0IGV0PUVuO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGV0LnByb3RvdHlwZSx7aGlnaFdhdGVyTWFyazp7ZW51bWVyYWJsZTohMH0sc2l6ZTp7ZW51bWVyYWJsZTohMH19KSx0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT1cInN5bWJvbFwiJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZXQucHJvdG90eXBlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJDb3VudFF1ZXVpbmdTdHJhdGVneVwiLGNvbmZpZ3VyYWJsZTohMH0pO2Z1bmN0aW9uIHJpKGUpe3JldHVybiBuZXcgVHlwZUVycm9yKGBDb3VudFF1ZXVpbmdTdHJhdGVneS5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgQ291bnRRdWV1aW5nU3RyYXRlZ3lgKX1uKHJpLFwiY291bnRCcmFuZENoZWNrRXhjZXB0aW9uXCIpO2Z1bmN0aW9uIG5pKGUpe3JldHVybiFsKGUpfHwhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrXCIpPyExOmUgaW5zdGFuY2VvZiBldH1uKG5pLFwiSXNDb3VudFF1ZXVpbmdTdHJhdGVneVwiKTtmdW5jdGlvbiBocyhlLHQpe3VlKGUsdCk7Y29uc3Qgcj1lPy5jYW5jZWwscz1lPy5mbHVzaCxmPWU/LnJlYWRhYmxlVHlwZSxjPWU/LnN0YXJ0LGQ9ZT8udHJhbnNmb3JtLG09ZT8ud3JpdGFibGVUeXBlO3JldHVybntjYW5jZWw6cj09PXZvaWQgMD92b2lkIDA6eXMocixlLGAke3R9IGhhcyBtZW1iZXIgJ2NhbmNlbCcgdGhhdGApLGZsdXNoOnM9PT12b2lkIDA/dm9pZCAwOnBzKHMsZSxgJHt0fSBoYXMgbWVtYmVyICdmbHVzaCcgdGhhdGApLHJlYWRhYmxlVHlwZTpmLHN0YXJ0OmM9PT12b2lkIDA/dm9pZCAwOmJzKGMsZSxgJHt0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLHRyYW5zZm9ybTpkPT09dm9pZCAwP3ZvaWQgMDptcyhkLGUsYCR7dH0gaGFzIG1lbWJlciAndHJhbnNmb3JtJyB0aGF0YCksd3JpdGFibGVUeXBlOm19fW4oaHMsXCJjb252ZXJ0VHJhbnNmb3JtZXJcIik7ZnVuY3Rpb24gcHMoZSx0LHIpe3JldHVybiBaKGUscikscz0+aihlLHQsW3NdKX1uKHBzLFwiY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFja1wiKTtmdW5jdGlvbiBicyhlLHQscil7cmV0dXJuIFooZSxyKSxzPT56KGUsdCxbc10pfW4oYnMsXCJjb252ZXJ0VHJhbnNmb3JtZXJTdGFydENhbGxiYWNrXCIpO2Z1bmN0aW9uIG1zKGUsdCxyKXtyZXR1cm4gWihlLHIpLChzLGYpPT5qKGUsdCxbcyxmXSl9bihtcyxcImNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrXCIpO2Z1bmN0aW9uIHlzKGUsdCxyKXtyZXR1cm4gWihlLHIpLHM9PmooZSx0LFtzXSl9bih5cyxcImNvbnZlcnRUcmFuc2Zvcm1lckNhbmNlbENhbGxiYWNrXCIpO2NvbnN0IEFuPWNsYXNzIEFue2NvbnN0cnVjdG9yKHQ9e30scj17fSxzPXt9KXt0PT09dm9pZCAwJiYodD1udWxsKTtjb25zdCBmPUd0KHIsXCJTZWNvbmQgcGFyYW1ldGVyXCIpLGM9R3QocyxcIlRoaXJkIHBhcmFtZXRlclwiKSxkPWhzKHQsXCJGaXJzdCBwYXJhbWV0ZXJcIik7aWYoZC5yZWFkYWJsZVR5cGUhPT12b2lkIDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHJlYWRhYmxlVHlwZSBzcGVjaWZpZWRcIik7aWYoZC53cml0YWJsZVR5cGUhPT12b2lkIDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHdyaXRhYmxlVHlwZSBzcGVjaWZpZWRcIik7Y29uc3QgbT1TdChjLDApLFI9WXQoYykseT1TdChmLDEpLEM9WXQoZik7bGV0IFA7Y29uc3QgQj1FKGFlPT57UD1hZX0pO2dzKHRoaXMsQix5LEMsbSxSKSxTcyh0aGlzLGQpLGQuc3RhcnQhPT12b2lkIDA/UChkLnN0YXJ0KHRoaXMuX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIpKTpQKHZvaWQgMCl9Z2V0IHJlYWRhYmxlKCl7aWYoIW9pKHRoaXMpKXRocm93IGxpKFwicmVhZGFibGVcIik7cmV0dXJuIHRoaXMuX3JlYWRhYmxlfWdldCB3cml0YWJsZSgpe2lmKCFvaSh0aGlzKSl0aHJvdyBsaShcIndyaXRhYmxlXCIpO3JldHVybiB0aGlzLl93cml0YWJsZX19O24oQW4sXCJUcmFuc2Zvcm1TdHJlYW1cIik7bGV0IHR0PUFuO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHR0LnByb3RvdHlwZSx7cmVhZGFibGU6e2VudW1lcmFibGU6ITB9LHdyaXRhYmxlOntlbnVtZXJhYmxlOiEwfX0pLHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PVwic3ltYm9sXCImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0dC5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlRyYW5zZm9ybVN0cmVhbVwiLGNvbmZpZ3VyYWJsZTohMH0pO2Z1bmN0aW9uIGdzKGUsdCxyLHMsZixjKXtmdW5jdGlvbiBkKCl7cmV0dXJuIHR9bihkLFwic3RhcnRBbGdvcml0aG1cIik7ZnVuY3Rpb24gbShCKXtyZXR1cm4gVHMoZSxCKX1uKG0sXCJ3cml0ZUFsZ29yaXRobVwiKTtmdW5jdGlvbiBSKEIpe3JldHVybiBDcyhlLEIpfW4oUixcImFib3J0QWxnb3JpdGhtXCIpO2Z1bmN0aW9uIHkoKXtyZXR1cm4gUHMoZSl9bih5LFwiY2xvc2VBbGdvcml0aG1cIiksZS5fd3JpdGFibGU9UmEoZCxtLHksUixyLHMpO2Z1bmN0aW9uIEMoKXtyZXR1cm4gdnMoZSl9bihDLFwicHVsbEFsZ29yaXRobVwiKTtmdW5jdGlvbiBQKEIpe3JldHVybiBFcyhlLEIpfW4oUCxcImNhbmNlbEFsZ29yaXRobVwiKSxlLl9yZWFkYWJsZT1DdChkLEMsUCxmLGMpLGUuX2JhY2twcmVzc3VyZT12b2lkIDAsZS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZT12b2lkIDAsZS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlPXZvaWQgMCxhcihlLCEwKSxlLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyPXZvaWQgMH1uKGdzLFwiSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbVwiKTtmdW5jdGlvbiBvaShlKXtyZXR1cm4hbChlKXx8IU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLFwiX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXJcIik/ITE6ZSBpbnN0YW5jZW9mIHR0fW4ob2ksXCJJc1RyYW5zZm9ybVN0cmVhbVwiKTtmdW5jdGlvbiBpaShlLHQpe29lKGUuX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsdCksZG4oZSx0KX1uKGlpLFwiVHJhbnNmb3JtU3RyZWFtRXJyb3JcIik7ZnVuY3Rpb24gZG4oZSx0KXtscihlLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyKSx3dChlLl93cml0YWJsZS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLHQpLGhuKGUpfW4oZG4sXCJUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlXCIpO2Z1bmN0aW9uIGhuKGUpe2UuX2JhY2twcmVzc3VyZSYmYXIoZSwhMSl9bihobixcIlRyYW5zZm9ybVN0cmVhbVVuYmxvY2tXcml0ZVwiKTtmdW5jdGlvbiBhcihlLHQpe2UuX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UhPT12b2lkIDAmJmUuX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSgpLGUuX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U9RShyPT57ZS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlPXJ9KSxlLl9iYWNrcHJlc3N1cmU9dH1uKGFyLFwiVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlXCIpO2NvbnN0IEJuPWNsYXNzIEJue2NvbnN0cnVjdG9yKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY29uc3RydWN0b3JcIil9Z2V0IGRlc2lyZWRTaXplKCl7aWYoIXNyKHRoaXMpKXRocm93IHVyKFwiZGVzaXJlZFNpemVcIik7Y29uc3QgdD10aGlzLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO3JldHVybiBmbih0KX1lbnF1ZXVlKHQ9dm9pZCAwKXtpZighc3IodGhpcykpdGhyb3cgdXIoXCJlbnF1ZXVlXCIpO2FpKHRoaXMsdCl9ZXJyb3IodD12b2lkIDApe2lmKCFzcih0aGlzKSl0aHJvdyB1cihcImVycm9yXCIpO3dzKHRoaXMsdCl9dGVybWluYXRlKCl7aWYoIXNyKHRoaXMpKXRocm93IHVyKFwidGVybWluYXRlXCIpO1JzKHRoaXMpfX07bihCbixcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIpO2xldCBwZT1CbjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwZS5wcm90b3R5cGUse2VucXVldWU6e2VudW1lcmFibGU6ITB9LGVycm9yOntlbnVtZXJhYmxlOiEwfSx0ZXJtaW5hdGU6e2VudW1lcmFibGU6ITB9LGRlc2lyZWRTaXplOntlbnVtZXJhYmxlOiEwfX0pLGgocGUucHJvdG90eXBlLmVucXVldWUsXCJlbnF1ZXVlXCIpLGgocGUucHJvdG90eXBlLmVycm9yLFwiZXJyb3JcIiksaChwZS5wcm90b3R5cGUudGVybWluYXRlLFwidGVybWluYXRlXCIpLHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWc9PVwic3ltYm9sXCImJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwZS5wcm90b3R5cGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIsY29uZmlndXJhYmxlOiEwfSk7ZnVuY3Rpb24gc3IoZSl7cmV0dXJuIWwoZSl8fCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcIl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtXCIpPyExOmUgaW5zdGFuY2VvZiBwZX1uKHNyLFwiSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtmdW5jdGlvbiBfcyhlLHQscixzLGYpe3QuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW09ZSxlLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyPXQsdC5fdHJhbnNmb3JtQWxnb3JpdGhtPXIsdC5fZmx1c2hBbGdvcml0aG09cyx0Ll9jYW5jZWxBbGdvcml0aG09Zix0Ll9maW5pc2hQcm9taXNlPXZvaWQgMCx0Ll9maW5pc2hQcm9taXNlX3Jlc29sdmU9dm9pZCAwLHQuX2ZpbmlzaFByb21pc2VfcmVqZWN0PXZvaWQgMH1uKF9zLFwiU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclwiKTtmdW5jdGlvbiBTcyhlLHQpe2NvbnN0IHI9T2JqZWN0LmNyZWF0ZShwZS5wcm90b3R5cGUpO2xldCBzLGYsYzt0LnRyYW5zZm9ybSE9PXZvaWQgMD9zPW4oZD0+dC50cmFuc2Zvcm0oZCxyKSxcInRyYW5zZm9ybUFsZ29yaXRobVwiKTpzPW4oZD0+e3RyeXtyZXR1cm4gYWkocixkKSxUKHZvaWQgMCl9Y2F0Y2gobSl7cmV0dXJuIGIobSl9fSxcInRyYW5zZm9ybUFsZ29yaXRobVwiKSx0LmZsdXNoIT09dm9pZCAwP2Y9bigoKT0+dC5mbHVzaChyKSxcImZsdXNoQWxnb3JpdGhtXCIpOmY9bigoKT0+VCh2b2lkIDApLFwiZmx1c2hBbGdvcml0aG1cIiksdC5jYW5jZWwhPT12b2lkIDA/Yz1uKGQ9PnQuY2FuY2VsKGQpLFwiY2FuY2VsQWxnb3JpdGhtXCIpOmM9bigoKT0+VCh2b2lkIDApLFwiY2FuY2VsQWxnb3JpdGhtXCIpLF9zKGUscixzLGYsYyl9bihTcyxcIlNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXJcIik7ZnVuY3Rpb24gbHIoZSl7ZS5fdHJhbnNmb3JtQWxnb3JpdGhtPXZvaWQgMCxlLl9mbHVzaEFsZ29yaXRobT12b2lkIDAsZS5fY2FuY2VsQWxnb3JpdGhtPXZvaWQgMH1uKGxyLFwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXNcIik7ZnVuY3Rpb24gYWkoZSx0KXtjb25zdCByPWUuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0scz1yLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO2lmKCFKZShzKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUmVhZGFibGUgc2lkZSBpcyBub3QgaW4gYSBzdGF0ZSB0aGF0IHBlcm1pdHMgZW5xdWV1ZVwiKTt0cnl7S2Uocyx0KX1jYXRjaChjKXt0aHJvdyBkbihyLGMpLHIuX3JlYWRhYmxlLl9zdG9yZWRFcnJvcn1aYShzKSE9PXIuX2JhY2twcmVzc3VyZSYmYXIociwhMCl9bihhaSxcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZVwiKTtmdW5jdGlvbiB3cyhlLHQpe2lpKGUuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sdCl9bih3cyxcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JcIik7ZnVuY3Rpb24gc2koZSx0KXtjb25zdCByPWUuX3RyYW5zZm9ybUFsZ29yaXRobSh0KTtyZXR1cm4gRihyLHZvaWQgMCxzPT57dGhyb3cgaWkoZS5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSxzKSxzfSl9bihzaSxcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybVwiKTtmdW5jdGlvbiBScyhlKXtjb25zdCB0PWUuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0scj10Ll9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyOyRlKHIpO2NvbnN0IHM9bmV3IFR5cGVFcnJvcihcIlRyYW5zZm9ybVN0cmVhbSB0ZXJtaW5hdGVkXCIpO2RuKHQscyl9bihScyxcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlXCIpO2Z1bmN0aW9uIFRzKGUsdCl7Y29uc3Qgcj1lLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO2lmKGUuX2JhY2twcmVzc3VyZSl7Y29uc3Qgcz1lLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlO3JldHVybiBGKHMsKCk9Pntjb25zdCBmPWUuX3dyaXRhYmxlO2lmKGYuX3N0YXRlPT09XCJlcnJvcmluZ1wiKXRocm93IGYuX3N0b3JlZEVycm9yO3JldHVybiBzaShyLHQpfSl9cmV0dXJuIHNpKHIsdCl9bihUcyxcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rV3JpdGVBbGdvcml0aG1cIik7ZnVuY3Rpb24gQ3MoZSx0KXtjb25zdCByPWUuX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7aWYoci5fZmluaXNoUHJvbWlzZSE9PXZvaWQgMClyZXR1cm4gci5fZmluaXNoUHJvbWlzZTtjb25zdCBzPWUuX3JlYWRhYmxlO3IuX2ZpbmlzaFByb21pc2U9RSgoYyxkKT0+e3IuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZT1jLHIuX2ZpbmlzaFByb21pc2VfcmVqZWN0PWR9KTtjb25zdCBmPXIuX2NhbmNlbEFsZ29yaXRobSh0KTtyZXR1cm4gbHIociksXyhmLCgpPT4ocy5fc3RhdGU9PT1cImVycm9yZWRcIj9ydChyLHMuX3N0b3JlZEVycm9yKToob2Uocy5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLHQpLHBuKHIpKSxudWxsKSxjPT4ob2Uocy5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLGMpLHJ0KHIsYyksbnVsbCkpLHIuX2ZpbmlzaFByb21pc2V9bihDcyxcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG1cIik7ZnVuY3Rpb24gUHMoZSl7Y29uc3QgdD1lLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO2lmKHQuX2ZpbmlzaFByb21pc2UhPT12b2lkIDApcmV0dXJuIHQuX2ZpbmlzaFByb21pc2U7Y29uc3Qgcj1lLl9yZWFkYWJsZTt0Ll9maW5pc2hQcm9taXNlPUUoKGYsYyk9Pnt0Ll9maW5pc2hQcm9taXNlX3Jlc29sdmU9Zix0Ll9maW5pc2hQcm9taXNlX3JlamVjdD1jfSk7Y29uc3Qgcz10Ll9mbHVzaEFsZ29yaXRobSgpO3JldHVybiBscih0KSxfKHMsKCk9PihyLl9zdGF0ZT09PVwiZXJyb3JlZFwiP3J0KHQsci5fc3RvcmVkRXJyb3IpOigkZShyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpLHBuKHQpKSxudWxsKSxmPT4ob2Uoci5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLGYpLHJ0KHQsZiksbnVsbCkpLHQuX2ZpbmlzaFByb21pc2V9bihQcyxcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG1cIik7ZnVuY3Rpb24gdnMoZSl7cmV0dXJuIGFyKGUsITEpLGUuX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2V9bih2cyxcIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIEVzKGUsdCl7Y29uc3Qgcj1lLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyO2lmKHIuX2ZpbmlzaFByb21pc2UhPT12b2lkIDApcmV0dXJuIHIuX2ZpbmlzaFByb21pc2U7Y29uc3Qgcz1lLl93cml0YWJsZTtyLl9maW5pc2hQcm9taXNlPUUoKGMsZCk9PntyLl9maW5pc2hQcm9taXNlX3Jlc29sdmU9YyxyLl9maW5pc2hQcm9taXNlX3JlamVjdD1kfSk7Y29uc3QgZj1yLl9jYW5jZWxBbGdvcml0aG0odCk7cmV0dXJuIGxyKHIpLF8oZiwoKT0+KHMuX3N0YXRlPT09XCJlcnJvcmVkXCI/cnQocixzLl9zdG9yZWRFcnJvcik6KHd0KHMuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcix0KSxobihlKSxwbihyKSksbnVsbCksYz0+KHd0KHMuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcixjKSxobihlKSxydChyLGMpLG51bGwpKSxyLl9maW5pc2hQcm9taXNlfW4oRXMsXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlQ2FuY2VsQWxnb3JpdGhtXCIpO2Z1bmN0aW9uIHVyKGUpe3JldHVybiBuZXcgVHlwZUVycm9yKGBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuJHtlfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKX1uKHVyLFwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uXCIpO2Z1bmN0aW9uIHBuKGUpe2UuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSE9PXZvaWQgMCYmKGUuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSgpLGUuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZT12b2lkIDAsZS5fZmluaXNoUHJvbWlzZV9yZWplY3Q9dm9pZCAwKX1uKHBuLFwiZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVzb2x2ZVwiKTtmdW5jdGlvbiBydChlLHQpe2UuX2ZpbmlzaFByb21pc2VfcmVqZWN0IT09dm9pZCAwJiYoUShlLl9maW5pc2hQcm9taXNlKSxlLl9maW5pc2hQcm9taXNlX3JlamVjdCh0KSxlLl9maW5pc2hQcm9taXNlX3Jlc29sdmU9dm9pZCAwLGUuX2ZpbmlzaFByb21pc2VfcmVqZWN0PXZvaWQgMCl9bihydCxcImRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdFwiKTtmdW5jdGlvbiBsaShlKXtyZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS4ke2V9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1gKX1uKGxpLFwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvblwiKSxhLkJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k9WGUsYS5Db3VudFF1ZXVpbmdTdHJhdGVneT1ldCxhLlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXI9dGUsYS5SZWFkYWJsZVN0cmVhbT1MLGEuUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyPWNlLGEuUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdD1SZSxhLlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI9bmUsYS5SZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI9ZmUsYS5UcmFuc2Zvcm1TdHJlYW09dHQsYS5UcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcj1wZSxhLldyaXRhYmxlU3RyZWFtPWRlLGEuV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcj1rZSxhLldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcj1yZX0pfShwcixwci5leHBvcnRzKSkscHIuZXhwb3J0c31uKExzLFwicmVxdWlyZVBvbnlmaWxsX2VzMjAxOFwiKTtjb25zdCAkcz02NTUzNjtpZighZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSl0cnl7Y29uc3QgaT1yZXF1aXJlKFwibm9kZTpwcm9jZXNzXCIpLHtlbWl0V2FybmluZzpvfT1pO3RyeXtpLmVtaXRXYXJuaW5nPSgpPT57fSxPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMscmVxdWlyZShcIm5vZGU6c3RyZWFtL3dlYlwiKSksaS5lbWl0V2FybmluZz1vfWNhdGNoKGEpe3Rocm93IGkuZW1pdFdhcm5pbmc9byxhfX1jYXRjaHtPYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsTHMoKSl9dHJ5e2NvbnN0e0Jsb2I6aX09cmVxdWlyZShcImJ1ZmZlclwiKTtpJiYhaS5wcm90b3R5cGUuc3RyZWFtJiYoaS5wcm90b3R5cGUuc3RyZWFtPW4oZnVuY3Rpb24oYSl7bGV0IHU9MDtjb25zdCBsPXRoaXM7cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7dHlwZTpcImJ5dGVzXCIsYXN5bmMgcHVsbChwKXtjb25zdCBnPWF3YWl0IGwuc2xpY2UodSxNYXRoLm1pbihsLnNpemUsdSskcykpLmFycmF5QnVmZmVyKCk7dSs9Zy5ieXRlTGVuZ3RoLHAuZW5xdWV1ZShuZXcgVWludDhBcnJheShnKSksdT09PWwuc2l6ZSYmcC5jbG9zZSgpfX0pfSxcIm5hbWVcIikpfWNhdGNoe30vKiEgZmV0Y2gtYmxvYi4gTUlUIExpY2Vuc2UuIEppbW15IFfDpHJ0aW5nIDxodHRwczovL2ppbW15LndhcnRpbmcuc2Uvb3BlbnNvdXJjZT4gKi9jb25zdCBoaT02NTUzNjthc3luYyBmdW5jdGlvbipxbihpLG89ITApe2Zvcihjb25zdCBhIG9mIGkpaWYoXCJzdHJlYW1cImluIGEpeWllbGQqYS5zdHJlYW0oKTtlbHNlIGlmKEFycmF5QnVmZmVyLmlzVmlldyhhKSlpZihvKXtsZXQgdT1hLmJ5dGVPZmZzZXQ7Y29uc3QgbD1hLmJ5dGVPZmZzZXQrYS5ieXRlTGVuZ3RoO2Zvcig7dSE9PWw7KXtjb25zdCBwPU1hdGgubWluKGwtdSxoaSksaD1hLmJ1ZmZlci5zbGljZSh1LHUrcCk7dSs9aC5ieXRlTGVuZ3RoLHlpZWxkIG5ldyBVaW50OEFycmF5KGgpfX1lbHNlIHlpZWxkIGE7ZWxzZXtsZXQgdT0wLGw9YTtmb3IoO3UhPT1sLnNpemU7KXtjb25zdCBoPWF3YWl0IGwuc2xpY2UodSxNYXRoLm1pbihsLnNpemUsdStoaSkpLmFycmF5QnVmZmVyKCk7dSs9aC5ieXRlTGVuZ3RoLHlpZWxkIG5ldyBVaW50OEFycmF5KGgpfX19bihxbixcInRvSXRlcmF0b3JcIik7Y29uc3QgcGk9KFZlPWNsYXNze2NvbnN0cnVjdG9yKG89W10sYT17fSl7YmUodGhpcyx2ZSxbXSk7YmUodGhpcyxrdCxcIlwiKTtiZSh0aGlzLGJ0LDApO2JlKHRoaXMsQ3IsXCJ0cmFuc3BhcmVudFwiKTtpZih0eXBlb2YgbyE9XCJvYmplY3RcInx8bz09PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ0Jsb2InOiBUaGUgcHJvdmlkZWQgdmFsdWUgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIHNlcXVlbmNlLlwiKTtpZih0eXBlb2Ygb1tTeW1ib2wuaXRlcmF0b3JdIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ0Jsb2InOiBUaGUgb2JqZWN0IG11c3QgaGF2ZSBhIGNhbGxhYmxlIEBAaXRlcmF0b3IgcHJvcGVydHkuXCIpO2lmKHR5cGVvZiBhIT1cIm9iamVjdFwiJiZ0eXBlb2YgYSE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdCbG9iJzogcGFyYW1ldGVyIDIgY2Fubm90IGNvbnZlcnQgdG8gZGljdGlvbmFyeS5cIik7YT09PW51bGwmJihhPXt9KTtjb25zdCB1PW5ldyBUZXh0RW5jb2Rlcjtmb3IoY29uc3QgcCBvZiBvKXtsZXQgaDtBcnJheUJ1ZmZlci5pc1ZpZXcocCk/aD1uZXcgVWludDhBcnJheShwLmJ1ZmZlci5zbGljZShwLmJ5dGVPZmZzZXQscC5ieXRlT2Zmc2V0K3AuYnl0ZUxlbmd0aCkpOnAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9oPW5ldyBVaW50OEFycmF5KHAuc2xpY2UoMCkpOnAgaW5zdGFuY2VvZiBWZT9oPXA6aD11LmVuY29kZShgJHtwfWApLFgodGhpcyxidCxPKHRoaXMsYnQpKyhBcnJheUJ1ZmZlci5pc1ZpZXcoaCk/aC5ieXRlTGVuZ3RoOmguc2l6ZSkpLE8odGhpcyx2ZSkucHVzaChoKX1YKHRoaXMsQ3IsYCR7YS5lbmRpbmdzPT09dm9pZCAwP1widHJhbnNwYXJlbnRcIjphLmVuZGluZ3N9YCk7Y29uc3QgbD1hLnR5cGU9PT12b2lkIDA/XCJcIjpTdHJpbmcoYS50eXBlKTtYKHRoaXMsa3QsL15bXFx4MjAtXFx4N0VdKiQvLnRlc3QobCk/bDpcIlwiKX1nZXQgc2l6ZSgpe3JldHVybiBPKHRoaXMsYnQpfWdldCB0eXBlKCl7cmV0dXJuIE8odGhpcyxrdCl9YXN5bmMgdGV4dCgpe2NvbnN0IG89bmV3IFRleHREZWNvZGVyO2xldCBhPVwiXCI7Zm9yIGF3YWl0KGNvbnN0IHUgb2YgcW4oTyh0aGlzLHZlKSwhMSkpYSs9by5kZWNvZGUodSx7c3RyZWFtOiEwfSk7cmV0dXJuIGErPW8uZGVjb2RlKCksYX1hc3luYyBhcnJheUJ1ZmZlcigpe2NvbnN0IG89bmV3IFVpbnQ4QXJyYXkodGhpcy5zaXplKTtsZXQgYT0wO2ZvciBhd2FpdChjb25zdCB1IG9mIHFuKE8odGhpcyx2ZSksITEpKW8uc2V0KHUsYSksYSs9dS5sZW5ndGg7cmV0dXJuIG8uYnVmZmVyfXN0cmVhbSgpe2NvbnN0IG89cW4oTyh0aGlzLHZlKSwhMCk7cmV0dXJuIG5ldyBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtKHt0eXBlOlwiYnl0ZXNcIixhc3luYyBwdWxsKGEpe2NvbnN0IHU9YXdhaXQgby5uZXh0KCk7dS5kb25lP2EuY2xvc2UoKTphLmVucXVldWUodS52YWx1ZSl9LGFzeW5jIGNhbmNlbCgpe2F3YWl0IG8ucmV0dXJuKCl9fSl9c2xpY2Uobz0wLGE9dGhpcy5zaXplLHU9XCJcIil7Y29uc3R7c2l6ZTpsfT10aGlzO2xldCBwPW88MD9NYXRoLm1heChsK28sMCk6TWF0aC5taW4obyxsKSxoPWE8MD9NYXRoLm1heChsK2EsMCk6TWF0aC5taW4oYSxsKTtjb25zdCBnPU1hdGgubWF4KGgtcCwwKSxBPU8odGhpcyx2ZSksdz1bXTtsZXQgRT0wO2Zvcihjb25zdCBiIG9mIEEpe2lmKEU+PWcpYnJlYWs7Y29uc3QgcT1BcnJheUJ1ZmZlci5pc1ZpZXcoYik/Yi5ieXRlTGVuZ3RoOmIuc2l6ZTtpZihwJiZxPD1wKXAtPXEsaC09cTtlbHNle2xldCBfO0FycmF5QnVmZmVyLmlzVmlldyhiKT8oXz1iLnN1YmFycmF5KHAsTWF0aC5taW4ocSxoKSksRSs9Xy5ieXRlTGVuZ3RoKTooXz1iLnNsaWNlKHAsTWF0aC5taW4ocSxoKSksRSs9Xy5zaXplKSxoLT1xLHcucHVzaChfKSxwPTB9fWNvbnN0IFQ9bmV3IFZlKFtdLHt0eXBlOlN0cmluZyh1KS50b0xvd2VyQ2FzZSgpfSk7cmV0dXJuIFgoVCxidCxnKSxYKFQsdmUsdyksVH1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVyblwiQmxvYlwifXN0YXRpY1tTeW1ib2wuaGFzSW5zdGFuY2VdKG8pe3JldHVybiBvJiZ0eXBlb2Ygbz09XCJvYmplY3RcIiYmdHlwZW9mIG8uY29uc3RydWN0b3I9PVwiZnVuY3Rpb25cIiYmKHR5cGVvZiBvLnN0cmVhbT09XCJmdW5jdGlvblwifHx0eXBlb2Ygby5hcnJheUJ1ZmZlcj09XCJmdW5jdGlvblwiKSYmL14oQmxvYnxGaWxlKSQvLnRlc3Qob1tTeW1ib2wudG9TdHJpbmdUYWddKX19LHZlPW5ldyBXZWFrTWFwLGt0PW5ldyBXZWFrTWFwLGJ0PW5ldyBXZWFrTWFwLENyPW5ldyBXZWFrTWFwLG4oVmUsXCJCbG9iXCIpLFZlKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwaS5wcm90b3R5cGUse3NpemU6e2VudW1lcmFibGU6ITB9LHR5cGU6e2VudW1lcmFibGU6ITB9LHNsaWNlOntlbnVtZXJhYmxlOiEwfX0pO2NvbnN0IERzPXBpLHV0PURzLE1zPShPdD1jbGFzcyBleHRlbmRzIHV0e2NvbnN0cnVjdG9yKGEsdSxsPXt9KXtpZihhcmd1bWVudHMubGVuZ3RoPDIpdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGNvbnN0cnVjdCAnRmlsZSc6IDIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAke2FyZ3VtZW50cy5sZW5ndGh9IHByZXNlbnQuYCk7c3VwZXIoYSxsKTtiZSh0aGlzLFd0LDApO2JlKHRoaXMscXQsXCJcIik7bD09PW51bGwmJihsPXt9KTtjb25zdCBwPWwubGFzdE1vZGlmaWVkPT09dm9pZCAwP0RhdGUubm93KCk6TnVtYmVyKGwubGFzdE1vZGlmaWVkKTtOdW1iZXIuaXNOYU4ocCl8fFgodGhpcyxXdCxwKSxYKHRoaXMscXQsU3RyaW5nKHUpKX1nZXQgbmFtZSgpe3JldHVybiBPKHRoaXMscXQpfWdldCBsYXN0TW9kaWZpZWQoKXtyZXR1cm4gTyh0aGlzLFd0KX1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVyblwiRmlsZVwifXN0YXRpY1tTeW1ib2wuaGFzSW5zdGFuY2VdKGEpe3JldHVybiEhYSYmYSBpbnN0YW5jZW9mIHV0JiYvXihGaWxlKSQvLnRlc3QoYVtTeW1ib2wudG9TdHJpbmdUYWddKX19LFd0PW5ldyBXZWFrTWFwLHF0PW5ldyBXZWFrTWFwLG4oT3QsXCJGaWxlXCIpLE90KSxVcz1NcyxPbj1VczsvKiEgZm9ybWRhdGEtcG9seWZpbGwuIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICovdmFye3RvU3RyaW5nVGFnOkV0LGl0ZXJhdG9yOnhzLGhhc0luc3RhbmNlOk5zfT1TeW1ib2wsYmk9TWF0aC5yYW5kb20sSHM9XCJhcHBlbmQsc2V0LGdldCxnZXRBbGwsZGVsZXRlLGtleXMsdmFsdWVzLGVudHJpZXMsZm9yRWFjaCxjb25zdHJ1Y3RvclwiLnNwbGl0KFwiLFwiKSxtaT1uKChpLG8sYSk9PihpKz1cIlwiLC9eKEJsb2J8RmlsZSkkLy50ZXN0KG8mJm9bRXRdKT9bKGE9YSE9PXZvaWQgMD9hK1wiXCI6b1tFdF09PVwiRmlsZVwiP28ubmFtZTpcImJsb2JcIixpKSxvLm5hbWUhPT1hfHxvW0V0XT09XCJibG9iXCI/bmV3IE9uKFtvXSxhLG8pOm9dOltpLG8rXCJcIl0pLFwiZlwiKSx6bj1uKChpLG8pPT4obz9pOmkucmVwbGFjZSgvXFxyP1xcbnxcXHIvZyxgXFxyXG5gKSkucmVwbGFjZSgvXFxuL2csXCIlMEFcIikucmVwbGFjZSgvXFxyL2csXCIlMERcIikucmVwbGFjZSgvXCIvZyxcIiUyMlwiKSxcImUkMVwiKSxNZT1uKChpLG8sYSk9PntpZihvLmxlbmd0aDxhKXRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICcke2l9JyBvbiAnRm9ybURhdGEnOiAke2F9IGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHtvLmxlbmd0aH0gcHJlc2VudC5gKX0sXCJ4XCIpO2NvbnN0IGJyPSh6dD1jbGFzc3tjb25zdHJ1Y3RvciguLi5vKXtiZSh0aGlzLGVlLFtdKTtpZihvLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnRm9ybURhdGEnOiBwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSAnSFRNTEZvcm1FbGVtZW50Jy5cIil9Z2V0W0V0XSgpe3JldHVyblwiRm9ybURhdGFcIn1beHNdKCl7cmV0dXJuIHRoaXMuZW50cmllcygpfXN0YXRpY1tOc10obyl7cmV0dXJuIG8mJnR5cGVvZiBvPT1cIm9iamVjdFwiJiZvW0V0XT09PVwiRm9ybURhdGFcIiYmIUhzLnNvbWUoYT0+dHlwZW9mIG9bYV0hPVwiZnVuY3Rpb25cIil9YXBwZW5kKC4uLm8pe01lKFwiYXBwZW5kXCIsYXJndW1lbnRzLDIpLE8odGhpcyxlZSkucHVzaChtaSguLi5vKSl9ZGVsZXRlKG8pe01lKFwiZGVsZXRlXCIsYXJndW1lbnRzLDEpLG8rPVwiXCIsWCh0aGlzLGVlLE8odGhpcyxlZSkuZmlsdGVyKChbYV0pPT5hIT09bykpfWdldChvKXtNZShcImdldFwiLGFyZ3VtZW50cywxKSxvKz1cIlwiO2Zvcih2YXIgYT1PKHRoaXMsZWUpLHU9YS5sZW5ndGgsbD0wO2w8dTtsKyspaWYoYVtsXVswXT09PW8pcmV0dXJuIGFbbF1bMV07cmV0dXJuIG51bGx9Z2V0QWxsKG8sYSl7cmV0dXJuIE1lKFwiZ2V0QWxsXCIsYXJndW1lbnRzLDEpLGE9W10sbys9XCJcIixPKHRoaXMsZWUpLmZvckVhY2godT0+dVswXT09PW8mJmEucHVzaCh1WzFdKSksYX1oYXMobyl7cmV0dXJuIE1lKFwiaGFzXCIsYXJndW1lbnRzLDEpLG8rPVwiXCIsTyh0aGlzLGVlKS5zb21lKGE9PmFbMF09PT1vKX1mb3JFYWNoKG8sYSl7TWUoXCJmb3JFYWNoXCIsYXJndW1lbnRzLDEpO2Zvcih2YXJbdSxsXW9mIHRoaXMpby5jYWxsKGEsbCx1LHRoaXMpfXNldCguLi5vKXtNZShcInNldFwiLGFyZ3VtZW50cywyKTt2YXIgYT1bXSx1PSEwO289bWkoLi4ubyksTyh0aGlzLGVlKS5mb3JFYWNoKGw9PntsWzBdPT09b1swXT91JiYodT0hYS5wdXNoKG8pKTphLnB1c2gobCl9KSx1JiZhLnB1c2gobyksWCh0aGlzLGVlLGEpfSplbnRyaWVzKCl7eWllbGQqTyh0aGlzLGVlKX0qa2V5cygpe2Zvcih2YXJbb11vZiB0aGlzKXlpZWxkIG99KnZhbHVlcygpe2Zvcih2YXJbLG9db2YgdGhpcyl5aWVsZCBvfX0sZWU9bmV3IFdlYWtNYXAsbih6dCxcIkZvcm1EYXRhXCIpLHp0KTtmdW5jdGlvbiBWcyhpLG89dXQpe3ZhciBhPWAke2JpKCl9JHtiaSgpfWAucmVwbGFjZSgvXFwuL2csXCJcIikuc2xpY2UoLTI4KS5wYWRTdGFydCgzMixcIi1cIiksdT1bXSxsPWAtLSR7YX1cXHJcbkNvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cImA7cmV0dXJuIGkuZm9yRWFjaCgocCxoKT0+dHlwZW9mIHA9PVwic3RyaW5nXCI/dS5wdXNoKGwrem4oaCkrYFwiXFxyXG5cXHJcbiR7cC5yZXBsYWNlKC9cXHIoPyFcXG4pfCg/PCFcXHIpXFxuL2csYFxcclxuYCl9XFxyXG5gKTp1LnB1c2gobCt6bihoKStgXCI7IGZpbGVuYW1lPVwiJHt6bihwLm5hbWUsMSl9XCJcXHJcbkNvbnRlbnQtVHlwZTogJHtwLnR5cGV8fFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9XFxyXG5cXHJcbmAscCxgXFxyXG5gKSksdS5wdXNoKGAtLSR7YX0tLWApLG5ldyBvKHUse3R5cGU6XCJtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1cIithfSl9bihWcyxcImZvcm1EYXRhVG9CbG9iXCIpO2NvbnN0IFVuPWNsYXNzIFVuIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IobyxhKXtzdXBlcihvKSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHRoaXMuY29uc3RydWN0b3IpLHRoaXMudHlwZT1hfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZX1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWV9fTtuKFVuLFwiRmV0Y2hCYXNlRXJyb3JcIik7bGV0IGZ0PVVuO2NvbnN0IHhuPWNsYXNzIHhuIGV4dGVuZHMgZnR7Y29uc3RydWN0b3IobyxhLHUpe3N1cGVyKG8sYSksdSYmKHRoaXMuY29kZT10aGlzLmVycm5vPXUuY29kZSx0aGlzLmVycm9yZWRTeXNDYWxsPXUuc3lzY2FsbCl9fTtuKHhuLFwiRmV0Y2hFcnJvclwiKTtsZXQgRz14bjtjb25zdCBtcj1TeW1ib2wudG9TdHJpbmdUYWcseWk9bihpPT50eXBlb2YgaT09XCJvYmplY3RcIiYmdHlwZW9mIGkuYXBwZW5kPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBpLmRlbGV0ZT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgaS5nZXQ9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGkuZ2V0QWxsPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBpLmhhcz09XCJmdW5jdGlvblwiJiZ0eXBlb2YgaS5zZXQ9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGkuc29ydD09XCJmdW5jdGlvblwiJiZpW21yXT09PVwiVVJMU2VhcmNoUGFyYW1zXCIsXCJpc1VSTFNlYXJjaFBhcmFtZXRlcnNcIikseXI9bihpPT5pJiZ0eXBlb2YgaT09XCJvYmplY3RcIiYmdHlwZW9mIGkuYXJyYXlCdWZmZXI9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGkudHlwZT09XCJzdHJpbmdcIiYmdHlwZW9mIGkuc3RyZWFtPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBpLmNvbnN0cnVjdG9yPT1cImZ1bmN0aW9uXCImJi9eKEJsb2J8RmlsZSkkLy50ZXN0KGlbbXJdKSxcImlzQmxvYlwiKSxRcz1uKGk9PnR5cGVvZiBpPT1cIm9iamVjdFwiJiYoaVttcl09PT1cIkFib3J0U2lnbmFsXCJ8fGlbbXJdPT09XCJFdmVudFRhcmdldFwiKSxcImlzQWJvcnRTaWduYWxcIiksWXM9bigoaSxvKT0+e2NvbnN0IGE9bmV3IFVSTChvKS5ob3N0bmFtZSx1PW5ldyBVUkwoaSkuaG9zdG5hbWU7cmV0dXJuIGE9PT11fHxhLmVuZHNXaXRoKGAuJHt1fWApfSxcImlzRG9tYWluT3JTdWJkb21haW5cIiksR3M9bigoaSxvKT0+e2NvbnN0IGE9bmV3IFVSTChvKS5wcm90b2NvbCx1PW5ldyBVUkwoaSkucHJvdG9jb2w7cmV0dXJuIGE9PT11fSxcImlzU2FtZVByb3RvY29sXCIpLFpzPWtzKG1lLnBpcGVsaW5lKSxIPVN5bWJvbChcIkJvZHkgaW50ZXJuYWxzXCIpLE5uPWNsYXNzIE5ue2NvbnN0cnVjdG9yKG8se3NpemU6YT0wfT17fSl7bGV0IHU9bnVsbDtvPT09bnVsbD9vPW51bGw6eWkobyk/bz1NLmZyb20oby50b1N0cmluZygpKTp5cihvKXx8TS5pc0J1ZmZlcihvKXx8KGRyLmlzQW55QXJyYXlCdWZmZXIobyk/bz1NLmZyb20obyk6QXJyYXlCdWZmZXIuaXNWaWV3KG8pP289TS5mcm9tKG8uYnVmZmVyLG8uYnl0ZU9mZnNldCxvLmJ5dGVMZW5ndGgpOm8gaW5zdGFuY2VvZiBtZXx8KG8gaW5zdGFuY2VvZiBicj8obz1WcyhvKSx1PW8udHlwZS5zcGxpdChcIj1cIilbMV0pOm89TS5mcm9tKFN0cmluZyhvKSkpKTtsZXQgbD1vO00uaXNCdWZmZXIobyk/bD1tZS5SZWFkYWJsZS5mcm9tKG8pOnlyKG8pJiYobD1tZS5SZWFkYWJsZS5mcm9tKG8uc3RyZWFtKCkpKSx0aGlzW0hdPXtib2R5Om8sc3RyZWFtOmwsYm91bmRhcnk6dSxkaXN0dXJiZWQ6ITEsZXJyb3I6bnVsbH0sdGhpcy5zaXplPWEsbyBpbnN0YW5jZW9mIG1lJiZvLm9uKFwiZXJyb3JcIixwPT57Y29uc3QgaD1wIGluc3RhbmNlb2YgZnQ/cDpuZXcgRyhgSW52YWxpZCByZXNwb25zZSBib2R5IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke3RoaXMudXJsfTogJHtwLm1lc3NhZ2V9YCxcInN5c3RlbVwiLHApO3RoaXNbSF0uZXJyb3I9aH0pfWdldCBib2R5KCl7cmV0dXJuIHRoaXNbSF0uc3RyZWFtfWdldCBib2R5VXNlZCgpe3JldHVybiB0aGlzW0hdLmRpc3R1cmJlZH1hc3luYyBhcnJheUJ1ZmZlcigpe2NvbnN0e2J1ZmZlcjpvLGJ5dGVPZmZzZXQ6YSxieXRlTGVuZ3RoOnV9PWF3YWl0IEluKHRoaXMpO3JldHVybiBvLnNsaWNlKGEsYSt1KX1hc3luYyBmb3JtRGF0YSgpe2NvbnN0IG89dGhpcy5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtpZihvLnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikpe2NvbnN0IHU9bmV3IGJyLGw9bmV3IFVSTFNlYXJjaFBhcmFtcyhhd2FpdCB0aGlzLnRleHQoKSk7Zm9yKGNvbnN0W3AsaF1vZiBsKXUuYXBwZW5kKHAsaCk7cmV0dXJuIHV9Y29uc3R7dG9Gb3JtRGF0YTphfT1hd2FpdCBpbXBvcnQoXCIuL2NodW5rcy9tdWx0aXBhcnQtcGFyc2VyLm1qc1wiKTtyZXR1cm4gYSh0aGlzLmJvZHksbyl9YXN5bmMgYmxvYigpe2NvbnN0IG89dGhpcy5oZWFkZXJzJiZ0aGlzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpfHx0aGlzW0hdLmJvZHkmJnRoaXNbSF0uYm9keS50eXBlfHxcIlwiLGE9YXdhaXQgdGhpcy5hcnJheUJ1ZmZlcigpO3JldHVybiBuZXcgdXQoW2FdLHt0eXBlOm99KX1hc3luYyBqc29uKCl7Y29uc3Qgbz1hd2FpdCB0aGlzLnRleHQoKTtyZXR1cm4gSlNPTi5wYXJzZShvKX1hc3luYyB0ZXh0KCl7Y29uc3Qgbz1hd2FpdCBJbih0aGlzKTtyZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG8pfWJ1ZmZlcigpe3JldHVybiBJbih0aGlzKX19O24oTm4sXCJCb2R5XCIpO2xldCBVZT1ObjtVZS5wcm90b3R5cGUuYnVmZmVyPWhyKFVlLnByb3RvdHlwZS5idWZmZXIsXCJQbGVhc2UgdXNlICdyZXNwb25zZS5hcnJheUJ1ZmZlcigpJyBpbnN0ZWFkIG9mICdyZXNwb25zZS5idWZmZXIoKSdcIixcIm5vZGUtZmV0Y2gjYnVmZmVyXCIpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFVlLnByb3RvdHlwZSx7Ym9keTp7ZW51bWVyYWJsZTohMH0sYm9keVVzZWQ6e2VudW1lcmFibGU6ITB9LGFycmF5QnVmZmVyOntlbnVtZXJhYmxlOiEwfSxibG9iOntlbnVtZXJhYmxlOiEwfSxqc29uOntlbnVtZXJhYmxlOiEwfSx0ZXh0OntlbnVtZXJhYmxlOiEwfSxkYXRhOntnZXQ6aHIoKCk9Pnt9LFwiZGF0YSBkb2Vzbid0IGV4aXN0LCB1c2UganNvbigpLCB0ZXh0KCksIGFycmF5QnVmZmVyKCksIG9yIGJvZHkgaW5zdGVhZFwiLFwiaHR0cHM6Ly9naXRodWIuY29tL25vZGUtZmV0Y2gvbm9kZS1mZXRjaC9pc3N1ZXMvMTAwMCAocmVzcG9uc2UpXCIpfX0pO2FzeW5jIGZ1bmN0aW9uIEluKGkpe2lmKGlbSF0uZGlzdHVyYmVkKXRocm93IG5ldyBUeXBlRXJyb3IoYGJvZHkgdXNlZCBhbHJlYWR5IGZvcjogJHtpLnVybH1gKTtpZihpW0hdLmRpc3R1cmJlZD0hMCxpW0hdLmVycm9yKXRocm93IGlbSF0uZXJyb3I7Y29uc3R7Ym9keTpvfT1pO2lmKG89PT1udWxsKXJldHVybiBNLmFsbG9jKDApO2lmKCEobyBpbnN0YW5jZW9mIG1lKSlyZXR1cm4gTS5hbGxvYygwKTtjb25zdCBhPVtdO2xldCB1PTA7dHJ5e2ZvciBhd2FpdChjb25zdCBsIG9mIG8pe2lmKGkuc2l6ZT4wJiZ1K2wubGVuZ3RoPmkuc2l6ZSl7Y29uc3QgcD1uZXcgRyhgY29udGVudCBzaXplIGF0ICR7aS51cmx9IG92ZXIgbGltaXQ6ICR7aS5zaXplfWAsXCJtYXgtc2l6ZVwiKTt0aHJvdyBvLmRlc3Ryb3kocCkscH11Kz1sLmxlbmd0aCxhLnB1c2gobCl9fWNhdGNoKGwpe3Rocm93IGwgaW5zdGFuY2VvZiBmdD9sOm5ldyBHKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7aS51cmx9OiAke2wubWVzc2FnZX1gLFwic3lzdGVtXCIsbCl9aWYoby5yZWFkYWJsZUVuZGVkPT09ITB8fG8uX3JlYWRhYmxlU3RhdGUuZW5kZWQ9PT0hMCl0cnl7cmV0dXJuIGEuZXZlcnkobD0+dHlwZW9mIGw9PVwic3RyaW5nXCIpP00uZnJvbShhLmpvaW4oXCJcIikpOk0uY29uY2F0KGEsdSl9Y2F0Y2gobCl7dGhyb3cgbmV3IEcoYENvdWxkIG5vdCBjcmVhdGUgQnVmZmVyIGZyb20gcmVzcG9uc2UgYm9keSBmb3IgJHtpLnVybH06ICR7bC5tZXNzYWdlfWAsXCJzeXN0ZW1cIixsKX1lbHNlIHRocm93IG5ldyBHKGBQcmVtYXR1cmUgY2xvc2Ugb2Ygc2VydmVyIHJlc3BvbnNlIHdoaWxlIHRyeWluZyB0byBmZXRjaCAke2kudXJsfWApfW4oSW4sXCJjb25zdW1lQm9keVwiKTtjb25zdCBGbj1uKChpLG8pPT57bGV0IGEsdSx7Ym9keTpsfT1pW0hdO2lmKGkuYm9keVVzZWQpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNsb25lIGJvZHkgYWZ0ZXIgaXQgaXMgdXNlZFwiKTtyZXR1cm4gbCBpbnN0YW5jZW9mIG1lJiZ0eXBlb2YgbC5nZXRCb3VuZGFyeSE9XCJmdW5jdGlvblwiJiYoYT1uZXcgY3Ioe2hpZ2hXYXRlck1hcms6b30pLHU9bmV3IGNyKHtoaWdoV2F0ZXJNYXJrOm99KSxsLnBpcGUoYSksbC5waXBlKHUpLGlbSF0uc3RyZWFtPWEsbD11KSxsfSxcImNsb25lXCIpLEtzPWhyKGk9PmkuZ2V0Qm91bmRhcnkoKSxcImZvcm0tZGF0YSBkb2Vzbid0IGZvbGxvdyB0aGUgc3BlYyBhbmQgcmVxdWlyZXMgc3BlY2lhbCB0cmVhdG1lbnQuIFVzZSBhbHRlcm5hdGl2ZSBwYWNrYWdlXCIsXCJodHRwczovL2dpdGh1Yi5jb20vbm9kZS1mZXRjaC9ub2RlLWZldGNoL2lzc3Vlcy8xMTY3XCIpLGdpPW4oKGksbyk9Pmk9PT1udWxsP251bGw6dHlwZW9mIGk9PVwic3RyaW5nXCI/XCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIjp5aShpKT9cImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04XCI6eXIoaSk/aS50eXBlfHxudWxsOk0uaXNCdWZmZXIoaSl8fGRyLmlzQW55QXJyYXlCdWZmZXIoaSl8fEFycmF5QnVmZmVyLmlzVmlldyhpKT9udWxsOmkgaW5zdGFuY2VvZiBicj9gbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JHtvW0hdLmJvdW5kYXJ5fWA6aSYmdHlwZW9mIGkuZ2V0Qm91bmRhcnk9PVwiZnVuY3Rpb25cIj9gbXVsdGlwYXJ0L2Zvcm0tZGF0YTtib3VuZGFyeT0ke0tzKGkpfWA6aSBpbnN0YW5jZW9mIG1lP251bGw6XCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIixcImV4dHJhY3RDb250ZW50VHlwZVwiKSxKcz1uKGk9Pntjb25zdHtib2R5Om99PWlbSF07cmV0dXJuIG89PT1udWxsPzA6eXIobyk/by5zaXplOk0uaXNCdWZmZXIobyk/by5sZW5ndGg6byYmdHlwZW9mIG8uZ2V0TGVuZ3RoU3luYz09XCJmdW5jdGlvblwiJiZvLmhhc0tub3duTGVuZ3RoJiZvLmhhc0tub3duTGVuZ3RoKCk/by5nZXRMZW5ndGhTeW5jKCk6bnVsbH0sXCJnZXRUb3RhbEJ5dGVzXCIpLFhzPW4oYXN5bmMoaSx7Ym9keTpvfSk9PntvPT09bnVsbD9pLmVuZCgpOmF3YWl0IFpzKG8saSl9LFwid3JpdGVUb1N0cmVhbVwiKSxncj10eXBlb2YgdnQudmFsaWRhdGVIZWFkZXJOYW1lPT1cImZ1bmN0aW9uXCI/dnQudmFsaWRhdGVIZWFkZXJOYW1lOmk9PntpZighL15bXFxeYFxcLVxcdyEjJCUmJyorLnx+XSskLy50ZXN0KGkpKXtjb25zdCBvPW5ldyBUeXBlRXJyb3IoYEhlYWRlciBuYW1lIG11c3QgYmUgYSB2YWxpZCBIVFRQIHRva2VuIFske2l9XWApO3Rocm93IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwiY29kZVwiLHt2YWx1ZTpcIkVSUl9JTlZBTElEX0hUVFBfVE9LRU5cIn0pLG99fSxqbj10eXBlb2YgdnQudmFsaWRhdGVIZWFkZXJWYWx1ZT09XCJmdW5jdGlvblwiP3Z0LnZhbGlkYXRlSGVhZGVyVmFsdWU6KGksbyk9PntpZigvW15cXHRcXHUwMDIwLVxcdTAwN0VcXHUwMDgwLVxcdTAwRkZdLy50ZXN0KG8pKXtjb25zdCBhPW5ldyBUeXBlRXJyb3IoYEludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBjb250ZW50IFtcIiR7aX1cIl1gKTt0aHJvdyBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImNvZGVcIix7dmFsdWU6XCJFUlJfSU5WQUxJRF9DSEFSXCJ9KSxhfX0sUHI9Y2xhc3MgUHIgZXh0ZW5kcyBVUkxTZWFyY2hQYXJhbXN7Y29uc3RydWN0b3Iobyl7bGV0IGE9W107aWYobyBpbnN0YW5jZW9mIFByKXtjb25zdCB1PW8ucmF3KCk7Zm9yKGNvbnN0W2wscF1vZiBPYmplY3QuZW50cmllcyh1KSlhLnB1c2goLi4ucC5tYXAoaD0+W2wsaF0pKX1lbHNlIGlmKG8hPW51bGwpaWYodHlwZW9mIG89PVwib2JqZWN0XCImJiFkci5pc0JveGVkUHJpbWl0aXZlKG8pKXtjb25zdCB1PW9bU3ltYm9sLml0ZXJhdG9yXTtpZih1PT1udWxsKWEucHVzaCguLi5PYmplY3QuZW50cmllcyhvKSk7ZWxzZXtpZih0eXBlb2YgdSE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJIZWFkZXIgcGFpcnMgbXVzdCBiZSBpdGVyYWJsZVwiKTthPVsuLi5vXS5tYXAobD0+e2lmKHR5cGVvZiBsIT1cIm9iamVjdFwifHxkci5pc0JveGVkUHJpbWl0aXZlKGwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYW4gaXRlcmFibGUgb2JqZWN0XCIpO3JldHVyblsuLi5sXX0pLm1hcChsPT57aWYobC5sZW5ndGghPT0yKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgYSBuYW1lL3ZhbHVlIHR1cGxlXCIpO3JldHVyblsuLi5sXX0pfX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdIZWFkZXJzJzogVGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBvZiB0eXBlICcoc2VxdWVuY2U8c2VxdWVuY2U8Qnl0ZVN0cmluZz4+IG9yIHJlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPilcIik7cmV0dXJuIGE9YS5sZW5ndGg+MD9hLm1hcCgoW3UsbF0pPT4oZ3IodSksam4odSxTdHJpbmcobCkpLFtTdHJpbmcodSkudG9Mb3dlckNhc2UoKSxTdHJpbmcobCldKSk6dm9pZCAwLHN1cGVyKGEpLG5ldyBQcm94eSh0aGlzLHtnZXQodSxsLHApe3N3aXRjaChsKXtjYXNlXCJhcHBlbmRcIjpjYXNlXCJzZXRcIjpyZXR1cm4oaCxnKT0+KGdyKGgpLGpuKGgsU3RyaW5nKGcpKSxVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlW2xdLmNhbGwodSxTdHJpbmcoaCkudG9Mb3dlckNhc2UoKSxTdHJpbmcoZykpKTtjYXNlXCJkZWxldGVcIjpjYXNlXCJoYXNcIjpjYXNlXCJnZXRBbGxcIjpyZXR1cm4gaD0+KGdyKGgpLFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGVbbF0uY2FsbCh1LFN0cmluZyhoKS50b0xvd2VyQ2FzZSgpKSk7Y2FzZVwia2V5c1wiOnJldHVybigpPT4odS5zb3J0KCksbmV3IFNldChVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmtleXMuY2FsbCh1KSkua2V5cygpKTtkZWZhdWx0OnJldHVybiBSZWZsZWN0LmdldCh1LGwscCl9fX0pfWdldFtTeW1ib2wudG9TdHJpbmdUYWddKCl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZX10b1N0cmluZygpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcyl9Z2V0KG8pe2NvbnN0IGE9dGhpcy5nZXRBbGwobyk7aWYoYS5sZW5ndGg9PT0wKXJldHVybiBudWxsO2xldCB1PWEuam9pbihcIiwgXCIpO3JldHVybi9eY29udGVudC1lbmNvZGluZyQvaS50ZXN0KG8pJiYodT11LnRvTG93ZXJDYXNlKCkpLHV9Zm9yRWFjaChvLGE9dm9pZCAwKXtmb3IoY29uc3QgdSBvZiB0aGlzLmtleXMoKSlSZWZsZWN0LmFwcGx5KG8sYSxbdGhpcy5nZXQodSksdSx0aGlzXSl9KnZhbHVlcygpe2Zvcihjb25zdCBvIG9mIHRoaXMua2V5cygpKXlpZWxkIHRoaXMuZ2V0KG8pfSplbnRyaWVzKCl7Zm9yKGNvbnN0IG8gb2YgdGhpcy5rZXlzKCkpeWllbGRbbyx0aGlzLmdldChvKV19W1N5bWJvbC5pdGVyYXRvcl0oKXtyZXR1cm4gdGhpcy5lbnRyaWVzKCl9cmF3KCl7cmV0dXJuWy4uLnRoaXMua2V5cygpXS5yZWR1Y2UoKG8sYSk9PihvW2FdPXRoaXMuZ2V0QWxsKGEpLG8pLHt9KX1bU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSgpe3JldHVyblsuLi50aGlzLmtleXMoKV0ucmVkdWNlKChvLGEpPT57Y29uc3QgdT10aGlzLmdldEFsbChhKTtyZXR1cm4gYT09PVwiaG9zdFwiP29bYV09dVswXTpvW2FdPXUubGVuZ3RoPjE/dTp1WzBdLG99LHt9KX19O24oUHIsXCJIZWFkZXJzXCIpO2xldCB5ZT1QcjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh5ZS5wcm90b3R5cGUsW1wiZ2V0XCIsXCJlbnRyaWVzXCIsXCJmb3JFYWNoXCIsXCJ2YWx1ZXNcIl0ucmVkdWNlKChpLG8pPT4oaVtvXT17ZW51bWVyYWJsZTohMH0saSkse30pKTtmdW5jdGlvbiBlbChpPVtdKXtyZXR1cm4gbmV3IHllKGkucmVkdWNlKChvLGEsdSxsKT0+KHUlMj09PTAmJm8ucHVzaChsLnNsaWNlKHUsdSsyKSksbyksW10pLmZpbHRlcigoW28sYV0pPT57dHJ5e3JldHVybiBncihvKSxqbihvLFN0cmluZyhhKSksITB9Y2F0Y2h7cmV0dXJuITF9fSkpfW4oZWwsXCJmcm9tUmF3SGVhZGVyc1wiKTtjb25zdCB0bD1uZXcgU2V0KFszMDEsMzAyLDMwMywzMDcsMzA4XSksTG49bihpPT50bC5oYXMoaSksXCJpc1JlZGlyZWN0XCIpLHNlPVN5bWJvbChcIlJlc3BvbnNlIGludGVybmFsc1wiKSx4ZT1jbGFzcyB4ZSBleHRlbmRzIFVle2NvbnN0cnVjdG9yKG89bnVsbCxhPXt9KXtzdXBlcihvLGEpO2NvbnN0IHU9YS5zdGF0dXMhPW51bGw/YS5zdGF0dXM6MjAwLGw9bmV3IHllKGEuaGVhZGVycyk7aWYobyE9PW51bGwmJiFsLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSl7Y29uc3QgcD1naShvLHRoaXMpO3AmJmwuYXBwZW5kKFwiQ29udGVudC1UeXBlXCIscCl9dGhpc1tzZV09e3R5cGU6XCJkZWZhdWx0XCIsdXJsOmEudXJsLHN0YXR1czp1LHN0YXR1c1RleHQ6YS5zdGF0dXNUZXh0fHxcIlwiLGhlYWRlcnM6bCxjb3VudGVyOmEuY291bnRlcixoaWdoV2F0ZXJNYXJrOmEuaGlnaFdhdGVyTWFya319Z2V0IHR5cGUoKXtyZXR1cm4gdGhpc1tzZV0udHlwZX1nZXQgdXJsKCl7cmV0dXJuIHRoaXNbc2VdLnVybHx8XCJcIn1nZXQgc3RhdHVzKCl7cmV0dXJuIHRoaXNbc2VdLnN0YXR1c31nZXQgb2soKXtyZXR1cm4gdGhpc1tzZV0uc3RhdHVzPj0yMDAmJnRoaXNbc2VdLnN0YXR1czwzMDB9Z2V0IHJlZGlyZWN0ZWQoKXtyZXR1cm4gdGhpc1tzZV0uY291bnRlcj4wfWdldCBzdGF0dXNUZXh0KCl7cmV0dXJuIHRoaXNbc2VdLnN0YXR1c1RleHR9Z2V0IGhlYWRlcnMoKXtyZXR1cm4gdGhpc1tzZV0uaGVhZGVyc31nZXQgaGlnaFdhdGVyTWFyaygpe3JldHVybiB0aGlzW3NlXS5oaWdoV2F0ZXJNYXJrfWNsb25lKCl7cmV0dXJuIG5ldyB4ZShGbih0aGlzLHRoaXMuaGlnaFdhdGVyTWFyaykse3R5cGU6dGhpcy50eXBlLHVybDp0aGlzLnVybCxzdGF0dXM6dGhpcy5zdGF0dXMsc3RhdHVzVGV4dDp0aGlzLnN0YXR1c1RleHQsaGVhZGVyczp0aGlzLmhlYWRlcnMsb2s6dGhpcy5vayxyZWRpcmVjdGVkOnRoaXMucmVkaXJlY3RlZCxzaXplOnRoaXMuc2l6ZSxoaWdoV2F0ZXJNYXJrOnRoaXMuaGlnaFdhdGVyTWFya30pfXN0YXRpYyByZWRpcmVjdChvLGE9MzAyKXtpZighTG4oYSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ZhaWxlZCB0byBleGVjdXRlIFwicmVkaXJlY3RcIiBvbiBcInJlc3BvbnNlXCI6IEludmFsaWQgc3RhdHVzIGNvZGUnKTtyZXR1cm4gbmV3IHhlKG51bGwse2hlYWRlcnM6e2xvY2F0aW9uOm5ldyBVUkwobykudG9TdHJpbmcoKX0sc3RhdHVzOmF9KX1zdGF0aWMgZXJyb3IoKXtjb25zdCBvPW5ldyB4ZShudWxsLHtzdGF0dXM6MCxzdGF0dXNUZXh0OlwiXCJ9KTtyZXR1cm4gb1tzZV0udHlwZT1cImVycm9yXCIsb31zdGF0aWMganNvbihvPXZvaWQgMCxhPXt9KXtjb25zdCB1PUpTT04uc3RyaW5naWZ5KG8pO2lmKHU9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihcImRhdGEgaXMgbm90IEpTT04gc2VyaWFsaXphYmxlXCIpO2NvbnN0IGw9bmV3IHllKGEmJmEuaGVhZGVycyk7cmV0dXJuIGwuaGFzKFwiY29udGVudC10eXBlXCIpfHxsLnNldChcImNvbnRlbnQtdHlwZVwiLFwiYXBwbGljYXRpb24vanNvblwiKSxuZXcgeGUodSx7Li4uYSxoZWFkZXJzOmx9KX1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVyblwiUmVzcG9uc2VcIn19O24oeGUsXCJSZXNwb25zZVwiKTtsZXQgbGU9eGU7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGUucHJvdG90eXBlLHt0eXBlOntlbnVtZXJhYmxlOiEwfSx1cmw6e2VudW1lcmFibGU6ITB9LHN0YXR1czp7ZW51bWVyYWJsZTohMH0sb2s6e2VudW1lcmFibGU6ITB9LHJlZGlyZWN0ZWQ6e2VudW1lcmFibGU6ITB9LHN0YXR1c1RleHQ6e2VudW1lcmFibGU6ITB9LGhlYWRlcnM6e2VudW1lcmFibGU6ITB9LGNsb25lOntlbnVtZXJhYmxlOiEwfX0pO2NvbnN0IHJsPW4oaT0+e2lmKGkuc2VhcmNoKXJldHVybiBpLnNlYXJjaDtjb25zdCBvPWkuaHJlZi5sZW5ndGgtMSxhPWkuaGFzaHx8KGkuaHJlZltvXT09PVwiI1wiP1wiI1wiOlwiXCIpO3JldHVybiBpLmhyZWZbby1hLmxlbmd0aF09PT1cIj9cIj9cIj9cIjpcIlwifSxcImdldFNlYXJjaFwiKTtmdW5jdGlvbiBfaShpLG89ITEpe3JldHVybiBpPT1udWxsfHwoaT1uZXcgVVJMKGkpLC9eKGFib3V0fGJsb2J8ZGF0YSk6JC8udGVzdChpLnByb3RvY29sKSk/XCJuby1yZWZlcnJlclwiOihpLnVzZXJuYW1lPVwiXCIsaS5wYXNzd29yZD1cIlwiLGkuaGFzaD1cIlwiLG8mJihpLnBhdGhuYW1lPVwiXCIsaS5zZWFyY2g9XCJcIiksaSl9bihfaSxcInN0cmlwVVJMRm9yVXNlQXNBUmVmZXJyZXJcIik7Y29uc3QgU2k9bmV3IFNldChbXCJcIixcIm5vLXJlZmVycmVyXCIsXCJuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZVwiLFwic2FtZS1vcmlnaW5cIixcIm9yaWdpblwiLFwic3RyaWN0LW9yaWdpblwiLFwib3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsXCJ1bnNhZmUtdXJsXCJdKSxubD1cInN0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW5cIjtmdW5jdGlvbiBvbChpKXtpZighU2kuaGFzKGkpKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcmVmZXJyZXJQb2xpY3k6ICR7aX1gKTtyZXR1cm4gaX1uKG9sLFwidmFsaWRhdGVSZWZlcnJlclBvbGljeVwiKTtmdW5jdGlvbiBpbChpKXtpZigvXihodHRwfHdzKXM6JC8udGVzdChpLnByb3RvY29sKSlyZXR1cm4hMDtjb25zdCBvPWkuaG9zdC5yZXBsYWNlKC8oXlxcWyl8KF0kKS9nLFwiXCIpLGE9T3Mobyk7cmV0dXJuIGE9PT00JiYvXjEyN1xcLi8udGVzdChvKXx8YT09PTYmJi9eKCgoMCs6KXs3fSl8KDo6KDArOil7MCw2fSkpMCoxJC8udGVzdChvKT8hMDppLmhvc3Q9PT1cImxvY2FsaG9zdFwifHxpLmhvc3QuZW5kc1dpdGgoXCIubG9jYWxob3N0XCIpPyExOmkucHJvdG9jb2w9PT1cImZpbGU6XCJ9bihpbCxcImlzT3JpZ2luUG90ZW50aWFsbHlUcnVzdHdvcnRoeVwiKTtmdW5jdGlvbiBjdChpKXtyZXR1cm4vXmFib3V0OihibGFua3xzcmNkb2MpJC8udGVzdChpKXx8aS5wcm90b2NvbD09PVwiZGF0YTpcInx8L14oYmxvYnxmaWxlc3lzdGVtKTokLy50ZXN0KGkucHJvdG9jb2wpPyEwOmlsKGkpfW4oY3QsXCJpc1VybFBvdGVudGlhbGx5VHJ1c3R3b3J0aHlcIik7ZnVuY3Rpb24gYWwoaSx7cmVmZXJyZXJVUkxDYWxsYmFjazpvLHJlZmVycmVyT3JpZ2luQ2FsbGJhY2s6YX09e30pe2lmKGkucmVmZXJyZXI9PT1cIm5vLXJlZmVycmVyXCJ8fGkucmVmZXJyZXJQb2xpY3k9PT1cIlwiKXJldHVybiBudWxsO2NvbnN0IHU9aS5yZWZlcnJlclBvbGljeTtpZihpLnJlZmVycmVyPT09XCJhYm91dDpjbGllbnRcIilyZXR1cm5cIm5vLXJlZmVycmVyXCI7Y29uc3QgbD1pLnJlZmVycmVyO2xldCBwPV9pKGwpLGg9X2kobCwhMCk7cC50b1N0cmluZygpLmxlbmd0aD40MDk2JiYocD1oKSxvJiYocD1vKHApKSxhJiYoaD1hKGgpKTtjb25zdCBnPW5ldyBVUkwoaS51cmwpO3N3aXRjaCh1KXtjYXNlXCJuby1yZWZlcnJlclwiOnJldHVyblwibm8tcmVmZXJyZXJcIjtjYXNlXCJvcmlnaW5cIjpyZXR1cm4gaDtjYXNlXCJ1bnNhZmUtdXJsXCI6cmV0dXJuIHA7Y2FzZVwic3RyaWN0LW9yaWdpblwiOnJldHVybiBjdChwKSYmIWN0KGcpP1wibm8tcmVmZXJyZXJcIjpoLnRvU3RyaW5nKCk7Y2FzZVwic3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiOnJldHVybiBwLm9yaWdpbj09PWcub3JpZ2luP3A6Y3QocCkmJiFjdChnKT9cIm5vLXJlZmVycmVyXCI6aDtjYXNlXCJzYW1lLW9yaWdpblwiOnJldHVybiBwLm9yaWdpbj09PWcub3JpZ2luP3A6XCJuby1yZWZlcnJlclwiO2Nhc2VcIm9yaWdpbi13aGVuLWNyb3NzLW9yaWdpblwiOnJldHVybiBwLm9yaWdpbj09PWcub3JpZ2luP3A6aDtjYXNlXCJuby1yZWZlcnJlci13aGVuLWRvd25ncmFkZVwiOnJldHVybiBjdChwKSYmIWN0KGcpP1wibm8tcmVmZXJyZXJcIjpwO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCByZWZlcnJlclBvbGljeTogJHt1fWApfX1uKGFsLFwiZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlclwiKTtmdW5jdGlvbiBzbChpKXtjb25zdCBvPShpLmdldChcInJlZmVycmVyLXBvbGljeVwiKXx8XCJcIikuc3BsaXQoL1ssXFxzXSsvKTtsZXQgYT1cIlwiO2Zvcihjb25zdCB1IG9mIG8pdSYmU2kuaGFzKHUpJiYoYT11KTtyZXR1cm4gYX1uKHNsLFwicGFyc2VSZWZlcnJlclBvbGljeUZyb21IZWFkZXJcIik7Y29uc3QgJD1TeW1ib2woXCJSZXF1ZXN0IGludGVybmFsc1wiKSxBdD1uKGk9PnR5cGVvZiBpPT1cIm9iamVjdFwiJiZ0eXBlb2YgaVskXT09XCJvYmplY3RcIixcImlzUmVxdWVzdFwiKSxsbD1ocigoKT0+e30sXCIuZGF0YSBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0SW5pdCBwcm9wZXJ0eSwgdXNlIC5ib2R5IGluc3RlYWRcIixcImh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL25vZGUtZmV0Y2gvaXNzdWVzLzEwMDAgKHJlcXVlc3QpXCIpLHZyPWNsYXNzIHZyIGV4dGVuZHMgVWV7Y29uc3RydWN0b3IobyxhPXt9KXtsZXQgdTtpZihBdChvKT91PW5ldyBVUkwoby51cmwpOih1PW5ldyBVUkwobyksbz17fSksdS51c2VybmFtZSE9PVwiXCJ8fHUucGFzc3dvcmQhPT1cIlwiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7dX0gaXMgYW4gdXJsIHdpdGggZW1iZWRkZWQgY3JlZGVudGlhbHMuYCk7bGV0IGw9YS5tZXRob2R8fG8ubWV0aG9kfHxcIkdFVFwiO2lmKC9eKGRlbGV0ZXxnZXR8aGVhZHxvcHRpb25zfHBvc3R8cHV0KSQvaS50ZXN0KGwpJiYobD1sLnRvVXBwZXJDYXNlKCkpLCFBdChhKSYmXCJkYXRhXCJpbiBhJiZsbCgpLChhLmJvZHkhPW51bGx8fEF0KG8pJiZvLmJvZHkhPT1udWxsKSYmKGw9PT1cIkdFVFwifHxsPT09XCJIRUFEXCIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJSZXF1ZXN0IHdpdGggR0VUL0hFQUQgbWV0aG9kIGNhbm5vdCBoYXZlIGJvZHlcIik7Y29uc3QgcD1hLmJvZHk/YS5ib2R5OkF0KG8pJiZvLmJvZHkhPT1udWxsP0ZuKG8pOm51bGw7c3VwZXIocCx7c2l6ZTphLnNpemV8fG8uc2l6ZXx8MH0pO2NvbnN0IGg9bmV3IHllKGEuaGVhZGVyc3x8by5oZWFkZXJzfHx7fSk7aWYocCE9PW51bGwmJiFoLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSl7Y29uc3Qgdz1naShwLHRoaXMpO3cmJmguc2V0KFwiQ29udGVudC1UeXBlXCIsdyl9bGV0IGc9QXQobyk/by5zaWduYWw6bnVsbDtpZihcInNpZ25hbFwiaW4gYSYmKGc9YS5zaWduYWwpLGchPW51bGwmJiFRcyhnKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgc2lnbmFsIHRvIGJlIGFuIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgb3IgRXZlbnRUYXJnZXRcIik7bGV0IEE9YS5yZWZlcnJlcj09bnVsbD9vLnJlZmVycmVyOmEucmVmZXJyZXI7aWYoQT09PVwiXCIpQT1cIm5vLXJlZmVycmVyXCI7ZWxzZSBpZihBKXtjb25zdCB3PW5ldyBVUkwoQSk7QT0vXmFib3V0OihcXC9cXC8pP2NsaWVudCQvLnRlc3Qodyk/XCJjbGllbnRcIjp3fWVsc2UgQT12b2lkIDA7dGhpc1skXT17bWV0aG9kOmwscmVkaXJlY3Q6YS5yZWRpcmVjdHx8by5yZWRpcmVjdHx8XCJmb2xsb3dcIixoZWFkZXJzOmgscGFyc2VkVVJMOnUsc2lnbmFsOmcscmVmZXJyZXI6QX0sdGhpcy5mb2xsb3c9YS5mb2xsb3c9PT12b2lkIDA/by5mb2xsb3c9PT12b2lkIDA/MjA6by5mb2xsb3c6YS5mb2xsb3csdGhpcy5jb21wcmVzcz1hLmNvbXByZXNzPT09dm9pZCAwP28uY29tcHJlc3M9PT12b2lkIDA/ITA6by5jb21wcmVzczphLmNvbXByZXNzLHRoaXMuY291bnRlcj1hLmNvdW50ZXJ8fG8uY291bnRlcnx8MCx0aGlzLmFnZW50PWEuYWdlbnR8fG8uYWdlbnQsdGhpcy5oaWdoV2F0ZXJNYXJrPWEuaGlnaFdhdGVyTWFya3x8by5oaWdoV2F0ZXJNYXJrfHwxNjM4NCx0aGlzLmluc2VjdXJlSFRUUFBhcnNlcj1hLmluc2VjdXJlSFRUUFBhcnNlcnx8by5pbnNlY3VyZUhUVFBQYXJzZXJ8fCExLHRoaXMucmVmZXJyZXJQb2xpY3k9YS5yZWZlcnJlclBvbGljeXx8by5yZWZlcnJlclBvbGljeXx8XCJcIn1nZXQgbWV0aG9kKCl7cmV0dXJuIHRoaXNbJF0ubWV0aG9kfWdldCB1cmwoKXtyZXR1cm4gcXModGhpc1skXS5wYXJzZWRVUkwpfWdldCBoZWFkZXJzKCl7cmV0dXJuIHRoaXNbJF0uaGVhZGVyc31nZXQgcmVkaXJlY3QoKXtyZXR1cm4gdGhpc1skXS5yZWRpcmVjdH1nZXQgc2lnbmFsKCl7cmV0dXJuIHRoaXNbJF0uc2lnbmFsfWdldCByZWZlcnJlcigpe2lmKHRoaXNbJF0ucmVmZXJyZXI9PT1cIm5vLXJlZmVycmVyXCIpcmV0dXJuXCJcIjtpZih0aGlzWyRdLnJlZmVycmVyPT09XCJjbGllbnRcIilyZXR1cm5cImFib3V0OmNsaWVudFwiO2lmKHRoaXNbJF0ucmVmZXJyZXIpcmV0dXJuIHRoaXNbJF0ucmVmZXJyZXIudG9TdHJpbmcoKX1nZXQgcmVmZXJyZXJQb2xpY3koKXtyZXR1cm4gdGhpc1skXS5yZWZlcnJlclBvbGljeX1zZXQgcmVmZXJyZXJQb2xpY3kobyl7dGhpc1skXS5yZWZlcnJlclBvbGljeT1vbChvKX1jbG9uZSgpe3JldHVybiBuZXcgdnIodGhpcyl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm5cIlJlcXVlc3RcIn19O24odnIsXCJSZXF1ZXN0XCIpO2xldCBkdD12cjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhkdC5wcm90b3R5cGUse21ldGhvZDp7ZW51bWVyYWJsZTohMH0sdXJsOntlbnVtZXJhYmxlOiEwfSxoZWFkZXJzOntlbnVtZXJhYmxlOiEwfSxyZWRpcmVjdDp7ZW51bWVyYWJsZTohMH0sY2xvbmU6e2VudW1lcmFibGU6ITB9LHNpZ25hbDp7ZW51bWVyYWJsZTohMH0scmVmZXJyZXI6e2VudW1lcmFibGU6ITB9LHJlZmVycmVyUG9saWN5OntlbnVtZXJhYmxlOiEwfX0pO2NvbnN0IHVsPW4oaT0+e2NvbnN0e3BhcnNlZFVSTDpvfT1pWyRdLGE9bmV3IHllKGlbJF0uaGVhZGVycyk7YS5oYXMoXCJBY2NlcHRcIil8fGEuc2V0KFwiQWNjZXB0XCIsXCIqLypcIik7bGV0IHU9bnVsbDtpZihpLmJvZHk9PT1udWxsJiYvXihwb3N0fHB1dCkkL2kudGVzdChpLm1ldGhvZCkmJih1PVwiMFwiKSxpLmJvZHkhPT1udWxsKXtjb25zdCBnPUpzKGkpO3R5cGVvZiBnPT1cIm51bWJlclwiJiYhTnVtYmVyLmlzTmFOKGcpJiYodT1TdHJpbmcoZykpfXUmJmEuc2V0KFwiQ29udGVudC1MZW5ndGhcIix1KSxpLnJlZmVycmVyUG9saWN5PT09XCJcIiYmKGkucmVmZXJyZXJQb2xpY3k9bmwpLGkucmVmZXJyZXImJmkucmVmZXJyZXIhPT1cIm5vLXJlZmVycmVyXCI/aVskXS5yZWZlcnJlcj1hbChpKTppWyRdLnJlZmVycmVyPVwibm8tcmVmZXJyZXJcIixpWyRdLnJlZmVycmVyIGluc3RhbmNlb2YgVVJMJiZhLnNldChcIlJlZmVyZXJcIixpLnJlZmVycmVyKSxhLmhhcyhcIlVzZXItQWdlbnRcIil8fGEuc2V0KFwiVXNlci1BZ2VudFwiLFwibm9kZS1mZXRjaFwiKSxpLmNvbXByZXNzJiYhYS5oYXMoXCJBY2NlcHQtRW5jb2RpbmdcIikmJmEuc2V0KFwiQWNjZXB0LUVuY29kaW5nXCIsXCJnemlwLCBkZWZsYXRlLCBiclwiKTtsZXR7YWdlbnQ6bH09aTt0eXBlb2YgbD09XCJmdW5jdGlvblwiJiYobD1sKG8pKTtjb25zdCBwPXJsKG8pLGg9e3BhdGg6by5wYXRobmFtZStwLG1ldGhvZDppLm1ldGhvZCxoZWFkZXJzOmFbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSgpLGluc2VjdXJlSFRUUFBhcnNlcjppLmluc2VjdXJlSFRUUFBhcnNlcixhZ2VudDpsfTtyZXR1cm57cGFyc2VkVVJMOm8sb3B0aW9uczpofX0sXCJnZXROb2RlUmVxdWVzdE9wdGlvbnNcIiksSG49Y2xhc3MgSG4gZXh0ZW5kcyBmdHtjb25zdHJ1Y3RvcihvLGE9XCJhYm9ydGVkXCIpe3N1cGVyKG8sYSl9fTtuKEhuLFwiQWJvcnRFcnJvclwiKTtsZXQgX3I9SG47LyohIG5vZGUtZG9tZXhjZXB0aW9uLiBNSVQgTGljZW5zZS4gSmltbXkgV8OkcnRpbmcgPGh0dHBzOi8vamltbXkud2FydGluZy5zZS9vcGVuc291cmNlPiAqL2lmKCFnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbil0cnl7Y29uc3R7TWVzc2FnZUNoYW5uZWw6aX09cmVxdWlyZShcIndvcmtlcl90aHJlYWRzXCIpLG89bmV3IGkoKS5wb3J0MSxhPW5ldyBBcnJheUJ1ZmZlcjtvLnBvc3RNZXNzYWdlKGEsW2EsYV0pfWNhdGNoKGkpe2kuY29uc3RydWN0b3IubmFtZT09PVwiRE9NRXhjZXB0aW9uXCImJihnbG9iYWxUaGlzLkRPTUV4Y2VwdGlvbj1pLmNvbnN0cnVjdG9yKX12YXIgZmw9Z2xvYmFsVGhpcy5ET01FeGNlcHRpb247Y29uc3QgY2w9V3MoZmwpLHtzdGF0OiRufT1JcyxkbD1uKChpLG8pPT53aShjaShpKSxpLG8pLFwiYmxvYkZyb21TeW5jXCIpLGhsPW4oKGksbyk9PiRuKGkpLnRoZW4oYT0+d2koYSxpLG8pKSxcImJsb2JGcm9tXCIpLHBsPW4oKGksbyk9PiRuKGkpLnRoZW4oYT0+UmkoYSxpLG8pKSxcImZpbGVGcm9tXCIpLGJsPW4oKGksbyk9PlJpKGNpKGkpLGksbyksXCJmaWxlRnJvbVN5bmNcIiksd2k9bigoaSxvLGE9XCJcIik9Pm5ldyB1dChbbmV3IFNyKHtwYXRoOm8sc2l6ZTppLnNpemUsbGFzdE1vZGlmaWVkOmkubXRpbWVNcyxzdGFydDowfSldLHt0eXBlOmF9KSxcImZyb21CbG9iXCIpLFJpPW4oKGksbyxhPVwiXCIpPT5uZXcgT24oW25ldyBTcih7cGF0aDpvLHNpemU6aS5zaXplLGxhc3RNb2RpZmllZDppLm10aW1lTXMsc3RhcnQ6MH0pXSxGcyhvKSx7dHlwZTphLGxhc3RNb2RpZmllZDppLm10aW1lTXN9KSxcImZyb21GaWxlXCIpLEVyPWNsYXNzIEVye2NvbnN0cnVjdG9yKG8pe2JlKHRoaXMsTmUsdm9pZCAwKTtiZSh0aGlzLEhlLHZvaWQgMCk7WCh0aGlzLE5lLG8ucGF0aCksWCh0aGlzLEhlLG8uc3RhcnQpLHRoaXMuc2l6ZT1vLnNpemUsdGhpcy5sYXN0TW9kaWZpZWQ9by5sYXN0TW9kaWZpZWR9c2xpY2UobyxhKXtyZXR1cm4gbmV3IEVyKHtwYXRoOk8odGhpcyxOZSksbGFzdE1vZGlmaWVkOnRoaXMubGFzdE1vZGlmaWVkLHNpemU6YS1vLHN0YXJ0Ok8odGhpcyxIZSkrb30pfWFzeW5jKnN0cmVhbSgpe2NvbnN0e210aW1lTXM6b309YXdhaXQgJG4oTyh0aGlzLE5lKSk7aWYobz50aGlzLmxhc3RNb2RpZmllZCl0aHJvdyBuZXcgY2woXCJUaGUgcmVxdWVzdGVkIGZpbGUgY291bGQgbm90IGJlIHJlYWQsIHR5cGljYWxseSBkdWUgdG8gcGVybWlzc2lvbiBwcm9ibGVtcyB0aGF0IGhhdmUgb2NjdXJyZWQgYWZ0ZXIgYSByZWZlcmVuY2UgdG8gYSBmaWxlIHdhcyBhY3F1aXJlZC5cIixcIk5vdFJlYWRhYmxlRXJyb3JcIik7eWllbGQqenMoTyh0aGlzLE5lKSx7c3RhcnQ6Tyh0aGlzLEhlKSxlbmQ6Tyh0aGlzLEhlKSt0aGlzLnNpemUtMX0pfWdldFtTeW1ib2wudG9TdHJpbmdUYWddKCl7cmV0dXJuXCJCbG9iXCJ9fTtOZT1uZXcgV2Vha01hcCxIZT1uZXcgV2Vha01hcCxuKEVyLFwiQmxvYkRhdGFJdGVtXCIpO2xldCBTcj1Fcjtjb25zdCBtbD1uZXcgU2V0KFtcImRhdGE6XCIsXCJodHRwOlwiLFwiaHR0cHM6XCJdKTthc3luYyBmdW5jdGlvbiBUaShpLG8pe3JldHVybiBuZXcgUHJvbWlzZSgoYSx1KT0+e2NvbnN0IGw9bmV3IGR0KGksbykse3BhcnNlZFVSTDpwLG9wdGlvbnM6aH09dWwobCk7aWYoIW1sLmhhcyhwLnByb3RvY29sKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBub2RlLWZldGNoIGNhbm5vdCBsb2FkICR7aX0uIFVSTCBzY2hlbWUgXCIke3AucHJvdG9jb2wucmVwbGFjZSgvOiQvLFwiXCIpfVwiIGlzIG5vdCBzdXBwb3J0ZWQuYCk7aWYocC5wcm90b2NvbD09PVwiZGF0YTpcIil7Y29uc3QgXz1qcyhsLnVybCksVj1uZXcgbGUoXyx7aGVhZGVyczp7XCJDb250ZW50LVR5cGVcIjpfLnR5cGVGdWxsfX0pO2EoVik7cmV0dXJufWNvbnN0IGc9KHAucHJvdG9jb2w9PT1cImh0dHBzOlwiP0JzOnZ0KS5yZXF1ZXN0LHtzaWduYWw6QX09bDtsZXQgdz1udWxsO2NvbnN0IEU9bigoKT0+e2NvbnN0IF89bmV3IF9yKFwiVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC5cIik7dShfKSxsLmJvZHkmJmwuYm9keSBpbnN0YW5jZW9mIG1lLlJlYWRhYmxlJiZsLmJvZHkuZGVzdHJveShfKSwhKCF3fHwhdy5ib2R5KSYmdy5ib2R5LmVtaXQoXCJlcnJvclwiLF8pfSxcImFib3J0XCIpO2lmKEEmJkEuYWJvcnRlZCl7RSgpO3JldHVybn1jb25zdCBUPW4oKCk9PntFKCkscSgpfSxcImFib3J0QW5kRmluYWxpemVcIiksYj1nKHAudG9TdHJpbmcoKSxoKTtBJiZBLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLFQpO2NvbnN0IHE9bigoKT0+e2IuYWJvcnQoKSxBJiZBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLFQpfSxcImZpbmFsaXplXCIpO2Iub24oXCJlcnJvclwiLF89Pnt1KG5ldyBHKGByZXF1ZXN0IHRvICR7bC51cmx9IGZhaWxlZCwgcmVhc29uOiAke18ubWVzc2FnZX1gLFwic3lzdGVtXCIsXykpLHEoKX0pLHlsKGIsXz0+e3cmJncuYm9keSYmdy5ib2R5LmRlc3Ryb3koXyl9KSxwcm9jZXNzLnZlcnNpb248XCJ2MTRcIiYmYi5vbihcInNvY2tldFwiLF89PntsZXQgVjtfLnByZXBlbmRMaXN0ZW5lcihcImVuZFwiLCgpPT57Vj1fLl9ldmVudHNDb3VudH0pLF8ucHJlcGVuZExpc3RlbmVyKFwiY2xvc2VcIixJPT57aWYodyYmVjxfLl9ldmVudHNDb3VudCYmIUkpe2NvbnN0IEY9bmV3IEVycm9yKFwiUHJlbWF0dXJlIGNsb3NlXCIpO0YuY29kZT1cIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXCIsdy5ib2R5LmVtaXQoXCJlcnJvclwiLEYpfX0pfSksYi5vbihcInJlc3BvbnNlXCIsXz0+e2Iuc2V0VGltZW91dCgwKTtjb25zdCBWPWVsKF8ucmF3SGVhZGVycyk7aWYoTG4oXy5zdGF0dXNDb2RlKSl7Y29uc3Qgej1WLmdldChcIkxvY2F0aW9uXCIpO2xldCBqPW51bGw7dHJ5e2o9ej09PW51bGw/bnVsbDpuZXcgVVJMKHosbC51cmwpfWNhdGNoe2lmKGwucmVkaXJlY3QhPT1cIm1hbnVhbFwiKXt1KG5ldyBHKGB1cmkgcmVxdWVzdGVkIHJlc3BvbmRzIHdpdGggYW4gaW52YWxpZCByZWRpcmVjdCBVUkw6ICR7en1gLFwiaW52YWxpZC1yZWRpcmVjdFwiKSkscSgpO3JldHVybn19c3dpdGNoKGwucmVkaXJlY3Qpe2Nhc2VcImVycm9yXCI6dShuZXcgRyhgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QsIHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke2wudXJsfWAsXCJuby1yZWRpcmVjdFwiKSkscSgpO3JldHVybjtjYXNlXCJtYW51YWxcIjpicmVhaztjYXNlXCJmb2xsb3dcIjp7aWYoaj09PW51bGwpYnJlYWs7aWYobC5jb3VudGVyPj1sLmZvbGxvdyl7dShuZXcgRyhgbWF4aW11bSByZWRpcmVjdCByZWFjaGVkIGF0OiAke2wudXJsfWAsXCJtYXgtcmVkaXJlY3RcIikpLHEoKTtyZXR1cm59Y29uc3QgVT17aGVhZGVyczpuZXcgeWUobC5oZWFkZXJzKSxmb2xsb3c6bC5mb2xsb3csY291bnRlcjpsLmNvdW50ZXIrMSxhZ2VudDpsLmFnZW50LGNvbXByZXNzOmwuY29tcHJlc3MsbWV0aG9kOmwubWV0aG9kLGJvZHk6Rm4obCksc2lnbmFsOmwuc2lnbmFsLHNpemU6bC5zaXplLHJlZmVycmVyOmwucmVmZXJyZXIscmVmZXJyZXJQb2xpY3k6bC5yZWZlcnJlclBvbGljeX07aWYoIVlzKGwudXJsLGopfHwhR3MobC51cmwsaikpZm9yKGNvbnN0IEZ0IG9mW1wiYXV0aG9yaXphdGlvblwiLFwid3d3LWF1dGhlbnRpY2F0ZVwiLFwiY29va2llXCIsXCJjb29raWUyXCJdKVUuaGVhZGVycy5kZWxldGUoRnQpO2lmKF8uc3RhdHVzQ29kZSE9PTMwMyYmbC5ib2R5JiZvLmJvZHkgaW5zdGFuY2VvZiBtZS5SZWFkYWJsZSl7dShuZXcgRyhcIkNhbm5vdCBmb2xsb3cgcmVkaXJlY3Qgd2l0aCBib2R5IGJlaW5nIGEgcmVhZGFibGUgc3RyZWFtXCIsXCJ1bnN1cHBvcnRlZC1yZWRpcmVjdFwiKSkscSgpO3JldHVybn0oXy5zdGF0dXNDb2RlPT09MzAzfHwoXy5zdGF0dXNDb2RlPT09MzAxfHxfLnN0YXR1c0NvZGU9PT0zMDIpJiZsLm1ldGhvZD09PVwiUE9TVFwiKSYmKFUubWV0aG9kPVwiR0VUXCIsVS5ib2R5PXZvaWQgMCxVLmhlYWRlcnMuZGVsZXRlKFwiY29udGVudC1sZW5ndGhcIikpO2NvbnN0IEQ9c2woVik7RCYmKFUucmVmZXJyZXJQb2xpY3k9RCksYShUaShuZXcgZHQoaixVKSkpLHEoKTtyZXR1cm59ZGVmYXVsdDpyZXR1cm4gdShuZXcgVHlwZUVycm9yKGBSZWRpcmVjdCBvcHRpb24gJyR7bC5yZWRpcmVjdH0nIGlzIG5vdCBhIHZhbGlkIHZhbHVlIG9mIFJlcXVlc3RSZWRpcmVjdGApKX19QSYmXy5vbmNlKFwiZW5kXCIsKCk9PntBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLFQpfSk7bGV0IEk9bHQoXyxuZXcgY3Isej0+e3omJnUoeil9KTtwcm9jZXNzLnZlcnNpb248XCJ2MTIuMTBcIiYmXy5vbihcImFib3J0ZWRcIixUKTtjb25zdCBGPXt1cmw6bC51cmwsc3RhdHVzOl8uc3RhdHVzQ29kZSxzdGF0dXNUZXh0Ol8uc3RhdHVzTWVzc2FnZSxoZWFkZXJzOlYsc2l6ZTpsLnNpemUsY291bnRlcjpsLmNvdW50ZXIsaGlnaFdhdGVyTWFyazpsLmhpZ2hXYXRlck1hcmt9LFE9Vi5nZXQoXCJDb250ZW50LUVuY29kaW5nXCIpO2lmKCFsLmNvbXByZXNzfHxsLm1ldGhvZD09PVwiSEVBRFwifHxRPT09bnVsbHx8Xy5zdGF0dXNDb2RlPT09MjA0fHxfLnN0YXR1c0NvZGU9PT0zMDQpe3c9bmV3IGxlKEksRiksYSh3KTtyZXR1cm59Y29uc3QgZ2U9e2ZsdXNoOnN0LlpfU1lOQ19GTFVTSCxmaW5pc2hGbHVzaDpzdC5aX1NZTkNfRkxVU0h9O2lmKFE9PT1cImd6aXBcInx8UT09PVwieC1nemlwXCIpe0k9bHQoSSxzdC5jcmVhdGVHdW56aXAoZ2UpLHo9Pnt6JiZ1KHopfSksdz1uZXcgbGUoSSxGKSxhKHcpO3JldHVybn1pZihRPT09XCJkZWZsYXRlXCJ8fFE9PT1cIngtZGVmbGF0ZVwiKXtjb25zdCB6PWx0KF8sbmV3IGNyLGo9PntqJiZ1KGopfSk7ei5vbmNlKFwiZGF0YVwiLGo9PnsoalswXSYxNSk9PT04P0k9bHQoSSxzdC5jcmVhdGVJbmZsYXRlKCksVT0+e1UmJnUoVSl9KTpJPWx0KEksc3QuY3JlYXRlSW5mbGF0ZVJhdygpLFU9PntVJiZ1KFUpfSksdz1uZXcgbGUoSSxGKSxhKHcpfSksei5vbmNlKFwiZW5kXCIsKCk9Pnt3fHwodz1uZXcgbGUoSSxGKSxhKHcpKX0pO3JldHVybn1pZihRPT09XCJiclwiKXtJPWx0KEksc3QuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpLHo9Pnt6JiZ1KHopfSksdz1uZXcgbGUoSSxGKSxhKHcpO3JldHVybn13PW5ldyBsZShJLEYpLGEodyl9KSxYcyhiLGwpLmNhdGNoKHUpfSl9bihUaSxcImZldGNoJDFcIik7ZnVuY3Rpb24geWwoaSxvKXtjb25zdCBhPU0uZnJvbShgMFxcclxuXFxyXG5gKTtsZXQgdT0hMSxsPSExLHA7aS5vbihcInJlc3BvbnNlXCIsaD0+e2NvbnN0e2hlYWRlcnM6Z309aDt1PWdbXCJ0cmFuc2Zlci1lbmNvZGluZ1wiXT09PVwiY2h1bmtlZFwiJiYhZ1tcImNvbnRlbnQtbGVuZ3RoXCJdfSksaS5vbihcInNvY2tldFwiLGg9Pntjb25zdCBnPW4oKCk9PntpZih1JiYhbCl7Y29uc3Qgdz1uZXcgRXJyb3IoXCJQcmVtYXR1cmUgY2xvc2VcIik7dy5jb2RlPVwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0VcIixvKHcpfX0sXCJvblNvY2tldENsb3NlXCIpLEE9bih3PT57bD1NLmNvbXBhcmUody5zbGljZSgtNSksYSk9PT0wLCFsJiZwJiYobD1NLmNvbXBhcmUocC5zbGljZSgtMyksYS5zbGljZSgwLDMpKT09PTAmJk0uY29tcGFyZSh3LnNsaWNlKC0yKSxhLnNsaWNlKDMpKT09PTApLHA9d30sXCJvbkRhdGFcIik7aC5wcmVwZW5kTGlzdGVuZXIoXCJjbG9zZVwiLGcpLGgub24oXCJkYXRhXCIsQSksaS5vbihcImNsb3NlXCIsKCk9PntoLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixnKSxoLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLEEpfSl9KX1uKHlsLFwiZml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmdcIik7Y29uc3QgQ2k9bmV3IFdlYWtNYXAsRG49bmV3IFdlYWtNYXA7ZnVuY3Rpb24gVyhpKXtjb25zdCBvPUNpLmdldChpKTtyZXR1cm4gY29uc29sZS5hc3NlcnQobyE9bnVsbCxcIid0aGlzJyBpcyBleHBlY3RlZCBhbiBFdmVudCBvYmplY3QsIGJ1dCBnb3RcIixpKSxvfW4oVyxcInBkXCIpO2Z1bmN0aW9uIFBpKGkpe2lmKGkucGFzc2l2ZUxpc3RlbmVyIT1udWxsKXt0eXBlb2YgY29uc29sZTxcInVcIiYmdHlwZW9mIGNvbnNvbGUuZXJyb3I9PVwiZnVuY3Rpb25cIiYmY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBwcmV2ZW50RGVmYXVsdCBpbnNpZGUgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBpbnZvY2F0aW9uLlwiLGkucGFzc2l2ZUxpc3RlbmVyKTtyZXR1cm59aS5ldmVudC5jYW5jZWxhYmxlJiYoaS5jYW5jZWxlZD0hMCx0eXBlb2YgaS5ldmVudC5wcmV2ZW50RGVmYXVsdD09XCJmdW5jdGlvblwiJiZpLmV2ZW50LnByZXZlbnREZWZhdWx0KCkpfW4oUGksXCJzZXRDYW5jZWxGbGFnXCIpO2Z1bmN0aW9uIGh0KGksbyl7Q2kuc2V0KHRoaXMse2V2ZW50VGFyZ2V0OmksZXZlbnQ6byxldmVudFBoYXNlOjIsY3VycmVudFRhcmdldDppLGNhbmNlbGVkOiExLHN0b3BwZWQ6ITEsaW1tZWRpYXRlU3RvcHBlZDohMSxwYXNzaXZlTGlzdGVuZXI6bnVsbCx0aW1lU3RhbXA6by50aW1lU3RhbXB8fERhdGUubm93KCl9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImlzVHJ1c3RlZFwiLHt2YWx1ZTohMSxlbnVtZXJhYmxlOiEwfSk7Y29uc3QgYT1PYmplY3Qua2V5cyhvKTtmb3IobGV0IHU9MDt1PGEubGVuZ3RoOysrdSl7Y29uc3QgbD1hW3VdO2wgaW4gdGhpc3x8T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsbCx2aShsKSl9fW4oaHQsXCJFdmVudFwiKSxodC5wcm90b3R5cGU9e2dldCB0eXBlKCl7cmV0dXJuIFcodGhpcykuZXZlbnQudHlwZX0sZ2V0IHRhcmdldCgpe3JldHVybiBXKHRoaXMpLmV2ZW50VGFyZ2V0fSxnZXQgY3VycmVudFRhcmdldCgpe3JldHVybiBXKHRoaXMpLmN1cnJlbnRUYXJnZXR9LGNvbXBvc2VkUGF0aCgpe2NvbnN0IGk9Vyh0aGlzKS5jdXJyZW50VGFyZ2V0O3JldHVybiBpPT1udWxsP1tdOltpXX0sZ2V0IE5PTkUoKXtyZXR1cm4gMH0sZ2V0IENBUFRVUklOR19QSEFTRSgpe3JldHVybiAxfSxnZXQgQVRfVEFSR0VUKCl7cmV0dXJuIDJ9LGdldCBCVUJCTElOR19QSEFTRSgpe3JldHVybiAzfSxnZXQgZXZlbnRQaGFzZSgpe3JldHVybiBXKHRoaXMpLmV2ZW50UGhhc2V9LHN0b3BQcm9wYWdhdGlvbigpe2NvbnN0IGk9Vyh0aGlzKTtpLnN0b3BwZWQ9ITAsdHlwZW9mIGkuZXZlbnQuc3RvcFByb3BhZ2F0aW9uPT1cImZ1bmN0aW9uXCImJmkuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCl9LHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpe2NvbnN0IGk9Vyh0aGlzKTtpLnN0b3BwZWQ9ITAsaS5pbW1lZGlhdGVTdG9wcGVkPSEwLHR5cGVvZiBpLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbj09XCJmdW5jdGlvblwiJiZpLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpfSxnZXQgYnViYmxlcygpe3JldHVybiEhVyh0aGlzKS5ldmVudC5idWJibGVzfSxnZXQgY2FuY2VsYWJsZSgpe3JldHVybiEhVyh0aGlzKS5ldmVudC5jYW5jZWxhYmxlfSxwcmV2ZW50RGVmYXVsdCgpe1BpKFcodGhpcykpfSxnZXQgZGVmYXVsdFByZXZlbnRlZCgpe3JldHVybiBXKHRoaXMpLmNhbmNlbGVkfSxnZXQgY29tcG9zZWQoKXtyZXR1cm4hIVcodGhpcykuZXZlbnQuY29tcG9zZWR9LGdldCB0aW1lU3RhbXAoKXtyZXR1cm4gVyh0aGlzKS50aW1lU3RhbXB9LGdldCBzcmNFbGVtZW50KCl7cmV0dXJuIFcodGhpcykuZXZlbnRUYXJnZXR9LGdldCBjYW5jZWxCdWJibGUoKXtyZXR1cm4gVyh0aGlzKS5zdG9wcGVkfSxzZXQgY2FuY2VsQnViYmxlKGkpe2lmKCFpKXJldHVybjtjb25zdCBvPVcodGhpcyk7by5zdG9wcGVkPSEwLHR5cGVvZiBvLmV2ZW50LmNhbmNlbEJ1YmJsZT09XCJib29sZWFuXCImJihvLmV2ZW50LmNhbmNlbEJ1YmJsZT0hMCl9LGdldCByZXR1cm5WYWx1ZSgpe3JldHVybiFXKHRoaXMpLmNhbmNlbGVkfSxzZXQgcmV0dXJuVmFsdWUoaSl7aXx8UGkoVyh0aGlzKSl9LGluaXRFdmVudCgpe319LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShodC5wcm90b3R5cGUsXCJjb25zdHJ1Y3RvclwiLHt2YWx1ZTpodCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KSx0eXBlb2Ygd2luZG93PFwidVwiJiZ0eXBlb2Ygd2luZG93LkV2ZW50PFwidVwiJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mKGh0LnByb3RvdHlwZSx3aW5kb3cuRXZlbnQucHJvdG90eXBlKSxEbi5zZXQod2luZG93LkV2ZW50LnByb3RvdHlwZSxodCkpO2Z1bmN0aW9uIHZpKGkpe3JldHVybntnZXQoKXtyZXR1cm4gVyh0aGlzKS5ldmVudFtpXX0sc2V0KG8pe1codGhpcykuZXZlbnRbaV09b30sY29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITB9fW4odmksXCJkZWZpbmVSZWRpcmVjdERlc2NyaXB0b3JcIik7ZnVuY3Rpb24gZ2woaSl7cmV0dXJue3ZhbHVlKCl7Y29uc3Qgbz1XKHRoaXMpLmV2ZW50O3JldHVybiBvW2ldLmFwcGx5KG8sYXJndW1lbnRzKX0sY29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITB9fW4oZ2wsXCJkZWZpbmVDYWxsRGVzY3JpcHRvclwiKTtmdW5jdGlvbiBfbChpLG8pe2NvbnN0IGE9T2JqZWN0LmtleXMobyk7aWYoYS5sZW5ndGg9PT0wKXJldHVybiBpO2Z1bmN0aW9uIHUobCxwKXtpLmNhbGwodGhpcyxsLHApfW4odSxcIkN1c3RvbUV2ZW50XCIpLHUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp1LGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH19KTtmb3IobGV0IGw9MDtsPGEubGVuZ3RoOysrbCl7Y29uc3QgcD1hW2xdO2lmKCEocCBpbiBpLnByb3RvdHlwZSkpe2NvbnN0IGc9dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobyxwKS52YWx1ZT09XCJmdW5jdGlvblwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LnByb3RvdHlwZSxwLGc/Z2wocCk6dmkocCkpfX1yZXR1cm4gdX1uKF9sLFwiZGVmaW5lV3JhcHBlclwiKTtmdW5jdGlvbiBFaShpKXtpZihpPT1udWxsfHxpPT09T2JqZWN0LnByb3RvdHlwZSlyZXR1cm4gaHQ7bGV0IG89RG4uZ2V0KGkpO3JldHVybiBvPT1udWxsJiYobz1fbChFaShPYmplY3QuZ2V0UHJvdG90eXBlT2YoaSkpLGkpLERuLnNldChpLG8pKSxvfW4oRWksXCJnZXRXcmFwcGVyXCIpO2Z1bmN0aW9uIFNsKGksbyl7Y29uc3QgYT1FaShPYmplY3QuZ2V0UHJvdG90eXBlT2YobykpO3JldHVybiBuZXcgYShpLG8pfW4oU2wsXCJ3cmFwRXZlbnRcIik7ZnVuY3Rpb24gd2woaSl7cmV0dXJuIFcoaSkuaW1tZWRpYXRlU3RvcHBlZH1uKHdsLFwiaXNTdG9wcGVkXCIpO2Z1bmN0aW9uIFJsKGksbyl7VyhpKS5ldmVudFBoYXNlPW99bihSbCxcInNldEV2ZW50UGhhc2VcIik7ZnVuY3Rpb24gVGwoaSxvKXtXKGkpLmN1cnJlbnRUYXJnZXQ9b31uKFRsLFwic2V0Q3VycmVudFRhcmdldFwiKTtmdW5jdGlvbiBBaShpLG8pe1coaSkucGFzc2l2ZUxpc3RlbmVyPW99bihBaSxcInNldFBhc3NpdmVMaXN0ZW5lclwiKTtjb25zdCBCaT1uZXcgV2Vha01hcCxraT0xLFdpPTIsd3I9MztmdW5jdGlvbiBScihpKXtyZXR1cm4gaSE9PW51bGwmJnR5cGVvZiBpPT1cIm9iamVjdFwifW4oUnIsXCJpc09iamVjdFwiKTtmdW5jdGlvbiBCdChpKXtjb25zdCBvPUJpLmdldChpKTtpZihvPT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCIndGhpcycgaXMgZXhwZWN0ZWQgYW4gRXZlbnRUYXJnZXQgb2JqZWN0LCBidXQgZ290IGFub3RoZXIgdmFsdWUuXCIpO3JldHVybiBvfW4oQnQsXCJnZXRMaXN0ZW5lcnNcIik7ZnVuY3Rpb24gQ2woaSl7cmV0dXJue2dldCgpe2xldCBhPUJ0KHRoaXMpLmdldChpKTtmb3IoO2EhPW51bGw7KXtpZihhLmxpc3RlbmVyVHlwZT09PXdyKXJldHVybiBhLmxpc3RlbmVyO2E9YS5uZXh0fXJldHVybiBudWxsfSxzZXQobyl7dHlwZW9mIG8hPVwiZnVuY3Rpb25cIiYmIVJyKG8pJiYobz1udWxsKTtjb25zdCBhPUJ0KHRoaXMpO2xldCB1PW51bGwsbD1hLmdldChpKTtmb3IoO2whPW51bGw7KWwubGlzdGVuZXJUeXBlPT09d3I/dSE9PW51bGw/dS5uZXh0PWwubmV4dDpsLm5leHQhPT1udWxsP2Euc2V0KGksbC5uZXh0KTphLmRlbGV0ZShpKTp1PWwsbD1sLm5leHQ7aWYobyE9PW51bGwpe2NvbnN0IHA9e2xpc3RlbmVyOm8sbGlzdGVuZXJUeXBlOndyLHBhc3NpdmU6ITEsb25jZTohMSxuZXh0Om51bGx9O3U9PT1udWxsP2Euc2V0KGkscCk6dS5uZXh0PXB9fSxjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMH19bihDbCxcImRlZmluZUV2ZW50QXR0cmlidXRlRGVzY3JpcHRvclwiKTtmdW5jdGlvbiBxaShpLG8pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShpLGBvbiR7b31gLENsKG8pKX1uKHFpLFwiZGVmaW5lRXZlbnRBdHRyaWJ1dGVcIik7ZnVuY3Rpb24gT2koaSl7ZnVuY3Rpb24gbygpe1BlLmNhbGwodGhpcyl9bihvLFwiQ3VzdG9tRXZlbnRUYXJnZXRcIiksby5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShQZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpvLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH19KTtmb3IobGV0IGE9MDthPGkubGVuZ3RoOysrYSlxaShvLnByb3RvdHlwZSxpW2FdKTtyZXR1cm4gb31uKE9pLFwiZGVmaW5lQ3VzdG9tRXZlbnRUYXJnZXRcIik7ZnVuY3Rpb24gUGUoKXtpZih0aGlzIGluc3RhbmNlb2YgUGUpe0JpLnNldCh0aGlzLG5ldyBNYXApO3JldHVybn1pZihhcmd1bWVudHMubGVuZ3RoPT09MSYmQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKXJldHVybiBPaShhcmd1bWVudHNbMF0pO2lmKGFyZ3VtZW50cy5sZW5ndGg+MCl7Y29uc3QgaT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7Zm9yKGxldCBvPTA7bzxhcmd1bWVudHMubGVuZ3RoOysrbylpW29dPWFyZ3VtZW50c1tvXTtyZXR1cm4gT2koaSl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1uKFBlLFwiRXZlbnRUYXJnZXRcIiksUGUucHJvdG90eXBlPXthZGRFdmVudExpc3RlbmVyKGksbyxhKXtpZihvPT1udWxsKXJldHVybjtpZih0eXBlb2YgbyE9XCJmdW5jdGlvblwiJiYhUnIobykpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidsaXN0ZW5lcicgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0LlwiKTtjb25zdCB1PUJ0KHRoaXMpLGw9UnIoYSksaD0obD8hIWEuY2FwdHVyZTohIWEpP2tpOldpLGc9e2xpc3RlbmVyOm8sbGlzdGVuZXJUeXBlOmgscGFzc2l2ZTpsJiYhIWEucGFzc2l2ZSxvbmNlOmwmJiEhYS5vbmNlLG5leHQ6bnVsbH07bGV0IEE9dS5nZXQoaSk7aWYoQT09PXZvaWQgMCl7dS5zZXQoaSxnKTtyZXR1cm59bGV0IHc9bnVsbDtmb3IoO0EhPW51bGw7KXtpZihBLmxpc3RlbmVyPT09byYmQS5saXN0ZW5lclR5cGU9PT1oKXJldHVybjt3PUEsQT1BLm5leHR9dy5uZXh0PWd9LHJlbW92ZUV2ZW50TGlzdGVuZXIoaSxvLGEpe2lmKG89PW51bGwpcmV0dXJuO2NvbnN0IHU9QnQodGhpcykscD0oUnIoYSk/ISFhLmNhcHR1cmU6ISFhKT9raTpXaTtsZXQgaD1udWxsLGc9dS5nZXQoaSk7Zm9yKDtnIT1udWxsOyl7aWYoZy5saXN0ZW5lcj09PW8mJmcubGlzdGVuZXJUeXBlPT09cCl7aCE9PW51bGw/aC5uZXh0PWcubmV4dDpnLm5leHQhPT1udWxsP3Uuc2V0KGksZy5uZXh0KTp1LmRlbGV0ZShpKTtyZXR1cm59aD1nLGc9Zy5uZXh0fX0sZGlzcGF0Y2hFdmVudChpKXtpZihpPT1udWxsfHx0eXBlb2YgaS50eXBlIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXZlbnQudHlwZVwiIHNob3VsZCBiZSBhIHN0cmluZy4nKTtjb25zdCBvPUJ0KHRoaXMpLGE9aS50eXBlO2xldCB1PW8uZ2V0KGEpO2lmKHU9PW51bGwpcmV0dXJuITA7Y29uc3QgbD1TbCh0aGlzLGkpO2xldCBwPW51bGw7Zm9yKDt1IT1udWxsOyl7aWYodS5vbmNlP3AhPT1udWxsP3AubmV4dD11Lm5leHQ6dS5uZXh0IT09bnVsbD9vLnNldChhLHUubmV4dCk6by5kZWxldGUoYSk6cD11LEFpKGwsdS5wYXNzaXZlP3UubGlzdGVuZXI6bnVsbCksdHlwZW9mIHUubGlzdGVuZXI9PVwiZnVuY3Rpb25cIil0cnl7dS5saXN0ZW5lci5jYWxsKHRoaXMsbCl9Y2F0Y2goaCl7dHlwZW9mIGNvbnNvbGU8XCJ1XCImJnR5cGVvZiBjb25zb2xlLmVycm9yPT1cImZ1bmN0aW9uXCImJmNvbnNvbGUuZXJyb3IoaCl9ZWxzZSB1Lmxpc3RlbmVyVHlwZSE9PXdyJiZ0eXBlb2YgdS5saXN0ZW5lci5oYW5kbGVFdmVudD09XCJmdW5jdGlvblwiJiZ1Lmxpc3RlbmVyLmhhbmRsZUV2ZW50KGwpO2lmKHdsKGwpKWJyZWFrO3U9dS5uZXh0fXJldHVybiBBaShsLG51bGwpLFJsKGwsMCksVGwobCxudWxsKSwhbC5kZWZhdWx0UHJldmVudGVkfX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KFBlLnByb3RvdHlwZSxcImNvbnN0cnVjdG9yXCIse3ZhbHVlOlBlLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pLHR5cGVvZiB3aW5kb3c8XCJ1XCImJnR5cGVvZiB3aW5kb3cuRXZlbnRUYXJnZXQ8XCJ1XCImJk9iamVjdC5zZXRQcm90b3R5cGVPZihQZS5wcm90b3R5cGUsd2luZG93LkV2ZW50VGFyZ2V0LnByb3RvdHlwZSk7Y29uc3QgVm49Y2xhc3MgVm4gZXh0ZW5kcyBQZXtjb25zdHJ1Y3Rvcigpe3Rocm93IHN1cGVyKCksbmV3IFR5cGVFcnJvcihcIkFib3J0U2lnbmFsIGNhbm5vdCBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseVwiKX1nZXQgYWJvcnRlZCgpe2NvbnN0IG89VHIuZ2V0KHRoaXMpO2lmKHR5cGVvZiBvIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAndGhpcycgdG8gYmUgYW4gJ0Fib3J0U2lnbmFsJyBvYmplY3QsIGJ1dCBnb3QgJHt0aGlzPT09bnVsbD9cIm51bGxcIjp0eXBlb2YgdGhpc31gKTtyZXR1cm4gb319O24oVm4sXCJBYm9ydFNpZ25hbFwiKTtsZXQgcHQ9Vm47cWkocHQucHJvdG90eXBlLFwiYWJvcnRcIik7ZnVuY3Rpb24gUGwoKXtjb25zdCBpPU9iamVjdC5jcmVhdGUocHQucHJvdG90eXBlKTtyZXR1cm4gUGUuY2FsbChpKSxUci5zZXQoaSwhMSksaX1uKFBsLFwiY3JlYXRlQWJvcnRTaWduYWxcIik7ZnVuY3Rpb24gdmwoaSl7VHIuZ2V0KGkpPT09ITEmJihUci5zZXQoaSwhMCksaS5kaXNwYXRjaEV2ZW50KHt0eXBlOlwiYWJvcnRcIn0pKX1uKHZsLFwiYWJvcnRTaWduYWxcIik7Y29uc3QgVHI9bmV3IFdlYWtNYXA7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHQucHJvdG90eXBlLHthYm9ydGVkOntlbnVtZXJhYmxlOiEwfX0pLHR5cGVvZiBTeW1ib2w9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHB0LnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpcIkFib3J0U2lnbmFsXCJ9KTtsZXQgTW49KEl0PWNsYXNze2NvbnN0cnVjdG9yKCl7emkuc2V0KHRoaXMsUGwoKSl9Z2V0IHNpZ25hbCgpe3JldHVybiBJaSh0aGlzKX1hYm9ydCgpe3ZsKElpKHRoaXMpKX19LG4oSXQsXCJBYm9ydENvbnRyb2xsZXJcIiksSXQpO2NvbnN0IHppPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIElpKGkpe2NvbnN0IG89emkuZ2V0KGkpO2lmKG89PW51bGwpdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgJ3RoaXMnIHRvIGJlIGFuICdBYm9ydENvbnRyb2xsZXInIG9iamVjdCwgYnV0IGdvdCAke2k9PT1udWxsP1wibnVsbFwiOnR5cGVvZiBpfWApO3JldHVybiBvfW4oSWksXCJnZXRTaWduYWxcIiksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTW4ucHJvdG90eXBlLHtzaWduYWw6e2VudW1lcmFibGU6ITB9LGFib3J0OntlbnVtZXJhYmxlOiEwfX0pLHR5cGVvZiBTeW1ib2w9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09XCJzeW1ib2xcIiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KE1uLnByb3RvdHlwZSxTeW1ib2wudG9TdHJpbmdUYWcse2NvbmZpZ3VyYWJsZTohMCx2YWx1ZTpcIkFib3J0Q29udHJvbGxlclwifSk7dmFyIEVsPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxBbD1uKChpLG8pPT5FbChpLFwibmFtZVwiLHt2YWx1ZTpvLGNvbmZpZ3VyYWJsZTohMH0pLFwiZVwiKTtjb25zdCBGaT1UaTtqaSgpO2Z1bmN0aW9uIGppKCl7IWdsb2JhbFRoaXMucHJvY2Vzcz8udmVyc2lvbnM/Lm5vZGUmJiFnbG9iYWxUaGlzLnByb2Nlc3M/LmVudi5ESVNBQkxFX05PREVfRkVUQ0hfTkFUSVZFX1dBUk4mJmNvbnNvbGUud2FybihcIltub2RlLWZldGNoLW5hdGl2ZV0gTm9kZS5qcyBjb21wYXRpYmxlIGJ1aWxkIG9mIGBub2RlLWZldGNoLW5hdGl2ZWAgaXMgYmVpbmcgdXNlZCBpbiBhIG5vbi1Ob2RlLmpzIGVudmlyb25tZW50LiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgdXNpbmcgcHJvcGVyIGV4cG9ydCBjb25kaXRpb25zIG9yIHJlcG9ydCB0aGlzIGlzc3VlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS91bmpzL25vZGUtZmV0Y2gtbmF0aXZlLiBZb3UgY2FuIHNldCBgcHJvY2Vzcy5lbnYuRElTQUJMRV9OT0RFX0ZFVENIX05BVElWRV9XQVJOYCB0byBkaXNhYmxlIHRoaXMgd2FybmluZy5cIil9bihqaSxcInNcIiksQWwoamksXCJjaGVja05vZGVFbnZpcm9ubWVudFwiKTtleHBvcnR7TW4gYXMgQWJvcnRDb250cm9sbGVyLF9yIGFzIEFib3J0RXJyb3IsdXQgYXMgQmxvYixHIGFzIEZldGNoRXJyb3IsT24gYXMgRmlsZSxiciBhcyBGb3JtRGF0YSx5ZSBhcyBIZWFkZXJzLGR0IGFzIFJlcXVlc3QsbGUgYXMgUmVzcG9uc2UsaGwgYXMgYmxvYkZyb20sZGwgYXMgYmxvYkZyb21TeW5jLEZpIGFzIGRlZmF1bHQsRmkgYXMgZmV0Y2gscGwgYXMgZmlsZUZyb20sYmwgYXMgZmlsZUZyb21TeW5jLExuIGFzIGlzUmVkaXJlY3R9O1xuIl0sIm5hbWVzIjpbIkFzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJuIiwiaSIsIm8iLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImZpIiwiYSIsImhhcyIsIlR5cGVFcnJvciIsIk8iLCJjYWxsIiwiZ2V0IiwiYmUiLCJXZWFrU2V0IiwiYWRkIiwic2V0IiwiWCIsInUiLCJ2ZSIsImt0IiwiYnQiLCJDciIsIlZlIiwiV3QiLCJxdCIsIk90IiwiZWUiLCJ6dCIsIk5lIiwiSGUiLCJJdCIsInZ0IiwiQnMiLCJzdCIsIm1lIiwiUGFzc1Rocm91Z2giLCJjciIsInBpcGVsaW5lIiwibHQiLCJCdWZmZXIiLCJNIiwidHlwZXMiLCJkciIsInByb21pc2lmeSIsImtzIiwiZGVwcmVjYXRlIiwiaHIiLCJjIiwiV24iLCJnIiwiV3MiLCJmb3JtYXQiLCJxcyIsImlzSVAiLCJPcyIsInN0YXRTeW5jIiwiY2kiLCJjcmVhdGVSZWFkU3RyZWFtIiwienMiLCJwcm9taXNlcyIsIklzIiwiYmFzZW5hbWUiLCJGcyIsImpzIiwidGVzdCIsInJlcGxhY2UiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwic3BsaXQiLCJsIiwicCIsImgiLCJFIiwibGVuZ3RoIiwiQSIsInVuZXNjYXBlIiwidyIsImZyb20iLCJ0eXBlIiwidHlwZUZ1bGwiLCJjaGFyc2V0IiwicHIiLCJleHBvcnRzIiwiZGkiLCJMcyIsImUiLCJ0IiwiUHJvbWlzZSIsInByb3RvdHlwZSIsInRoZW4iLCJyZWplY3QiLCJiaW5kIiwiVCIsImIiLCJxIiwiciIsIl8iLCJWIiwiSSIsIkYiLCJRIiwiZ2UiLCJxdWV1ZU1pY3JvdGFzayIsInoiLCJGdW5jdGlvbiIsImFwcGx5IiwiaiIsInMiLCJVIiwiYm4iLCJjb25zdHJ1Y3RvciIsIl9jdXJzb3IiLCJfc2l6ZSIsIl9mcm9udCIsIl9lbGVtZW50cyIsIl9uZXh0IiwiX2JhY2siLCJwdXNoIiwic2hpZnQiLCJmIiwiZCIsImZvckVhY2giLCJwZWVrIiwiRCIsIkZ0IiwiU3ltYm9sIiwiUW4iLCJBciIsIkJyIiwia3IiLCJZbiIsIl9vd25lclJlYWRhYmxlU3RyZWFtIiwiX3JlYWRlciIsIl9zdGF0ZSIsInFyIiwiTGkiLCJHbiIsIl9zdG9yZWRFcnJvciIsIldyIiwiaWUiLCJfZSIsIk9yIiwiJGkiLCJfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyIiwianQiLCJfY2xvc2VkUHJvbWlzZSIsIl9jbG9zZWRQcm9taXNlX3Jlc29sdmUiLCJfY2xvc2VkUHJvbWlzZV9yZWplY3QiLCJabiIsIktuIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJEaSIsIk1hdGgiLCJ0cnVuYyIsImNlaWwiLCJmbG9vciIsIk1pIiwidWUiLCJaIiwiVWkiLCJKbiIsIlNlIiwienIiLCJJciIsIlhuIiwieGkiLCJGciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJqciIsIldlIiwiUWUiLCJmZSIsImVvIiwiX3JlYWRSZXF1ZXN0cyIsIkxyIiwiX2Nsb3NlU3RlcHMiLCJfY2h1bmtTdGVwcyIsIkx0IiwidG8iLCJFZSIsIm1uIiwicWUiLCJjbG9zZWQiLCIkdCIsImNhbmNlbCIsInJlYWQiLCJtdCIsImRvbmUiLCJfZXJyb3JTdGVwcyIsInJlbGVhc2VMb2NrIiwiTmkiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZW51bWVyYWJsZSIsInRvU3RyaW5nVGFnIiwiaGFzT3duUHJvcGVydHkiLCJfZGlzdHVyYmVkIiwicm8iLCJIaSIsImdldFByb3RvdHlwZU9mIiwieW4iLCJfb25nb2luZ1Byb21pc2UiLCJfaXNGaW5pc2hlZCIsIl9wcmV2ZW50Q2FuY2VsIiwibmV4dCIsIl9uZXh0U3RlcHMiLCJyZXR1cm4iLCJfcmV0dXJuU3RlcHMiLCJyZXNvbHZlIiwibSIsIkR0Iiwibm8iLCJvbyIsIl9hc3luY0l0ZXJhdG9ySW1wbCIsImlvIiwic2V0UHJvdG90eXBlT2YiLCJWaSIsImNyZWF0ZSIsImFvIiwiaXNOYU4iLCIkciIsIkRyIiwiTXIiLCJ5dCIsInNsaWNlIiwic28iLCJVaW50OEFycmF5Iiwid2UiLCJ0cmFuc2ZlciIsInN0cnVjdHVyZWRDbG9uZSIsIkFlIiwiZGV0YWNoZWQiLCJieXRlTGVuZ3RoIiwibG8iLCJBcnJheUJ1ZmZlciIsIk10IiwiU3RyaW5nIiwiUWkiLCJpdGVyYXRvciIsIm5leHRNZXRob2QiLCJVciIsImFzeW5jSXRlcmF0b3IiLCJmb3IiLCJ1byIsIllpIiwiR2kiLCJaaSIsIktpIiwiZm8iLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwieHIiLCJfcXVldWUiLCJfcXVldWVUb3RhbFNpemUiLCJzaXplIiwiTnIiLCJSYW5nZUVycm9yIiwiSmkiLCJCZSIsImNvIiwiRGF0YVZpZXciLCJYaSIsImVhIiwiQllURVNfUEVSX0VMRU1FTlQiLCJnbiIsInZpZXciLCJIciIsIlpyIiwiX3ZpZXciLCJyZXNwb25kIiwiX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwiSHQiLCJyZXNwb25kV2l0aE5ld1ZpZXciLCJpc1ZpZXciLCJWdCIsIlJlIiwiX24iLCJieW9iUmVxdWVzdCIsInplIiwiX3QiLCJHciIsImRlc2lyZWRTaXplIiwiUm8iLCJjbG9zZSIsIl9jbG9zZVJlcXVlc3RlZCIsIl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtIiwiZ3QiLCJlbnF1ZXVlIiwiTnQiLCJlcnJvciIsIksiLCJobyIsIl9jYW5jZWxBbGdvcml0aG0iLCJ4dCIsIndvIiwiX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSIsImJ1ZmZlckJ5dGVMZW5ndGgiLCJieXRlc0ZpbGxlZCIsIm1pbmltdW1GaWxsIiwiZWxlbWVudFNpemUiLCJ2aWV3Q29uc3RydWN0b3IiLCJyZWFkZXJUeXBlIiwiX3BlbmRpbmdQdWxsSW50b3MiLCJJZSIsInRlIiwiaWEiLCJfcHVsbGluZyIsIl9wdWxsQWdhaW4iLCJfcHVsbEFsZ29yaXRobSIsIlFyIiwiVnIiLCJwbyIsImNhIiwiVXQiLCJibyIsIm1vIiwiWWUiLCJ5byIsIm1pbiIsIlIiLCJ5IiwiQyIsIlAiLCJnbyIsIl9vIiwiUHQiLCJfYnlvYlJlcXVlc3QiLCJZciIsInRhIiwicmEiLCJCIiwiUG8iLCJuYSIsIktyIiwidm8iLCJvYSIsIlNvIiwiX3N0YXJ0ZWQiLCJabyIsInNhIiwiX3N0cmF0ZWd5SFdNIiwiVG8iLCJhYSIsInN0YXJ0IiwicHVsbCIsImF1dG9BbGxvY2F0ZUNodW5rU2l6ZSIsImxhIiwibW9kZSIsInVhIiwiZmEiLCJDbyIsImNlIiwiX3JlYWRJbnRvUmVxdWVzdHMiLCJGZSIsIlNuIiwiUXQiLCJFbyIsImRhIiwiQW8iLCJTdCIsImhpZ2hXYXRlck1hcmsiLCJZdCIsIkd0IiwiaGEiLCJwYSIsImFib3J0Iiwid3JpdGUiLCJiYSIsIm1hIiwieWEiLCJnYSIsIkJvIiwiR2UiLCJfYSIsImFib3J0ZWQiLCJTYSIsIkFib3J0Q29udHJvbGxlciIsIndhIiwid24iLCJXbyIsIklhIiwibG9ja2VkIiwiZXIiLCJaZSIsIlp0IiwiaGUiLCJxbyIsImdldFdyaXRlciIsImtvIiwiZGUiLCJyZSIsIlJhIiwia2UiLCJMbyIsIl93cml0ZXIiLCJfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyIiwiX3dyaXRlUmVxdWVzdHMiLCJfaW5GbGlnaHRXcml0ZVJlcXVlc3QiLCJfY2xvc2VSZXF1ZXN0IiwiX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0IiwiX3BlbmRpbmdBYm9ydFJlcXVlc3QiLCJfYmFja3ByZXNzdXJlIiwiX2Fib3J0UmVhc29uIiwiX2Fib3J0Q29udHJvbGxlciIsIl9wcm9taXNlIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiX3JlYXNvbiIsIl93YXNBbHJlYWR5RXJyb3JpbmciLCJYciIsImxuIiwiRmEiLCJUYSIsIkpyIiwiZW4iLCJ6byIsIkFhIiwiS3QiLCJDYSIsIlBhIiwidmEiLCJVbyIsIkVhIiwiQmEiLCJrYSIsImFuIiwidG4iLCJ4YSIsIlJuIiwiX293bmVyV3JpdGFibGVTdHJlYW0iLCJyciIsInhvIiwidHIiLCJzbiIsIk1hIiwiTW8iLCJqZSIsIkxlIiwiUnQiLCJ6YSIsInJlYWR5IiwiX3JlYWR5UHJvbWlzZSIsIldhIiwiT28iLCJJbyIsIkZvIiwicWEiLCJPYSIsIl9jbG9zZWRQcm9taXNlU3RhdGUiLCJVYSIsIl9yZWFkeVByb21pc2VTdGF0ZSIsIk5vIiwiTmEiLCIkbyIsImphIiwiTGEiLCJqbyIsIlRuIiwiYWJvcnRSZWFzb24iLCJybiIsIm9uIiwic2lnbmFsIiwiX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSIsIkRvIiwiX2Fib3J0QWxnb3JpdGhtIiwiSnQiLCJfc3RyYXRlZ3lTaXplQWxnb3JpdGhtIiwiX3dyaXRlQWxnb3JpdGhtIiwiX2Nsb3NlQWxnb3JpdGhtIiwibm4iLCJYdCIsInd0IiwiJGEiLCJEYSIsIl9yZWFkeVByb21pc2VfcmVzb2x2ZSIsIl9yZWFkeVByb21pc2VfcmVqZWN0IiwiSGEiLCJnbG9iYWxUaGlzIiwic2VsZiIsInVuIiwiVmEiLCJuYW1lIiwiUWEiLCJET01FeGNlcHRpb24iLCJZYSIsIm1lc3NhZ2UiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwid3JpdGFibGUiLCJHYSIsIkhvIiwiUyIsInJlYXNvbiIsInYiLCJOIiwiYWxsIiwibWFwIiwiayIsImFkZEV2ZW50TGlzdGVuZXIiLCJhZSIsIlkiLCJudCIsIlRlIiwiSiIsIngiLCJPZSIsIkNlIiwib3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiQ24iLCJuciIsImlyIiwiZm4iLCJKZSIsIiRlIiwiS2UiLCJvZSIsIm9yIiwiX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbSIsIlR0IiwibmUiLCJWbyIsIlphIiwiUW8iLCJLYSIsIkphIiwiZXMiLCJYYSIsIkN0IiwiaXQiLCJhdCIsInVpIiwia24iLCJmciIsIkdvIiwidHMiLCJnZXRSZWFkZXIiLCJycyIsIm9zIiwibnMiLCJpcyIsImFzIiwic3MiLCJscyIsInVzIiwiZnMiLCJwcmV2ZW50Q2FuY2VsIiwiWW8iLCJwcmV2ZW50QWJvcnQiLCJwcmV2ZW50Q2xvc2UiLCJjcyIsImRzIiwicmVhZGFibGUiLCJQbiIsImNuIiwiRGUiLCJwaXBlVGhyb3VnaCIsInBpcGVUbyIsInRlZSIsInZhbHVlcyIsIkwiLCJLbyIsIkpvIiwidm4iLCJfYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsiLCJlaSIsIlhvIiwiWGUiLCJ0aSIsIkVuIiwiX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsIm5pIiwicmkiLCJldCIsImhzIiwiZmx1c2giLCJyZWFkYWJsZVR5cGUiLCJ0cmFuc2Zvcm0iLCJ3cml0YWJsZVR5cGUiLCJ5cyIsInBzIiwiYnMiLCJtcyIsIkFuIiwiZ3MiLCJTcyIsIl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyIiwib2kiLCJsaSIsIl9yZWFkYWJsZSIsIl93cml0YWJsZSIsInR0IiwiVHMiLCJDcyIsIlBzIiwidnMiLCJFcyIsIl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlIiwiX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSIsImFyIiwiaWkiLCJkbiIsImxyIiwiaG4iLCJCbiIsInNyIiwidXIiLCJfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSIsImFpIiwid3MiLCJ0ZXJtaW5hdGUiLCJScyIsInBlIiwiX3MiLCJfdHJhbnNmb3JtQWxnb3JpdGhtIiwiX2ZsdXNoQWxnb3JpdGhtIiwiX2ZpbmlzaFByb21pc2UiLCJfZmluaXNoUHJvbWlzZV9yZXNvbHZlIiwiX2ZpbmlzaFByb21pc2VfcmVqZWN0Iiwic2kiLCJydCIsInBuIiwiQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSIsIkNvdW50UXVldWluZ1N0cmF0ZWd5IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsIlJlYWRhYmxlU3RyZWFtIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIiLCJUcmFuc2Zvcm1TdHJlYW0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIldyaXRhYmxlU3RyZWFtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIiRzIiwicmVxdWlyZSIsImVtaXRXYXJuaW5nIiwiYXNzaWduIiwiQmxvYiIsInN0cmVhbSIsImFycmF5QnVmZmVyIiwiaGkiLCJxbiIsInBpIiwiVGV4dEVuY29kZXIiLCJlbmNvZGUiLCJlbmRpbmdzIiwidGV4dCIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwibWF4Iiwic3ViYXJyYXkiLCJ0b0xvd2VyQ2FzZSIsImhhc0luc3RhbmNlIiwiV2Vha01hcCIsIkRzIiwidXQiLCJNcyIsImFyZ3VtZW50cyIsImxhc3RNb2RpZmllZCIsIkRhdGUiLCJub3ciLCJVcyIsIk9uIiwiRXQiLCJ4cyIsIk5zIiwiYmkiLCJyYW5kb20iLCJIcyIsIm1pIiwiem4iLCJNZSIsImJyIiwiZW50cmllcyIsInNvbWUiLCJhcHBlbmQiLCJkZWxldGUiLCJmaWx0ZXIiLCJnZXRBbGwiLCJrZXlzIiwiVnMiLCJwYWRTdGFydCIsIlVuIiwiZnQiLCJ4biIsImNvZGUiLCJlcnJubyIsImVycm9yZWRTeXNDYWxsIiwic3lzY2FsbCIsIkciLCJtciIsInlpIiwic29ydCIsInlyIiwiUXMiLCJZcyIsIlVSTCIsImhvc3RuYW1lIiwiZW5kc1dpdGgiLCJHcyIsInByb3RvY29sIiwiWnMiLCJIIiwiTm4iLCJ0b1N0cmluZyIsImlzQnVmZmVyIiwiaXNBbnlBcnJheUJ1ZmZlciIsIlJlYWRhYmxlIiwiYm9keSIsImJvdW5kYXJ5IiwiZGlzdHVyYmVkIiwidXJsIiwiYm9keVVzZWQiLCJJbiIsImZvcm1EYXRhIiwiaGVhZGVycyIsInN0YXJ0c1dpdGgiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0b0Zvcm1EYXRhIiwiYmxvYiIsImpzb24iLCJKU09OIiwicGFyc2UiLCJVZSIsImRhdGEiLCJhbGxvYyIsImRlc3Ryb3kiLCJyZWFkYWJsZUVuZGVkIiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRlZCIsImV2ZXJ5Iiwiam9pbiIsImNvbmNhdCIsIkZuIiwiZ2V0Qm91bmRhcnkiLCJwaXBlIiwiS3MiLCJnaSIsIkpzIiwiZ2V0TGVuZ3RoU3luYyIsImhhc0tub3duTGVuZ3RoIiwiWHMiLCJlbmQiLCJnciIsInZhbGlkYXRlSGVhZGVyTmFtZSIsImpuIiwidmFsaWRhdGVIZWFkZXJWYWx1ZSIsIlByIiwicmF3IiwiaXNCb3hlZFByaW1pdGl2ZSIsIlByb3h5IiwiU2V0IiwiUmVmbGVjdCIsInJlZHVjZSIsInllIiwiZWwiLCJ0bCIsIkxuIiwic2UiLCJ4ZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJjb3VudGVyIiwib2siLCJyZWRpcmVjdGVkIiwiY2xvbmUiLCJyZWRpcmVjdCIsImxvY2F0aW9uIiwic3RyaW5naWZ5IiwibGUiLCJybCIsInNlYXJjaCIsImhyZWYiLCJoYXNoIiwiX2kiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicGF0aG5hbWUiLCJTaSIsIm5sIiwib2wiLCJpbCIsImhvc3QiLCJjdCIsImFsIiwicmVmZXJyZXJVUkxDYWxsYmFjayIsInJlZmVycmVyT3JpZ2luQ2FsbGJhY2siLCJyZWZlcnJlciIsInJlZmVycmVyUG9saWN5Iiwib3JpZ2luIiwic2wiLCIkIiwiQXQiLCJsbCIsInZyIiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJwYXJzZWRVUkwiLCJmb2xsb3ciLCJjb21wcmVzcyIsImFnZW50IiwiaW5zZWN1cmVIVFRQUGFyc2VyIiwiZHQiLCJ1bCIsInBhdGgiLCJvcHRpb25zIiwiSG4iLCJfciIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3N0TWVzc2FnZSIsImZsIiwiY2wiLCJzdGF0IiwiJG4iLCJkbCIsIndpIiwiaGwiLCJwbCIsIlJpIiwiYmwiLCJTciIsIm10aW1lTXMiLCJFciIsIm1sIiwiVGkiLCJyZXF1ZXN0IiwiZW1pdCIsInlsIiwicHJvY2VzcyIsInZlcnNpb24iLCJwcmVwZW5kTGlzdGVuZXIiLCJfZXZlbnRzQ291bnQiLCJzZXRUaW1lb3V0IiwicmF3SGVhZGVycyIsInN0YXR1c0NvZGUiLCJvbmNlIiwic3RhdHVzTWVzc2FnZSIsIlpfU1lOQ19GTFVTSCIsImZpbmlzaEZsdXNoIiwiY3JlYXRlR3VuemlwIiwiY3JlYXRlSW5mbGF0ZSIsImNyZWF0ZUluZmxhdGVSYXciLCJjcmVhdGVCcm90bGlEZWNvbXByZXNzIiwiY2F0Y2giLCJjb21wYXJlIiwicmVtb3ZlTGlzdGVuZXIiLCJDaSIsIkRuIiwiVyIsImNvbnNvbGUiLCJhc3NlcnQiLCJQaSIsInBhc3NpdmVMaXN0ZW5lciIsImV2ZW50IiwiY2FuY2VsYWJsZSIsImNhbmNlbGVkIiwicHJldmVudERlZmF1bHQiLCJodCIsImV2ZW50VGFyZ2V0IiwiZXZlbnRQaGFzZSIsImN1cnJlbnRUYXJnZXQiLCJzdG9wcGVkIiwiaW1tZWRpYXRlU3RvcHBlZCIsInRpbWVTdGFtcCIsInZpIiwidGFyZ2V0IiwiY29tcG9zZWRQYXRoIiwiTk9ORSIsIkNBUFRVUklOR19QSEFTRSIsIkFUX1RBUkdFVCIsIkJVQkJMSU5HX1BIQVNFIiwic3RvcFByb3BhZ2F0aW9uIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiYnViYmxlcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjb21wb3NlZCIsInNyY0VsZW1lbnQiLCJjYW5jZWxCdWJibGUiLCJyZXR1cm5WYWx1ZSIsImluaXRFdmVudCIsIndpbmRvdyIsIkV2ZW50IiwiZ2wiLCJfbCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIkVpIiwiU2wiLCJ3bCIsIlJsIiwiVGwiLCJBaSIsIkJpIiwia2kiLCJXaSIsIndyIiwiUnIiLCJCdCIsIkNsIiwibGlzdGVuZXJUeXBlIiwibGlzdGVuZXIiLCJwYXNzaXZlIiwicWkiLCJPaSIsIlBlIiwiTWFwIiwiQXJyYXkiLCJpc0FycmF5IiwiY2FwdHVyZSIsImRpc3BhdGNoRXZlbnQiLCJoYW5kbGVFdmVudCIsIkV2ZW50VGFyZ2V0IiwiVm4iLCJUciIsInB0IiwiUGwiLCJ2bCIsIk1uIiwiemkiLCJJaSIsIkVsIiwiQWwiLCJGaSIsImppIiwidmVyc2lvbnMiLCJub2RlIiwiZW52IiwiRElTQUJMRV9OT0RFX0ZFVENIX05BVElWRV9XQVJOIiwid2FybiIsIkFib3J0RXJyb3IiLCJGZXRjaEVycm9yIiwiRmlsZSIsIkZvcm1EYXRhIiwiSGVhZGVycyIsIlJlcXVlc3QiLCJSZXNwb25zZSIsImJsb2JGcm9tIiwiYmxvYkZyb21TeW5jIiwiZGVmYXVsdCIsImZldGNoIiwiZmlsZUZyb20iLCJmaWxlRnJvbVN5bmMiLCJpc1JlZGlyZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch-native/dist/node.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.1a4a356d.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/node-fetch-native/dist/shared/node-fetch-native.1a4a356d.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: () => (/* binding */ n),\n/* harmony export */   g: () => (/* binding */ f)\n/* harmony export */ });\nvar t = Object.defineProperty;\nvar o = (e, l)=>t(e, \"name\", {\n        value: l,\n        configurable: !0\n    });\nvar n = typeof globalThis < \"u\" ? globalThis :  false ? 0 : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction f(e) {\n    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\no(f, \"getDefaultExportFromCjs\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9zaGFyZWQvbm9kZS1mZXRjaC1uYXRpdmUuMWE0YTM1NmQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsSUFBRUMsT0FBT0MsY0FBYztBQUFDLElBQUlDLElBQUUsQ0FBQ0MsR0FBRUMsSUFBSUwsRUFBRUksR0FBRSxRQUFPO1FBQUNFLE9BQU1EO1FBQUVFLGNBQWEsQ0FBQztJQUFDO0FBQUcsSUFBSUMsSUFBRSxPQUFPQyxhQUFXLE1BQUlBLGFBQVcsTUFBaUIsR0FBQ0MsQ0FBTUEsR0FBQyxPQUFPQyxTQUFPLE1BQUlBLFNBQU8sT0FBT0MsT0FBSyxNQUFJQSxPQUFLLENBQUM7QUFBRSxTQUFTQyxFQUFFVCxDQUFDO0lBQUUsT0FBT0EsS0FBR0EsRUFBRVUsVUFBVSxJQUFFYixPQUFPYyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDYixHQUFFLGFBQVdBLEVBQUVjLE9BQU8sR0FBQ2Q7QUFBQztBQUFDRCxFQUFFVSxHQUFFO0FBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHByaXZ5LWlvL3dhZ21pLWRlbW8vLi9ub2RlX21vZHVsZXMvbm9kZS1mZXRjaC1uYXRpdmUvZGlzdC9zaGFyZWQvbm9kZS1mZXRjaC1uYXRpdmUuMWE0YTM1NmQubWpzP2U1MGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHQ9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBvPShlLGwpPT50KGUsXCJuYW1lXCIse3ZhbHVlOmwsY29uZmlndXJhYmxlOiEwfSk7dmFyIG49dHlwZW9mIGdsb2JhbFRoaXM8XCJ1XCI/Z2xvYmFsVGhpczp0eXBlb2Ygd2luZG93PFwidVwiP3dpbmRvdzp0eXBlb2YgZ2xvYmFsPFwidVwiP2dsb2JhbDp0eXBlb2Ygc2VsZjxcInVcIj9zZWxmOnt9O2Z1bmN0aW9uIGYoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkZWZhdWx0XCIpP2UuZGVmYXVsdDplfW8oZixcImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzXCIpO2V4cG9ydHtuIGFzIGMsZiBhcyBnfTtcbiJdLCJuYW1lcyI6WyJ0IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJvIiwiZSIsImwiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIm4iLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsImYiLCJfX2VzTW9kdWxlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGVmYXVsdCIsImMiLCJnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-fetch-native/dist/shared/node-fetch-native.1a4a356d.mjs\n");

/***/ })

};
;